#!/uxsr/bin/env python
# coding:utf-8
import time, logging, ujson, sys, datetime
from pyutil.program import metrics2 as metrics
from pyutil.program.conf import Conf
from pyutil.program.db import DAL
def get_db_dal():
    conf = Conf('/opt/tiger/ss_conf/ss/db_recommend3.conf')
    dal = DAL(host=conf.ss_recommend3_read_host,
              port=conf.ss_recommend3_read_port,
              user=conf.ss_recommend3_read_user,
              passwd=conf.ss_recommend3_read_password,
              name=conf.ss_recommend3_name)
    return dal

PREFIX = "data.abtest.info_service"
PREFIX1 = "data.abtest.info_service.vid_to_vids"


class ABTestInformationService(object):

    def __init__(self, caller):
        '''caller should be a valid P.S.M.
        '''
        self.caller = caller
        self.dal = get_db_dal()
        self._init_metrics()

    def _init_metrics(self):
        metrics.define_timer("latency", prefix=PREFIX)
        metrics.define_tagkv('caller', [self.caller])
        metrics.define_counter("count", prefix=PREFIX)
        metrics.define_counter("fail", prefix=PREFIX)

        metrics.define_timer("latency", prefix=PREFIX1)
        metrics.define_counter("count", prefix=PREFIX1)
        metrics.define_counter("fail", prefix=PREFIX1)

    def _add_call_metric(self, latency, prefix=PREFIX, is_ok=True):
        tag = {"caller" : self.caller}
        metrics.emit_counter("count", "1", prefix=prefix, tagkv=tag)
        metrics.emit_timer("latency", latency * 1000000, prefix=prefix, tagkv=tag)
        if not is_ok:
            metrics.emit_counter("fail", "1", prefix=prefix, tagkv=tag)

    def get_running_vid_to_config(self):
        '''WARNING: do not use this api before consulting weiliuxi@/hanyunfei@
           This api would return the map from vid(abtest version id) to config(abtest version configuration) of all running flights, type of vid is integer and type of config is dict
           It is up to you to do necessary cache job when using this API in high concurrency scenarios
        '''

        res = {'code' : 0, 'data' : None, 'msg' : ''}

        if not self.caller:
            res['code'] = -1
            res['msg'] = 'caller required'
            return res

        start = time.time()
        end = start
        try:
            sql = "select id, config from abtest_version_new where flight_id in (select id from abtest_flight_new where status = 1)"
            self.dal.execute(sql)
            data = {}
            for r in self.dal.cursor.fetchall():
                version_config = {}
                if r['config'] and len(r['config']) > 0:
                    try:
                        version_config = ujson.loads(r['config'])
                    except:
                        pass
                data[r['id']] = version_config
            end = time.time()
            self._add_call_metric(end - start)
            res['data'] = data
        except:
            end = time.time()
            self._add_call_metric(end - start, is_ok = False)
            res['code'] = -1
            res['msg'] = 'exception occurs, please retry later'
        return res

    def get_vid_to_vids(self):
        '''WARNING: do not use this api before consulting weiliuxi@/hanyunfei@
           It is used for significance calculation
           This api would return the map from vid(abtest version id) to vids(list of other abtest version id who share the same flight with vid) of flights who are running now or ended in last week, type of vid is integer and type of vids is list of integer
           It is up to you to do necessary cache job when using this API in high concurrency scenarios
        '''

        res = {'code' : 0, 'data' : None, 'msg' : ''}

        if not self.caller:
            res['code'] = -1
            res['msg'] = 'caller required'
            return res

        start = time.time()
        end = start
        try:
            data = {}
            now = datetime.datetime.now()
            last_week_str = (datetime.datetime(now.year, now.month, now.day) - datetime.timedelta(days=7)).strftime('%Y-%m-%d')
            sql = "select id, flight_id from abtest_version_new where flight_id in (select id from abtest_flight_new where status = 1 or end_time >= '%s')" % last_week_str # remove old flights
            self.dal.execute(sql)
            flight_to_vids = {}
            for r in self.dal.cursor.fetchall():
                if r['flight_id'] not in flight_to_vids:
                    flight_to_vids[r['flight_id']] = []
                flight_to_vids[r['flight_id']].append(r['id'])
            for vids in flight_to_vids.values():
                for vid in vids:
                    other_vids = [v for v in vids if v != vid]
                    data[vid] = other_vids
            end = time.time()
            self._add_call_metric(end - start, PREFIX1)
            res['data'] = data
        except:
            end = time.time()
            self._add_call_metric(end - start, PREFIX1, False)
            res['code'] = -1
            res['msg'] = 'exception occurs, please retry later'
        return res



import logging
import threading
import time
import random
import os


_refresh_duration = 10  # seconds

_consul_fetcher = None
_consul_fetcher_lock = threading.Lock()


def get_instances_from_consul(consul_key):
    # guarantee one fetcher in one process
    global _consul_fetcher
    global _consul_fetcher_lock

    if _consul_fetcher is None:
        with _consul_fetcher_lock:
            if _consul_fetcher is None:
                _consul_fetcher = CachedConsulFetcher()
    else:
        if not _belongs_to_current_process(_consul_fetcher):
            with _consul_fetcher_lock:
                if not _belongs_to_current_process(_consul_fetcher):
                    _consul_fetcher = CachedConsulFetcher()

    return _consul_fetcher.get_instances(consul_key)


def _belongs_to_current_process(fetcher):
    return fetcher.get_creator_pid() is None or fetcher.get_creator_pid() == os.getpid()


class ConsulFetcher(object):
    def get_creator_pid(self):
        raise NotImplementedError()

    def get_instances(self, consul_key, idc):
        raise NotImplementedError()


class CachedConsulFetcher(ConsulFetcher):
    def __init__(self):
        self.cache = {}
        self.version = {}
        self.cache_lock = threading.Lock()
        self.cache_refresh_duration = 4  # seconds
        self._pid = None

        try:
            self._pid = os.getpid()
            updater = self.RefreshThread(self, _refresh_duration)
            updater.start()
        except:
            pass

    def get_creator_pid(self):
        return self._pid

    def get_instances(self, consul_key):
        with self.cache_lock:
            if consul_key in self.cache and self.cache[consul_key] is not None:
                return self.cache[consul_key]
            else:
                instance_list = self._get_instances_from_remote(consul_key)
                self.cache[consul_key] = instance_list
                return instance_list

    @staticmethod
    def _get_instances_from_remote(consul_key):
        from pyutil.consul.bridge import translate_one

        try:
            server_list = translate_one(consul_key)
            if not isinstance(server_list[0], tuple):
                return []
            else:
                return sorted(server_list, key=lambda x: (x[0], x[1]))
        except Exception, e:
            logging.info(e)
            return []

    def _refresh(self):

        for key in self.cache.keys():
            # try catch in the loop
            try:
                instances = CachedConsulFetcher._get_instances_from_remote(key)
                with self.cache_lock:
                    self.cache[key] = instances
            except Exception as e:
                # seem like something error, sleep 50 ms
                logging.error("get consul error: %s" % str(e))
                time.sleep(0.05)

    class RefreshThread(threading.Thread):
        daemon = True

        def __init__(self, ref, refresh_duration):
            super(CachedConsulFetcher.RefreshThread, self).__init__()
            self._ref = ref
            self._refresh_duration = refresh_duration
            self.name = "ConsulUpdater"

        def run(self):
            try:
                # random so that avoid query consul at the same time
                time.sleep(random.random() * 5)
            except:
                pass

            while True:
                deviation = 0
                try:
                    start_time = time.time()
                    self._ref._refresh()
                    deviation = time.time() - start_time
                except Exception as e:
                    logging.error("refresh error: %s" % str(e))

                sleep_time = self._refresh_duration - deviation
                time.sleep(sleep_time if sleep_time > 0 else 0.01)

if __name__ == "__main__":
    import pdb
    pdb.set_trace()
    instances = get_instances_from_consul("data.abtest.versionmanager")
    print len(instances)
    if len(instances) > 0:
        print instances[0]

# -*- coding: utf-8 -*-
import sys
import logging
import datetime
import traceback
import json

from pyutil.net.get_local_ip import get_local_ip
from send_alarm import _send_alarm


class AlarmHandler(logging.Handler):
    DEFAULT_FORMAT = '%(asctime)s %(process)d %(module)s +%(lineno)d %(message)s'
    """
    Generic alarm logging handler
    把当前时间，机器ip信息和log message按指定的subject发送到recipient_list
    如果在exception处理中打log，还会把stack_trace信息发出
    如果没有指定subject，会以module路径作为subject
    如果没有指定recipient_list, 会发送到订阅了该subject的收件人，如果没有人订阅则发到默认收件人
    """

    def __init__(self, subject=None, recipient_list=None, level=logging.ERROR):
        super(AlarmHandler, self).__init__(level)
        self.subject = subject
        self.recipient_list = recipient_list
        self.setFormatter(logging.Formatter(AlarmHandler.DEFAULT_FORMAT))

    def emit(self, record):
        msg = {}
        msg['message'] = self.format(record)

        # add more custom information
        msg['time'] = str(datetime.datetime.now())
        msg['host'] = get_local_ip()
        # stack trace作为消息去重的key
        if sys.exc_info()[0] != None:
            msg['key'] = '\n'.join(traceback.format_exception(*sys.exc_info())[:-1])

        if self.subject:
            msg['subject'] = self.subject
        elif hasattr(record, 'pathname') and record.pathname:
            msg['subject'] = record.pathname
        else:
            msg['subject'] = 'no subject'

        if self.recipient_list:
            msg['recipient_list'] = self.recipient_list
        _send_alarm(json.dumps(msg))

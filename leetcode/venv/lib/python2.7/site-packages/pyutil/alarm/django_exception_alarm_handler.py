# -*- coding: utf-8 -*-
#@author xuruiqi
#@desc   基本与DjangoAlarmHandler一致，但为了迁移的平顺性
#        暂时将ssad与其它原本使用DjangoAlarmHandler的代码
#        分开。与DjangoAlarmHandler不同的地方在于加入了主
#        动频率控制，使用了PRODUCT.SUBSYS.MODULE作为
#        SUBJECT的一部分等
import datetime
import json
import logging
import sys
import time
import traceback

from django.conf import settings
from pyutil.mail import send_mail as pyutil_send_mail
from pyutil.net.get_local_ip import get_local_ip
from send_alarm import _send_alarm

class DjangoExceptionAlarmHandler(logging.Handler):
    """
    django site使用的logging handler
    与AlarmHandler相比，它会以用错误信息构造标题，并且带上request信息
    """

    def __init__(self, level=logging.ERROR, min_send_interval = 1800):
        #本地的邮件发送频率也要进行频率控制
        self.min_send_interval = min_send_interval
        self.local_freq_control = {}

        super(DjangoExceptionAlarmHandler, self).__init__(level=level)

    def emit(self, record):
        if not hasattr(settings, "ENABLE_ALARM_MAIL") or \
                not settings.ENABLE_ALARM_MAIL:
            return

        cur_timestamp = time.time()
        local_freq_key = None

        msg = {}
        msg['time'] = str(datetime.datetime.now())
        msg['host'] = get_local_ip()

        if isinstance(record.msg, unicode):
            msg['message'] = record.msg.encode('utf-8')
        else:
            msg['message'] = record.msg
        if sys.exc_info()[0] != None:
            backtrace_list = traceback.format_exception(*sys.exc_info())
            #使用strack_trace作为key进行频率控制
            local_freq_key = hash("".join(backtrace_list[-3:]))
            if local_freq_key in self.local_freq_control \
                    and self.local_freq_control[local_freq_key] \
                        + self.min_send_interval \
                            > cur_timestamp:
                logging.debug("drop one email message")
                return

            msg['key'] = local_freq_key
            msg['message'] = msg.get('message', '') + '\n' + '\n'.join(backtrace_list)

        try:
            psm = ""
            if hasattr(settings, "PRODUCT") \
                    and hasattr(settings, "SUBSYS") \
                    and hasattr(settings, "MODULE"):
                psm = "{}.{}.{}".format(
                        settings.PRODUCT,
                        settings.SUBSYS,
                        settings.MODULE
                )

            request = record.request
            subject = '%s [%s] %s (%s IP): %s' % (
                settings.EMAIL_SUBJECT_PREFIX,
                psm,
                record.levelname,
                (request.META.get('REMOTE_ADDR')
                        in settings.INTERNAL_IPS 
                        and 'INTERNAL' or 'EXTERNAL'),
                record.msg
            )
            request.META.pop('HTTP_AUTHORIZATION', None)
            request_repr = repr(request)
        except Exception as ex:
            subject = '%s %s (%s IP): %s, additional ex=[%s]' % (
                '',
                record.levelname,
                'UNKNOWN',
                record.msg,
                repr(ex)
            )
            request_repr = "request not available"

        msg['subject'] = subject
        msg['message'] = msg.get('message', '') + '\n' + request_repr

        #加入频率控制，同样的调用栈每30分钟最多打一条
        msg["seconds"]  = self.min_send_interval
        msg["num_msgs"] = 1

        try:
            #TODO(xuruiqi) 根据PRODUCT.SUBSYS.MODULE添加对应的邮件组
            msg['recipient_list'] = [admin[1] for admin in settings.ADMINS]
        except:
            pass

        #try:
        #不能这么做，因为这样所有出问题的机器都各自发一封邮件，没有频控效果
        #    #为了及时报出问题，先直接调用接口发一封邮件
        #    if local_freq_key is not None \
        #            and local_freq_key not in self.local_freq_control:
        #        pyutil_send_mail(
        #            subject = msg["subject"], \
        #            message = "host={} time={}\n".format( \
        #                    msg["host"], msg["time"]) + msg["message"], \
        #            recipient_list = msg["recipient_list"] \
        #        )
        #except:
        #    #TODO(xuruiqi) 这些except也要发报警邮件
        #    pass

        _send_alarm(json.dumps(msg))
        if local_freq_key:
            self.local_freq_control[local_freq_key] = cur_timestamp

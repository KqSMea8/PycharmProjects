#include <math.h>
#include <iostream>
#include <string>
#include <map>

using namespace std;
typedef map<long, float> Feature;
typedef vector<Feature> FeatureList;

void test(const vector< map<int, float> >& val) {
    cout << val.size() << endl;
}


float euclidean_len(const Feature& X) {
    float ret = 0;
    for (Feature::const_iterator it_x=X.begin(); it_x != X.end(); it_x++) {
        ret += it_x->second * it_x->second;
    }
    return sqrt(ret);
}

float square_sum(const Feature& X) {
    float ret = 0;
    for (Feature::const_iterator it_x=X.begin(); it_x != X.end(); it_x++) {
        ret += it_x->second * it_x->second;
    }
    return ret;
}


float dot(const Feature& X, const Feature& Y) {
    float ret = 0;
    for (Feature::const_iterator it_x=X.begin(); it_x != X.end(); it_x++) {
        Feature::const_iterator it_y = Y.find(it_x->first);
        if (it_y == Y.end()) {
            continue;
        }
        ret += it_x->second * it_y->second;
    }
    return ret;
}


float cosine_pairwise(const Feature& X, const Feature& Y) {
    float X_len = euclidean_len(X);
    float Y_len = euclidean_len(Y);
    if (X_len == 0 || Y_len == 0) {
        return 0;
    }
    float XY_dot = dot(X, Y);
    float ret = XY_dot / (X_len*Y_len);
    return ret;
}

void cosine(const FeatureList& X, const FeatureList& Y) {
    vector< vector<float> > ret;
    vector<float> X_len;
    vector<float> Y_len;
    for (size_t i=0; i<X.size(); i++) {
        const Feature& x = X[i];
        X_len.push_back(euclidean_len(x));
    }
    for (size_t i=0; i<Y.size(); i++) {
        const Feature& y = Y[i];
        Y_len.push_back(euclidean_len(y));
    }

    for (size_t i=0; i<X.size(); i++) {
        vector<float> row;
        const Feature& x = X[i];
        float x_len = X_len[i];

        for (size_t j=0; j<Y.size(); j++) {
            const Feature& y = Y[j];
            float y_len = Y_len[j];
            float XY_dot = dot(x, y);
            float ret = XY_dot / (x_len*y_len);
            row.push_back(ret);
        }

        ret.push_back(row);
    }

    //return ret;
}


float tanimoto_pairwise(const Feature& X, const Feature& Y) {
    float X_sum = square_sum(X);
    float Y_sum = square_sum(Y);
    float XY_dot = dot(X, Y);
    float ret = XY_dot / (X_sum+Y_sum-XY_dot);
    return ret;
}

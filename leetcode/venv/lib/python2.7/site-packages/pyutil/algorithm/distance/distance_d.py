import numpy as np
import scipy.spatial.distance as dist 
from pyutil.algorithm.wrap import dict_pairwise, dict2array_pairwise, dict2array
import pdb, time, math


def _dot(XA, XB):
    ret = []
    for i in range(len(XA)):
        xa = XA[i]
        row = []
        ret.append(row)
        for j in range(len(XB)):
            xb = XB[j]
            d = 0
            for k, v in xa.iteritems():
                d += v*xb.get(k, 0)
            row.append(d)
    return ret

@dict_pairwise
def dot(XA, XB):
    return _dot(XA, XB)

@dict_pairwise
def cosine(XA, XB):
    '''
    >>> cosine([{0:1, 1:1}, {0:0, 1:1}], [{0:0, 2:1}, {0:0, 1:1}])
    [[1.0, 0.29289321881345254], [1.0, 0.0]]
    >>> cosine([{0:2, 1:1}, {0:0, 1:1}], [{0:4, 2:3}, {0:1, 1:2}])
    [[0.2844582472000673, 0.20000000000000018], [1.0, 0.10557280900008414]]
    >>> cosine([{0:0, 1:1}, {4:0, 1:1}], [{0:4, 2:5}, {0:1, 1:2, 3:0}])
    [[1.0, 0.10557280900008414], [1.0, 0.10557280900008414]]
    '''

    XA_len = []
    for x in XA:
        ret = 0
        for k, v in x.iteritems():
            ret += v*v
        XA_len.append(math.sqrt(ret))
            
    XB_len = []
    for x in XB:
        ret = 0
        for k, v in x.iteritems():
            ret += v*v
        XB_len.append(math.sqrt(ret))

    ret = []
    for i in range(len(XA)):
        xa = XA[i]
        xa_len = XA_len[i]
        row = []
        ret.append(row)
        for j in range(len(XB)):
            xb = XB[j]
            xb_len = XB_len[j]
            if not xa_len or not xb_len:
                row.append(np.nan)
            else:
                d = 0
                for k, v in xa.iteritems():
                    d += v*xb.get(k, 0)
                row.append(1 - float(d)/(xa_len*xb_len))
    return ret

@dict_pairwise
def jaccard2(XA, XB):
    """
    >>> jaccard2([{0:1, 1:2}, {0:0.2, 1:0.8}], [{0:2, 1:3}, {0:0.2, 1:0.8}])
    [[0.19999999999999996, 0.5360824742268041], [0.7426470588235294, 0.0]]
    """
    XA_len = []
    for x in XA:
        ret = 0 
        for k, v in x.iteritems():
            ret += v*v
        XA_len.append(ret)

    XB_len = []
    for x in XB:
        ret = 0 
        for k, v in x.iteritems():
            ret += v*v
        XB_len.append(ret)

    ret = _dot(XA, XB) 

    for i in range(len(ret)): 
        for j in range(len(ret[i])):
            v = ret[i][j]
            div = XA_len[i]+XB_len[j]-v
            ret[i][j] = (1 - float(v)/div) if div > 0 else np.nan 
    return ret 


if __name__ == '__main__':
    import doctest
    doctest.testmod()

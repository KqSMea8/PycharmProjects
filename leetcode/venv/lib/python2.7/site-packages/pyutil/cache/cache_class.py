# coding: utf8
import time
import zlib
try:
    import cPickle as pickle
except ImportError:
    import pickle
from pyutil.program import metrics2 as metrics


class CacheClass(object):
    cache = None
    version = 1
    timeout = 0
    metrics_prefix = ''
    metrics_inited = False

    def __init__(self, zip_on=False, zip_level=1):
        """
        :param zip_on: bool, 开启压缩（为确保平滑过渡，开启时请修改cache version）
        :param zip_level: [0, 9]，0基本没压缩，默认是1
        """
        self.zip_on = zip_on
        self.zip_level = zip_level

    def make_key(self, item_id):
        return '%s:%s:%s' % (self.__class__.__name__, item_id, self.version)

    def get_metrics_prefix(self):
        # 如果用构造函数初始化，需要所有使用的地方都修改才行，所以记录初始化标识。
        if not self.metrics_inited:
            self._init_metric()
            self.metrics_inited = True
        return self.metrics_prefix

    def _init_metric(self):
        from pyutil.text.util import camel_to_snake
        self.metrics_prefix = 'web.cache_class.%s' % camel_to_snake(self.__class__.__name__)

        metrics.define_counter('db_count', prefix=self.metrics_prefix)
        metrics.define_counter('mc_count', prefix=self.metrics_prefix)
        metrics.define_counter('query_count', prefix=self.metrics_prefix)
        metrics.define_timer('total_cost', units='us', prefix=self.metrics_prefix)
        metrics.define_timer('mc_get_cost', units='us', prefix=self.metrics_prefix)
        metrics.define_timer('mc_set_cost', units='us', prefix=self.metrics_prefix)
        metrics.define_timer('db_cost', units='us', prefix=self.metrics_prefix)

    def pack(self, item):
        try:
            if self.zip_on:
                data = pickle.dumps(item)
                zip_data = zlib.compress(data, self.zip_level)
                return zip_data
            else:
                return item
        except:
            return item

    def unpack(self, raw_item):
        try:
            if self.zip_on:
                try:
                    data = zlib.decompress(raw_item)
                    item = pickle.loads(data)
                    return item
                except:
                    return raw_item
            else:
                return raw_item
        except:
            return raw_item

    def set_multi(self, data):
        data_ = {}
        for item_id, item in data.iteritems():
            key = self.make_key(item_id)
            raw_item = self.pack(item)
            data_[key] = raw_item
        self.cache.set_multi(data_, self.timeout)

    def mset(self, data):
        self.set_multi(data)

    def delete(self, item_id):
        key = self.make_key(item_id)
        self.cache.delete(key)

    def set(self, item_id, item):
        key = self.make_key(item_id)
        raw_item = self.pack(item)
        self.cache.set(key, raw_item, self.timeout)

    def get(self, item_id, use_cache=True, cache_only=False):
        item_dict = self.get_multi_as_dict([item_id], use_cache, cache_only)
        return item_dict.get(item_id)

    def mget(self, item_ids, use_cache=True, cache_only=False):
        return self.get_multi_as_dict(item_ids, use_cache, cache_only)

    def get_multi_as_dict(self, item_ids, use_cache=True, cache_only=False):
        st0 = time.time()
        if not item_ids:
            return {}

        query_count = len(item_ids)
        db_count = 0
        mc_count = 0
        db_cost = 0
        mc_get_cost = 0
        mc_set_cost = 0

        if not use_cache:
            db_count = len(item_ids)
            st = time.time()
            data = self._get_multi_as_dict(item_ids)
            db_cost = time.time() - st
            st = time.time()
            self.set_multi(data)
            mc_set_cost = time.time() - st
            total_cost = time.time()-st0
            self._log_and_add_metric(query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost)
            return data

        item_key_dict = {}
        for item_id in item_ids:
            key = self.make_key(item_id)
            item_key_dict[item_id] = key

        st = time.time()
        raw_items = self.cache.get_multi(item_key_dict.values())
        mc_count = len(raw_items)
        mc_get_cost = time.time() - st

        data = {}
        fall_item_ids = []
        for item_id in item_ids:
            key = item_key_dict.get(item_id)
            raw_item = raw_items.get(key)
            if raw_item is None:
                fall_item_ids.append(item_id)
                continue
            item = self.unpack(raw_item)
            data[item_id] = item

        if cache_only:
            total_cost = time.time()-st0
            self._log_and_add_metric(query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost)
            return data

        if fall_item_ids:
            db_count = len(fall_item_ids)
            st = time.time()
            data_ = self._get_multi_as_dict(fall_item_ids)
            db_cost = time.time() - st

            if data_:
                st = time.time()
                self.set_multi(data_)
                mc_set_cost = time.time() - st
                data.update(data_)

        total_cost = time.time()-st0
        self._log_and_add_metric(query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost)
        return data

    def _log_and_add_metric(self, query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost):
        self._add_metric(query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost)
        self._log(query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost)

    def _add_metric(self, query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost):
        prefix = self.get_metrics_prefix()
        metrics.emit_counter('query_count', query_count, prefix)
        metrics.emit_counter('mc_count', mc_count, prefix)
        metrics.emit_counter('db_count', db_count, prefix)
        metrics.emit_timer('total_cost', int(total_cost * 1000000), prefix)
        metrics.emit_timer('mc_get_cost', int(mc_get_cost * 1000000), prefix)
        metrics.emit_timer('db_cost', int(db_cost * 1000000), prefix)
        metrics.emit_timer('mc_set_cost', int(mc_set_cost * 1000000), prefix)

    def _log(self, query_count, mc_count, db_count, total_cost, mc_get_cost, db_cost, mc_set_cost):
        pass

    def _get_multi_as_dict(self, item_ids):
        return self._mget(item_ids)

    def _mget(self, item_ids):
        return {}

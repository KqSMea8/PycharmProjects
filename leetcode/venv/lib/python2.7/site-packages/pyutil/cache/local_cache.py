"Thread-safe in-memory cache backend."

import time
from copy import deepcopy
import threading

MAX_TIMEOUT = 86400*30

# Global in-memory store of cache data. Keyed by name, to provide
# multiple named local memory caches.

class FakeLock():
    def reader_enters(self):
        pass
    def reader_leaves(self):
        pass
    def writer_enters(self):
        pass
    def writer_leaves(self):
        pass


class SimpleLock():
    def __init__(self):
        self.lock = threading.Lock()

    def reader_enters(self):
        pass
    def reader_leaves(self):
        pass

    def writer_enters(self):
        self.lock.acquire()

    def writer_leaves(self):
        self.lock.release()


class LocMemCache:
    def __init__(self, name='default', timeout=0, max_entries=300, 
            cull_frequency=3, lock=True, copy=True):

        self.default_timeout = timeout if timeout else MAX_TIMEOUT
        self._max_entries = max_entries
        self._cull_frequency = cull_frequency

        self._cache = {}
        self._expire_info = {}
        self._lock = SimpleLock() if lock else FakeLock()
        self._copy = copy


    def validate_key(self, key):
        pass

    def add(self, key, value, timeout=None):
        self.validate_key(key)
        self._lock.writer_enters()
        try:
            exp = self._expire_info.get(key)
            if exp is None or exp <= time.time():
                self._set(key, value, timeout)
                return True
            return False
        finally:
            self._lock.writer_leaves()

    def get(self, key, default=None):
        self.validate_key(key)
        self._lock.reader_enters()
        try:
            exp = self._expire_info.get(key)
            if exp is None:
                return default
            elif exp > time.time():
                value = self._cache[key]
                if self._copy:
                    return deepcopy(value)
                return value
        finally:
            self._lock.reader_leaves()
        self._lock.writer_enters()
        try:
            try:
                del self._cache[key]
                del self._expire_info[key]
            except KeyError:
                pass
            return default
        finally:
            self._lock.writer_leaves()


    def get_multi(self, keys):
        kvs = {}
        for key in keys:
            value = self.get(key)
            if value != None:
                kvs[key] = value
        return kvs

    def _set(self, key, value, timeout=None):
        if len(self._cache) >= self._max_entries:
            self._cull()
        if timeout is None:
            timeout = self.default_timeout
        if self._copy:
            self._cache[key] = deepcopy(value)
        else:
            self._cache[key] = value
        self._expire_info[key] = time.time() + timeout

    def set(self, key, value, timeout=None):
        self.validate_key(key)
        self._lock.writer_enters()
        # Python 2.4 doesn't allow combined try-except-finally blocks.
        try:
            self._set(key, value, timeout)
        finally:
            self._lock.writer_leaves()

    def set_multi(self, kvs, timeout=None):
        for key, value in kvs.iteritems():
            self.set(key, value, timeout)
        

    def has_key(self, key):
        self.validate_key(key)
        self._lock.reader_enters()
        try:
            exp = self._expire_info.get(key)
            if exp is None:
                return False
            elif exp > time.time():
                return True
        finally:
            self._lock.reader_leaves()

        self._lock.writer_enters()
        try:
            try:
                del self._cache[key]
                del self._expire_info[key]
            except KeyError:
                pass
            return False
        finally:
            self._lock.writer_leaves()

    def _cull(self):
        if self._cull_frequency == 0:
            self.clear()
        else:
            doomed = [k for (i, k) in enumerate(self._cache) if i % self._cull_frequency == 0]
            for k in doomed:
                self._delete(k)

    def _delete(self, key):
        try:
            del self._cache[key]
        except KeyError:
            pass
        try:
            del self._expire_info[key]
        except KeyError:
            pass

    def delete(self, key):
        self.validate_key(key)
        self._lock.writer_enters()
        try:
            self._delete(key)
        finally:
            self._lock.writer_leaves()

    def clear(self):
        self._cache.clear()
        self._expire_info.clear()


if __name__ == '__main__':
    cache = LocMemCache(copy=False)
    cache.set('test_key', 'value', 3)
    while True:
        print cache.get('test_key')
        time.sleep(2)

    

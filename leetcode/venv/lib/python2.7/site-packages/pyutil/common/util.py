#coding=utf8
import re
import ctypes
import os

class TimeSpec(ctypes.Structure):
    _fields_ = [
        ('tv_sec', ctypes.c_long),
        ('tv_nsec', ctypes.c_long)
    ]

librt = ctypes.CDLL('librt.so.1', use_errno=True)
clock_gettime = librt.clock_gettime
clock_gettime.argtypes = [ctypes.c_int, ctypes.POINTER(TimeSpec)]


def cputime_us():
    CLOCK_PROCESS_CPUTIME_ID = 2  # see <linux/time.h>
    t = TimeSpec()
    if clock_gettime(CLOCK_PROCESS_CPUTIME_ID, ctypes.pointer(t)) != 0:
        errno_ = ctypes.get_errno()
        raise OSError(errno_, os.strerror(errno_))
    return t.tv_sec * 1000000 + t.tv_nsec / 1000

def tran_group_id(group_id):
    group_id = long(group_id)
    if group_id > 2147483647:
        group_id -= 4294967296
    return group_id

def fix_group_id(group_id):
    group_id = long(group_id)
    if group_id < 0:
        group_id += 4294967296
    return group_id

ESCAPE = re.compile(r'[\\"\b\f\n\r\t]')
ESCAPE_DCT = {
    '\\': '\\\\',
    '"': '\\"',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
}

def encode_basestring(s):
    def replace(match):
            return ESCAPE_DCT[match.group(0)]
    return ESCAPE.sub(replace, s)

def version_cmp(v1, v2):
    '''
    @ param: v1, 支持数字、字母组合,按字符'.'隔开
    @ param: v2, 支持数字、字母组合,按字符'.'隔开
    @ return: -1(v1<v2), 0(v1==v2), 1(v1>v2)

    print '2.1.9 > 2.1.9.1 = ', version_cmp('2.1.9', '2.1.9.1')
    print '2.1.9 > 2.3 = ', version_cmp('2.1.9', '2.3')
    print '2.2 > 2.1 = ', version_cmp('2.2', '2.1')
    print '2.2 > 2.2 = ', version_cmp('2.2', '2.2')
    print '2.2.a > 2.2 = ', version_cmp('2.2.a', '2.2')
    print '2.2 > 2.2.a = ', version_cmp('2.2', '2.2.a')
    print '200 > 220 = ', version_cmp(200, 220)

    '''
    def smart_str_to_value(v):
        if v.isdigit():
            return long(v)
        else:
            return v

    v1_data = [ smart_str_to_value(v) for v in str(v1).split('.')]
    v2_data = [ smart_str_to_value(v) for v in str(v2).split('.')]
    len_v1_data = len(v1_data)
    len_v2_data = len(v2_data)
    if len_v2_data > len_v1_data:
        for i in range(len_v2_data):
            if i+1 > len_v1_data:
                return -1
            if v2_data[i] > v1_data[i]:
                return -1
            elif v2_data[i] < v1_data[i]:
                return 1
            else:
                continue
        return 0
    else:
        for i in range(len_v1_data):
            if i+1 > len_v2_data:
                return 1
            if v1_data[i] > v2_data[i]:
                return 1
            elif v1_data[i] < v2_data[i]:
                return -1
            else:
                continue
        return 0


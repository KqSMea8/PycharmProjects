#coding=utf8
from consul import Consul
import random
import time
import logging
import json
from pyutil.consul import defaults, is_perf_test, add_perf_prefix

SERVICE_SUFFIX = "service"
WEAK_CONSISTENCY = "stale"

class ServiceDiscoveryException(Exception):
    def __init__(self, message, errors=None):
        super(Exception, self).__init__(message)
        self.errors = errors

def dump_tags(tags):
    # handle case 0 only
    return ["%s:%s" % (k, tags[k]) for k in tags]

def load_tags(service_tags):
    # case 0: ['k0:v0'] => {'k0': 'v0'}
    # case 1: ['k0:v0', 'master'] => {'master': True}
    if service_tags is None:
        return {}
    return {kv[0]: kv[1] if len(kv) > 1 else True for kv in map(lambda x: x.split(':'), service_tags)}

def load_service_node(service_node):
    return (service_node['Address'],
            int(service_node['Port']),
            load_tags(service_node['Tags']))

def catch_sd_exception(fn):
    def wrapped(*args, **kwargs):
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            raise ServiceDiscoveryException(str(e), e)
    return wrapped

def strip_domain(s):
    return s.strip(".")

class ServiceDiscovery(Consul):

    def __init__(self, agent_host=defaults.agent_host, agent_port=defaults.agent_port, dc=None, domain=None):
        Consul.__init__(self, host=agent_host, port=agent_port)
        self.random = random.Random()
        if not dc or not domain:
            # use specified dc and domain if any
            self.dc, self.domain = self.get_agent_dc_domain()
        else:
            self.dc = dc
            self.domain = domain
        self.domain = strip_domain(self.domain)

    @catch_sd_exception
    def get_agent_config(self):
        return self.agent.self()['Config']

    def get_agent_dc_domain(self):
        config = self.get_agent_config()
        return config['Datacenter'], config['Domain']

    # canonical service name, e.g. "comment" => "comment.hy.byted.org."
    # can be further used as DNS domain name
    def canonical_name(self, service):
        if service.endswith(self.domain):
            return service
        return ".".join([service, SERVICE_SUFFIX, self.dc, self.domain])

    # convert canonical service name to (service, dc)
    def resolve_name(self, name):
        name = strip_domain(name)
        # strip domain
        if name.endswith(self.domain):
            name = name[0:-len(self.domain)-1]
        # service part indicates a consul service
        separator = ".%s" % SERVICE_SUFFIX
        if name.find(separator) > 0:
            service, dc = name.split(separator)
            dc = strip_domain(dc) if len(dc) > 1 else self.dc
        else:
            service, dc = name, self.dc
        return service, dc

    # python-consul do not have consistency option provided with health.service, doing without it anyway
    def health_service(self, service, consistency, passing, dc):
        def callback(response):
            data = json.loads(response.body)
            return response.headers['X-Consul-Index'], data
        params = {}
        if passing:
            params['passing'] = '1'
        if consistency in ('consistent', 'stale'):
            params[consistency] = '1'
        if dc:
            params['dc'] = dc
        return self.http.get(
            callback,
            '/v1/health/service/%s' % service, params=params)

    @catch_sd_exception
    def health_node(self, node):
        path = "/v1/health/node/%s" % node
        return self.http.get(lambda response: json.loads(response.body), path)

    # WARN: use weak consistency, this causes stale read
    # may explicitly specific otherwise (values: 'default', 'consistent' or 'stale')
    # 'default': R/W goes to leader without quorum verification of leadership
    # 'consistency': R/W goes to leader with quorum verification of leadership (extra RTT)
    # 'stale': R goes to any server, W goes to leader
    @catch_sd_exception
    def lookup(self, name, consistency=WEAK_CONSISTENCY):
        if is_perf_test:
            name = add_perf_prefix(name)
        try:
            service, dc = self.resolve_name(name)
            index, items = self.health_service(service, consistency, True, dc)
            nodes = [dict(item['Service'].items() + item['Node'].items()) for item in items]
            endpoints = map(load_service_node, nodes)
            logging.debug("[ServiceDiscovery] lookup %s endpoints %s" % (name, endpoints))
            return endpoints
        except Exception as e:
            # if fail, fallback to WEAK_CONSISTENCY
            # this can occur during leader failure, hence try out follower nodes
            logging.exception(e)
            logging.error("Failed to lookup with %s consistency, try %s" % (consistency, WEAK_CONSISTENCY))
            if consistency != WEAK_CONSISTENCY:
                return self.lookup(name, WEAK_CONSISTENCY)

    def _id(self, service, port):
        return "%s-%s" % (service, port)

    def _register(self, name, port, tags, ttl=None, script=None, safemode=False):
        service, dc = self.resolve_name(name)
        service_id = self._id(service, port)
        if dc != self.dc:
            raise ServiceDiscoveryException('Datacenter mismatch: %s <-> %s' % (dc, self.dc))
        service_tags = dump_tags(tags)
        check = {}
        if script:
            check['script'] = script
            check['interval'] = '%ss' % ttl
        elif ttl:
            check['ttl'] = '%ss' % ttl
        if not self.agent.service.register(service, service_id=service_id, port=port, tags=service_tags, check=check):
            raise ServiceDiscoveryException('Failed to register')
        return service_id

    def _deregister(self, id, safemode=False):
        if not self.agent.service.deregister(id):
            raise ServiceDiscoveryException('Failed to deregister')

    def _pass(self, check_id):
        if not self.agent.check.ttl_pass(check_id):
            raise ServiceDiscoveryException('Failed to update lease')

    @catch_sd_exception
    def announce(self, name, port, tags, ttl=120):
        if is_perf_test:
            name = add_perf_prefix(name)
        pass_success = False
        service, dc = self.resolve_name(name)
        service_id = self._id(service, port)
        check_id = "service:%s" % service_id
        try:
            # run a quick TTL pass first, register may take arbitrary time to finish
            self._pass(check_id)
            pass_success = True
        except:
            pass
        if not pass_success:
            self._register(name, port, tags, ttl)
            self._pass(check_id)
            logging.info("[ServiceDiscovery] registered %s, id %s" % (name, service_id))
        alpha = random.random() * 0.5
        next_lease = max(0.5, alpha * ttl)
        logging.debug("[ServiceDiscovery] leased %s next_lease %s" % (service_id, next_lease))
        return next_lease

    @catch_sd_exception
    def bring_up(self, name, port, tags, script=None, safemode=False):
        if is_perf_test:
            name = add_perf_prefix(name)
        ttl = None if script is None else 30
        self._register(name, port, tags, ttl=ttl, script=script, safemode=safemode)
        return True

    @catch_sd_exception
    def bring_down(self, name, port, safemode=False):
        if is_perf_test:
            name = add_perf_prefix(name)
        name, _ = self.resolve_name(name)
        service_id = "%s-%s" % (name, port)
        self._deregister(service_id, safemode=safemode)
        return True

    @catch_sd_exception
    def translate_name(self, name, cb=None):
        def callback(response):
            items = json.loads(response.body)
            return [(x['Host'], x['Port'], x['Tags']) for x in items]
        if cb is None:
            cb = callback
        return self.http.get(cb, '/v1/lookup/name', params={'name': name})

    @catch_sd_exception
    def translate_uri(self, uri):
        def callback(response):
            return json.loads(response.body)
        return self.http.get(callback, '/v1/lookup/uri', params={'uri': uri})

    @catch_sd_exception
    def translate_conf(self, conf):
        start = time.time()
        def callback(response):
            end = time.time()
            diff = end - start
            if diff > 1:
                logging.warn("/v1/lookup/conf too slow: %s", diff)
            if response.code != 200:
                logging.warn("/v1/lookup/conf resp code: %s", response.code)
            return json.loads(response.body)
        return self.http.put(callback, '/v1/lookup/conf', data=json.dumps(conf))


if __name__ == '__main__':
    sd = ServiceDiscovery('127.0.0.1', defaults.agent_port, 'hy', 'byted.org')
    print(sd.translate_name('adengine'))
    print(sd.translate_uri('consul:adengine'))
    print(sd.translate_conf({'a':'b','c':'consul:adengine'}))

    print(load_tags(['a:b', 'c:d', 'a:x', 'master']))
    print(dump_tags(load_tags(['a:b', 'c:d', 'a:x', 'master'])))
    assert(sd.canonical_name('consul') == "consul.service.hy.byted.org")
    assert(sd.resolve_name('consul') == ("consul", "hy"))
    assert(sd.resolve_name('consul.service.byted.org') == ("consul", "hy"))
    assert(sd.resolve_name('consul.service.hy.byted.org') == ("consul", "hy"))
    assert(sd.resolve_name('consul.service.aws.byted.org') == ("consul", "aws"))
    assert(sd.resolve_name('consul.service.hy.byted.org.') == ("consul", "hy"))
    assert(sd.resolve_name('consul.service.db.byted.org.') == ("consul", "db"))
    assert(sd.resolve_name('consul.service.aws.byted.org.') == ("consul", "aws"))
    assert(sd.resolve_name('comment-service.service.hy.byted.org') == ("comment-service", "hy"))
    assert(sd.resolve_name('comment-service') == ("comment-service", "hy"))
    assert(sd.resolve_name('comment.service.aws') == ("comment", "aws"))
    assert(sd.resolve_name('comment-service.service.aws') == ("comment-service", "aws"))
    assert(len(sd.lookup('consul.service.hy.byted.org.')) > 0)
    assert(len(sd.lookup('cons222ul.service.hy.byted.org.')) == 0)
    while True:
        lease = sd.announce('testsvc', 11111, {'master': True})
        time.sleep(lease)

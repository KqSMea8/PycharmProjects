#coding=utf8
from consul import Consul
import random
import time
import logging
import ujson
import hashlib
from pyutil.consul import defaults
from datetime import datetime
from threading import Thread
from threading import Lock
from pyutil.program import metrics2 as metrics
from pyutil.consul import is_python3
from pyutil.idc.idc import get_idc

#单开线程,轮询localagent,更新数据
#用户api直接从缓存中取数据
#用户只能关注当前机房,指定service全部的配置
#getStatusValue()返回当前的状态以及历史最新的数据
#getDegradeValue()用于降级场景，从agent获取配置失败，则返回空
#其他场景后续可以扩展


DEFAULT_DEMOTION_CONSUL_HOST = '{IDC}-demotion-kv.byted.org'.format(IDC=get_idc().value)


class DynamicConfig(object):

#INIT表示还未从consul获取数据
#SUCC表示已经从consul获取数据，且数据符合标准
#FAIL表示从consul获取数据失败，或者数据不符合标准
    class STATUS:
        INIT = 1
        SUCC = 2
        FAIL = 3

    def __init__(self,
                 service,
                 host=defaults.agent_host,
                 port=defaults.agent_port,
                 consistency='stale',
                 start=False,
                 ):
        self.thread_running = start
#需要返回的信息和当前状态
        self.value = {} # old demotion value
        self.status = DynamicConfig.STATUS.INIT
        self.ratio_plan = {}  #ratio-plan dict
#lock用来保证状态的一致，不要读到中间状态（设置了status，但是还没设置value）,而不是用来保证value的读写，因为现在value都只写一次
        self.lock = Lock()
        metrics.define_counter(service, 'num', prefix='infr.config')
#5s更新一次，因为agent client端已经加了缓存，请求快点对agent server无压力
#Thread是否会报异常?
        _t = Thread(target=self._get_config, args=(host, port, consistency, service, self.value, 5, self.lock), name = 'DynamicConfig')
        _t.setDaemon(True)
        _t.start()
        random.seed(datetime.now())

    def _get_config(self, host, port, consistency, service, value, update_time, lock):
#默认超时1.5s,连接超时1.5s，读取超时也是1.5秒
#确认有重连
#Consul的构造全部是赋值,无异常
        consul = Consul(host=host, port=port, consistency=consistency)
        old_index = -1
        while True:
            if self.thread_running:
                try:
#每个service对应一个key，value为json
#暂不比较index，不过渡优化
                    if is_python3:
                        index, data = consul.kv.get('config/' + service)
                    else:
                        index, data =  consul.kv.get('config/' + service, service_config = True)
                    #打metric，用index做为tag
                    if index != old_index:
                        metrics.emit_counter(service, 1, prefix='infr.config')
                        old_index = index
                        logging.info("emit dynamic_config metric" + str(index))
                    # clear plan ratio list
                    self.plan_ratio = []
#不存在service对应的key
                    if data is None:
                        with lock:
                            # clear plan ratio list
                            self.ratio_plan = {}
                            self.value = {}
                            self.status = DynamicConfig.STATUS.SUCC
                    else:
#json需要是一个map结构，需要做检查
#检查失败的情况，不污染value
                        if is_python3:
                            tmp_map = ujson.loads(data.get('Value').decode('utf-8'))
                        else:
                            tmp_map = ujson.loads(data.get('Value'))
                        now = int(time.time())
                        if isinstance(tmp_map, dict):
                            with lock:
                                self.ratio_plan = {}
                                start = int(tmp_map.get("_start", "0"))
                                end = int(tmp_map.get("_end", "0"))
                                if start != 0 and now < start:
                                    self.value = {}
                                    self.status = DynamicConfig.STATUS.SUCC
                                elif end != 0 and now > end:
                                    self.value = {}
                                    self.status = DynamicConfig.STATUS.SUCC
                                elif '_raw_plan_list_' in tmp_map and type(tmp_map['_raw_plan_list_']) == list:
                                    pr_list = tmp_map['_raw_plan_list_']
                                    for pr in pr_list:
                                        if '_ratio_' not in pr or '_plan_' not in pr:
                                            continue
                                        r, p = pr['_ratio_'], pr['_plan_']
                                        if r in self.ratio_plan:
                                            self.deepUpdate(self.ratio_plan[r], p)
                                        else:
                                            self.ratio_plan[r] = p
                                    if len(self.ratio_plan) > 0:
                                        kl = sorted(self.ratio_plan.keys(), reverse=True)
                                        for i in range(0, len(kl)):
                                            ki = kl[i]
                                            for j in range(i, len(kl)):
                                                kj = kl[j]
                                                self.deepUpdate(self.ratio_plan[kj], self.ratio_plan[ki])

                                    del tmp_map['_raw_plan_list_']
                                    # keep original value
                                    self.value = tmp_map
                                    self.status = DynamicConfig.STATUS.SUCC

                                else:
                                    self.value = tmp_map
                                    self.status = DynamicConfig.STATUS.SUCC
                        else:
                            self.status = DynamicConfig.STATUS.FAIL
                except Exception as e:
                    logging.warn('[DynamicConfig] Failed to get config: %s' % str(e))
#从agent client获取数据失败或者解析value失败
                    self.status = DynamicConfig.STATUS.FAIL
            time.sleep(random.uniform(1, update_time))

    def getStatusValue(self, shard_id=None):
        #self.start()
        #with self.lock:
        #    return self.status, self.value
        value = self.getDegradeValue(shard_id)
        with self.lock:
            return self.status, value

#从agent获取配置失败，返回空，用于降级
# pass shard_id as ratio support
    def getDegradeValue(self, shard_id=None):
        self.start()
        with self.lock:
            if self.status == DynamicConfig.STATUS.FAIL:
                return {}
            else :
                if len(self.ratio_plan) > 0:
                    r = int(hashlib.sha1(shard_id).hexdigest(), 16) % 100 if shard_id else random.randint(0, 99)
                    for k in sorted(self.ratio_plan.keys()):
                        if r < k:
                            return self.ratio_plan[k]
                    return {}
                else:
                    return self.value

    def start(self):
        self.thread_running = True

    def stop(self):
        self.thread_running = False

    def deepUpdate(self, dst, src):
        for k in src.keys():
            i = src[k]
            if type(i) == dict:
                if k not in dst:
                    dst[k] = {}
                self.deepUpdate(dst[k], src[k])
            else:
                dst[k] = i

if __name__ == '__main__':
    dc = DynamicConfig(service = "sort_demo", host='demotion-kv.byted.org', start = False)
    for i in range(1, 210):
        status, value = dc.getStatusValue('adsfasfadsdfas')
        print('status : ' + str(status))
        print('value : ' + str(value))
        value = dc.getDegradeValue('1232dfdw')
        print('*** value : ' + str(value))
        value = dc.getDegradeValue()
        print('random: *** value:' + str(value))
        time.sleep(1)
    dc.stop()

#coding=utf8
import sched
import time
import signal
import logging
import os
from threading import Timer, Lock
from pyutil.consul.safety import check_safety, get_process_attr
from pyutil.consul.discovery import ServiceDiscovery, ServiceDiscoveryException
from pyutil.consul import is_python3

if is_python3:
    import setproctitle
else:
    import ss_lib.pytopology.utils.setproctitle as setproctitle

sd = None
defined_services = []
scheduler = sched.scheduler(time.time, time.sleep)

running_timers = []
running_timers_lock = Lock()
stopped = False

def alter_proc_suffix(suffix):
    global proc_title
    setproctitle.setproctitle(" ".join(proc_title + [suffix]))

def init_register(conf=None):
    global sd, proc_title
    if sd:
        # already init
        return
    if conf:
        host = conf.consul_agent_host or None
        port = int(conf.consul_agent_port) or None
        sd = ServiceDiscovery(agent_host=host, agent_port=port)
    else:
        sd = ServiceDiscovery()
    proc_title = get_process_attr(os.getpid(), 'cmdline').split('\0')

def define_service(name, port, tags={}, ttl=60):
    global defined_services
    defined_services.append((name, port, tags, ttl))
    logging.info("Defined service %s, port %s, tags %s, ttl %s" % (name, port, tags, ttl))

def register_service(name, port, tags={}, ttl=120, repeated=False, attempt=0):
    global sd, running_timers_lock, running_timers, stopped
    if not sd:
        logging.error("Call init_register first")
        return
    try:
        next_lease = sd.announce(name, port, tags, ttl)
        attempt = 0
    except ServiceDiscoveryException as e:
        logging.exception(e)
        # bounded exponential backoff
        next_lease = min(0.2 * 2 ** attempt, ttl * 0.5)
        attempt += 1
    if not repeated:
        return
    next_timer = Timer(next_lease, register_service, (name, port, tags, ttl, repeated, attempt))
    next_timer.daemon = True
    with running_timers_lock:
        if not stopped:
            running_timers.append(next_timer)
            next_timer.start()

def ensure_safety():
    return all(map(lambda x: check_safety(sd, x), map(lambda x:x[0], defined_services)))

def start_register(disable_safety=False):
    global sd, defined_services, stopped
    if not sd:
        logging.error("Call init_register first")
        return
    if not disable_safety and not ensure_safety():
        logging.warn("Not safe to register, skipping")
        alter_proc_suffix('[register_disabled]')
        return
    logging.info("Starting to register defined services")
    stopped = False
    for name, port, tags, ttl in defined_services:
        register_service(name, port, tags, ttl, True)
    alter_proc_suffix('[registered]')

def stop_register():
    global sd, running_timers_lock, running_timers, stopped
    if not sd:
        logging.error("Call init_register first")
        return
    stopped = True
    logging.info("Stopping to register defined services")
    with running_timers_lock:
        for timer in running_timers:
            timer.cancel()
    alter_proc_suffix('[unregistered]')

def setup_signal_handlers(start_signal=signal.SIGUSR2, stop_signal=signal.SIGPWR):
    signal.signal(start_signal, lambda x, y: start_register())
    signal.signal(stop_signal, lambda x, y: stop_register())

if __name__ == '__main__':
    root = logging.getLogger()
    root.setLevel(logging.DEBUG)

    init_register()
    setup_signal_handlers()
    define_service('data.arch.testsvc', 60000, ttl=2)
    start_register()
    while True:
        time.sleep(1)

import getpass
import subprocess
import json
import logging
import requests
import os
import time
import random
import psutil
from pyutil.net.get_local_ip import get_local_ip
from pyutil.consul import is_python3

SERVICE_PRECONDITION_KEY = "service/%s/precondition"

# two conditions must both hold to ensure safety:
# 1. run under tiger
# 2. parent process is supervise
DEFAULT_CHECKS = {'user': ['tiger'], 'parent': ['supervise', 'systemd']}

def get_process_attr(pid, name):
    result = subprocess.check_output("cat /proc/%d/%s" % (pid, name), shell=True)
    if is_python3:
        return result.decode('utf-8').strip()
    else:
        return result.strip()

# get a list of commands of each parent, tracing down to init (pid=1)
def get_commands_of_parents():
    pid = os.getppid()
    commands = []
    while pid != 1:
        try:
            commands.append(get_process_attr(pid, 'comm'))
            pid = psutil.Process(pid).ppid()
        except:
            # perhaps access to the process is denied, stop tracing right here
            # this won't happen to processses launched in same user
            # and, at least ppid of current process is captured, no harm done
            logging.warn('Failed to get command of process %s' % pid)
            break
    return set(commands)

def local_ams_tags():
    local_ip = get_local_ip()
    try:
        r = requests.get("https://ams.byted.org/api.php?token=6eed2a47fe5e82fa4599b7ca2d6e8838&method=host.tag.get&ip=%s" % local_ip, verify=False)
        return json.loads(r.text)['response']['tags']
    except Exception as e:
        logging.error('Failed to load ams tags')
        logging.exception(e)
    return []

def load_precondition(sd, service):
    idx, data = sd.kv.get(SERVICE_PRECONDITION_KEY % service)
    if data:
        if is_python3:
            checks = json.loads(data['Value'].decode('utf-8'))
        else:
            checks = json.loads(data['Value'])
    else:
        # make copy for modification
        checks = dict(DEFAULT_CHECKS)
        idx = 0
    return idx, checks

def save_precondition(sd, service, idx, checks):
    return sd.kv.put(SERVICE_PRECONDITION_KEY % service,
                     json.dumps(checks), cas=idx)

def check_safety(sd, service):
    _, checks = load_precondition(sd, service)
    for k, v in checks.items():
        if k == 'ams_tag':
            if not any(x in v for x in local_ams_tags()):
                logging.warn("No associated with ams tag in %s" % v)
                return False
        if k == 'ip':
            if get_local_ip() not in v:
                logging.warn("No associated with ip in %s" % v)
                return False
        if k == 'user':
            user_name = getpass.getuser()
            if user_name not in v:
                logging.warn('Not running under %s (actual: %s)' % (v, user_name))
                return False
        if k == 'parent':
            names = get_commands_of_parents()
            if not any(x in v for x in names):
                logging.warn('Not started by %s (actual: %s)' % (v, names))
                return False
    return True

def modify_precondition(sd, service, func):
    while True:
        idx, checks = load_precondition(sd, service)
        checks = func(checks)
        if save_precondition(sd, service, idx, checks):
            break
        # random backoff
        time.sleep(random.uniform(0.01, 0.10))

def add_precondition(sd, service, key, value):
    def internal(checks):
        if key not in checks:
            checks[key] = []
        if value not in checks[key]:
            checks[key].append(value)
        return checks
    modify_precondition(sd, service, internal)

def remove_precondition(sd, service, key, value):
    def internal(checks):
        if key not in checks:
            return checks
        if value not in checks[key]:
            return checks
        checks[key].remove(value)
        if len(checks[key]) == 0:
            del checks[key]
        return checks
    modify_precondition(sd, service, internal)

if __name__ == "__main__":
    print(local_ams_tags())
    from pyutil.consul.discovery import ServiceDiscovery
    sd = ServiceDiscovery()
    remove_precondition(sd, "comment_test", "user", "tiger")
    remove_precondition(sd, "comment_test", "parent", "supervise")
    remove_precondition(sd, "comment_test", "ip", get_local_ip())
    add_precondition(sd, "comment_test", "parent", "supervi2se")
    assert not check_safety(sd, "comment_test")
    remove_precondition(sd, "comment_test", "parent", "supervi2se")
    assert check_safety(sd, "comment_test")
    print('PASS!')

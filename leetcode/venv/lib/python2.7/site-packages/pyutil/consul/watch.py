#coding=utf8

import sys
from pyutil.consul import is_python3, is_perf_test, add_perf_prefix

if is_python3:
    sys.path.append('/opt/tiger/ss_lib/python_package/lib/python2.7/site-packages')

import logging, functools, time, sched, ujson, threading, requests, random
from threading import Thread

from pyutil.consul import defaults
from pyutil.consul.bridge import send_metrics_lite, local_dc

QUIET_PERIOD = 10

def get_timeout():
    return int(random.uniform(1, 5) * QUIET_PERIOD)

schedulers_by_dc = {}
schedulers_lock = threading.Lock()

class WatchScheduler:
    def __init__(self):
        self.active_watch = {}
        self.watch_lock = threading.Lock()
        self.last_watch_id = 0
        self.scheduler = sched.scheduler(time.time, time.sleep)
        self.scheduler_thread = Thread(target=self.run_scheduler)
        self.scheduler_thread.daemon = True
        self.scheduler_thread.start()
        self.schedule_poll()
        self.last_watch_index = 0

    def run_scheduler(self):
        while True:
            try:
                self.scheduler.run()
            except Exception as e:
                logging.exception(e)
            time.sleep(10)

    def schedule_poll(self):
        self.scheduler.enter(get_timeout(), 1, self.make_request, ())

    def make_request(self):
        self.watch_lock.acquire(True)
        service_names = [name for name in self.active_watch]
        self.watch_lock.release()
        send_metrics_lite('inf.consul.watch.names', 'counter', len(service_names))
        if len(service_names) == 0:
            logging.info("empty service_names should not send http request to local agent")
            time.sleep(10)
            self.scheduler.enter(0, 1, self.make_request, ())
            return
        url = 'http://%s:2280/v1/lookup/watch-multiple?name=%s&index=%s&timeout=%s' % (defaults.agent_host, ','.join(service_names), self.last_watch_index, get_timeout())
        r = None
        try:
            r = requests.get(url, timeout=None)
            if r.status_code == 200:
                self.last_watch_index = int(r.headers.get('Watch-Index', '0'))
                results = ujson.loads(r.text)
                for name in results:
                    self.service_changed(name, results[name])
            else:
                raise Exception('Agent returned: %s' % r.status_code)
            send_metrics_lite('inf.consul.watch.result.requests', 'counter', 1)
            send_metrics_lite('inf.consul.watch.result.services', 'counter', len(results))
        except Exception as e:
            send_metrics_lite('inf.consul.watch.exception', 'counter', 1)
            logging.exception('Failed to call watch-multiple')
            logging.warn('watch-multiple request: <%s>', url)
            if r:
                logging.warn('watch-multiple response: <%s:%s:%s>',
                             r.status_code, r.headers, r.text)
            # backoff to prevent high cpu consumption
            time.sleep(10)
        finally:
            self.scheduler.enter(0, 1, self.make_request, ())

    def service_changed(self, name, nodes):
        self.watch_lock.acquire(True)
        # make a copy of active watches
        watches = {k: v for k, v in self.active_watch.get(name, {}).items()}
        self.watch_lock.release()
        for cb, delay in watches.values():
            _nodes = [(x['Host'], x['Port']) for x in nodes]
            if len(_nodes) == 0:
                # precaution
                logging.error('Watch returned empty result: %s' % name)
                continue
            self.scheduler.enter(delay, 0, cb, (name, _nodes, ))

    def add_watch(self, service, callback, delay=0):
        self.watch_lock.acquire(True)
        try:
            if is_perf_test:
                service = add_perf_prefix(service)
            #if not self.scheduler_thread.isAlive():
            #    self.scheduler_thread.start()
            #    self.schedule_poll()
            watch_id = self.last_watch_id
            self.last_watch_id += 1
            tup = (callback, delay)
            if service in self.active_watch:
                self.active_watch[service][watch_id] = tup
            else:
                self.active_watch[service] = {watch_id: tup}
            return watch_id
        finally:
            self.watch_lock.release()

    def remove_watch(self, service, watch_id):
        self.watch_lock.acquire(True)
        try:
            if is_perf_test:
                service = add_perf_prefix(service)
            if service not in self.active_watch:
                return
            if watch_id not in self.active_watch[service]:
                return
            del self.active_watch[service][watch_id]
            if len(self.active_watch[service]) == 0:
                del self.active_watch[service]
        finally:
            self.watch_lock.release()


SERVICE_DELIM = '.service.'

# FIXME: resolve_dc cannot be reused
def resolve_dc(service):
    service = service.replace('.byted.org', '')
    while service.endswith('.'):
        service = service[0:-1]
    service_pos = service.find(SERVICE_DELIM)
    if service_pos > -1:
        dc = service[service_pos + len(SERVICE_DELIM):]
        return dc
    else:
        return local_dc

def add_watch(service, callback, delay=0):
    schedulers_lock.acquire(True)
    dc = resolve_dc(service)
    try:
        if dc not in schedulers_by_dc:
            schedulers_by_dc[dc] = WatchScheduler()
        return schedulers_by_dc[dc].add_watch(service, callback, delay)
    finally:
        schedulers_lock.release()

def child_proc_after_fork():
    """
    Reload <schedulers_by_dc> and regenerate all watching threads.
    """
    global schedulers_by_dc
    orig_schers = schedulers_by_dc

    with schedulers_lock:
        schedulers_by_dc = {}

    # schedulers_by_dc data structure:
    # { <dc>: { <watch_id>: { <cb>: <delay> } } }
    for dc, raw_sch in orig_schers.iteritems():
        for service, dic in raw_sch.active_watch.iteritems():
            for watch_id, (cb, delay) in dic.iteritems():
                add_watch(service, cb, delay=delay)

try:
    import atfork
    atfork.monkeypatch_os_fork_functions()
    atfork.atfork(child=child_proc_after_fork)
except ImportError as e:
    logging.warn(e)

def remove_watch(service, watch_id):
    schedulers_lock.acquire(True)
    dc = resolve_dc(service)


    try:
        if dc not in schedulers_by_dc:
            return
        schedulers_by_dc[dc].remove_watch(service, watch_id)
    finally:
        schedulers_lock.release()

def add_multiple_watch(services, callback, delay=0):
    return map(lambda x: add_watch(x, callback, delay), services)

if __name__ == '__main__':
    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    def test_cb(name, nodes):
        print('Service %s changed: %s' % (name, nodes))
    add_watch("comment_service2", test_cb)
    add_watch("adengine", test_cb)
    add_multiple_watch(["consul", "category_recommend"], test_cb)
    add_watch("dongtai_comment_service2", test_cb)
    add_watch("editor_targeting", test_cb)
    add_watch("go_category_recommend", test_cb)
    add_watch("profile_server3", test_cb)
    add_watch("profile_server2_offline", test_cb)
    add_watch("toutiao.stream.impression", test_cb)
    add_watch("twemproxy_memcache_group_item", test_cb)
    time.sleep(100)

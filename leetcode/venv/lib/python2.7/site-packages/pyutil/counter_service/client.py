'''
    To see intro for counter_service, visit http://code.byted.org/data/counter_service
    For counter meta, visit http://10.4.19.26:3000/api/v1/counters
'''
import logging
import random
import threading
from collections import OrderedDict

from urllib3 import connection_from_url, Timeout
import ujson

from pyutil.program.conf import Conf
from pyutil.program.tracing import get_current_span, start_child_span

logging.getLogger("urllib3").setLevel(logging.WARNING)
logger = logging.getLogger("counter_service")
logger.setLevel(logging.WARNING)

TIMEOUT = 0.2
CLUSTERS = {
    "OFFLINE": map(lambda x: 'http://%s/' % x, Conf('/opt/tiger/ss_conf/ss/counter_service.conf').get_values('counter_service_servers')),
    "ONLINE": map(lambda x: 'http://%s/' % x, Conf('/opt/tiger/ss_conf/ss/counter_service.conf').get_values('counter_service_online_servers')),
    "MARATHON": map(lambda x: 'http://%s/' % x, Conf('/opt/tiger/ss_conf/ss/counter_service.conf').get_values('counter_service_marathon_servers')),
    "TEST": ['http://10.4.19.26:3000/']
}

class CounterServiceClient(object):
    def __init__(self, cluster="OFFLINE", max_retries=3, conn_timeout=TIMEOUT):
        self.servers = CLUSTERS.get(cluster)
        if not self.servers:
            raise ValueError("cluster '%s' not exists" % cluster)
        self._conn_timeout = conn_timeout
        self.max_retries = max_retries
        self.lock = threading.Lock()
        self.counter_cache = {}

    def _get_response(self, url, lookup):
        with self.lock:
            retries = self.max_retries
            while retries >= 0:
                try:
                    retries -= 1
                    s = random.choice(self.servers)
                    headers = {'Content-Type': 'application/json'}
                    lookup = ujson.dumps(lookup)
                    conn = connection_from_url(s, maxsize=1, timeout=Timeout(self._conn_timeout))
                    r = conn.request("GET", url, headers=headers, body=lookup)
                    content = r.data
                    assert r.status == 200, "http status(%d) != 200 : %s" % (
                        r.status, content
                    )
                    return content
                except Exception as e:
                    logger.warn("%s %s", url, e)

    def get_count(self, counter_name, lookup):
        span = get_current_span()
        with start_child_span(span, 'counter.get_count',
                tags=dict(component='counter_client', counter_name=counter_name)):
            return self._get_count(counter_name, lookup)

    def _get_count(self, counter_name, lookup):
        if not lookup.get('itemIds'):
            return []
        counter_id = self.get_counter_id(counter_name)
        result = None
        url = "/api/v1/counters/%s" % counter_id
        try:
            response = self._get_response(url, lookup)
            result = ujson.loads(response)
        except Exception as e:
            logger.error('get count error. name: %s, lookup: %s, error: %s', counter_name, lookup, e)
        return result

    def get_multi_count(self, lookup):
        '''
        lookup examle: {'counters': ['group_go_detail_count', 'group_impression_count'], 'itemIds':[6227814255891906817, 6228040879090303233]}
        '''
        span = get_current_span()
        with start_child_span(span, 'counter.get_multi_count',
                tags=dict(component='counter_client')):
            return self._get_multi_count(lookup)

    def _get_multi_count(self, lookup):
        if not lookup.get('counters') or not lookup.get('itemIds'):
            return []
        ids = map(lambda name: self.get_counter_id(name), lookup.get('counters'))

        # drop counters which has not been registered yet
        safe_ids = []
        safe_counters = []
        for i in range(len(ids)):
            if ids[i] is not None:
                safe_ids.append(ids[i])
                safe_counters.append(lookup['counters'][i])
        lookup['ids'] = safe_ids
        lookup['counters'] = safe_counters

        result = None
        url = "/api/v1/counters"
        response = self._get_response(url, lookup)
        try:
            result = ujson.loads(response)
        except Exception as e:
            logger.error('get multi count error. lookup: %s, error: %s', lookup, e)
        return result

    def get_counter_id(self, counter_name):
        counter_id = self.counter_cache.get(counter_name)
        if not counter_id:
            url = "/api/v1/counters"
            response = self._get_response(url, {'name': counter_name})
            try:
                counter_list = ujson.loads(response)
                counter_id = counter_list[0].get('id')
                self.counter_cache[counter_name] = counter_id
            except Exception as e:
                logger.error('get counter id error, place check name. name: %s, error: %s', counter_name, e)
        return counter_id

counter_client = CounterServiceClient()
counter_client_test = CounterServiceClient("TEST")


class SpecificCounterServiceClient(object):
    def __init__(self, counter_name, client=None):
        self._counter = client or counter_client
        self._counter_name = counter_name

    def get_count(self, lookup):
        if not lookup.get('itemIds'):
            return {}
        count_list = self._counter.get_count(self._counter_name, lookup)
        id2count = {}
        if isinstance(count_list, list) and isinstance(random.choice(count_list), dict):
            id2count = {i['itemId']: i.get('count', 0) for i in count_list}
            id2count = OrderedDict(sorted(id2count.items(), key=lambda x: x[1], reverse=True))
        return id2count

    def get_counter_id(self):
        return self._counter.get_counter_id(self._counter_name)


if __name__ == "__main__":
    import time
    t = int(time.time()) / 1800 + 1
    test_lookup = dict(itemIds=[6230638808434475265], timeSlots=[t-1])
    test_lookup2 = dict(itemIds=[6227814255891906817, 6228040879090303233])
    go_detail_counter = SpecificCounterServiceClient('group_feed_go_detail_count')
    impression_counter = SpecificCounterServiceClient('group_feed_impression_count')
    print go_detail_counter.get_count(test_lookup)
    print impression_counter.get_count(test_lookup)

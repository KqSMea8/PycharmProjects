# -*- coding: utf-8 -*- 
"""
A library for emitting and collecting any intermediate debuginfo within request processing.

Code Example:
    from pyutil.program.conf import Conf
    from pyutil.debuginfo import debuginfo

    # define following config entries:
    #   self_module_name article_sort
    #   debuginfo_kafka_topic  debuginfo:runing_feature
    #   debuginfo_server_address /var/log/tiger/debug_datagram2
    debuginfo.init(conf)

    class RequestHandler():
        def process(self, req):
            # get writer for this request to record some data
            writer = debuginfo.get_writer(req.req_id)
            writer.record_by_request('uid', 8)
            writer.record_by_group(123, 'score', 1)

            # calling into another function that records more data.
            self.foo(req)
            writer.emit()
            # ...

        def foo(self, req):
            # calling debuginfo.get_writer() with the same req_id returns the identical writer.
            writer = debuginfo.get_writer(req.req_id)
            writer.record_by_group(456, 'score', 2)
            writer.record_by_request('msg', self.msg)

What you get are:
    {"req_id":439,"module":"article_sort","host":"bird","groups":{"456":{"score":2},"123":{"score":1}},"msg":"world","uid":8}
    {"req_id":851,"module":"article_sort","host":"bird","groups":{"456":{"score":2},"123":{"score":1}},"msg":"hello","uid":8}
    ...

"""

import threading
import ctypes
import ujson
import logging
import time
import socket
import struct, select
from pyutil.program import metrics2

_initialized = False
_conf = None
_self_hostname = None
_self_module_name = None
_self_server_address = "/var/log/tiger/debug_datagram2"
_tls = threading.local()


class DebugInfoException(Exception):
    pass

class DebugInfoWriter(object):
    def __init__(self, self_hostname, self_module_name, req_id, topic, server_address):
        self.req_id = req_id
        self.topic = topic
        self.server_address = server_address
        self.reqinfo = {'topic': self.topic, 'module': self_module_name, 'host': self_hostname, 'ts': time.time(), 'req_id': self.req_id, 'groups': {} }

    def get_req_id(self):
        return self.req_id

    def get_req_topic(self):
        return self.topic

    def record_by_request(self, key, message):
        self.reqinfo[key] = message

    def record_by_group(self, group_id, key, message):
        if group_id not in self.reqinfo['groups']:
            self.reqinfo['groups'][group_id] = {}
        self.reqinfo['groups'][group_id][key] = message

    def emit(self):
        try:
            #connect
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.setblocking(0)
            sock.connect(self.server_address)
            outputs = [sock,]
            readable, writable, exceptional = select.select([], outputs, outputs, 0.003) #timeout 3ms
            if not (readable or writable or exceptional):
                raise DebugInfoException, "connect timeout"
            if not writable:
                raise DebugInfoException, "connect exception happen"
            #encode
            data = ujson.dumps(self.reqinfo)
            packet_len = struct.pack('!i',len(data))
            sock.sendall(packet_len)
            #send 
            now = time.time()
            index = 0
            while(1):
                costtime = time.time() - now
                timeout = 0.010 - costtime #10ms timeout
                if timeout < 0:
                    raise DebugInfoException, "send timeout"
                readable, writable, exceptional = select.select([], outputs, outputs, timeout)
                if not (readable or writable or exceptional):
                    raise DebugInfoException, "send timeout"
                if exceptional:
                    raise DebugInfoException, "send exception happen"
                if writable:
                    ret = sock.send(data[index:])
                    index = index + ret
                    if(index == len(data)):
                        break # success over
            metrics2.emit_counter('debuginfo.%s.emit.counter'%(self.topic), 1)
        except DebugInfoException, e:
            logging.exception('debuginfo Exception: %s', e)
            metrics2.emit_counter('debuginfo.%s.emit.failed'%(self.topic), 1)
        except:
            metrics2.emit_counter('debuginfo.%s.emit.failed'%(self.topic), 1)
            logging.exception('debuginfo SysException')
        finally:
            sock.close()

def init(conf_obj):
    global _initialized
    global _conf
    global _self_hostname
    global _self_module_name

    metrics2.init(conf_obj) 
    kafka_topic_list = conf_obj.get_values('debuginfo_kafka_topic')
    for topic in kafka_topic_list:
        metrics2.define_counter('debuginfo.%s.emit.counter'%(topic), 'nums')
        metrics2.define_counter('debuginfo.%s.emit.failed'%(topic), 'nums')

    _conf = conf_obj
    _self_hostname = socket.gethostname()
    _self_module_name = _conf.self_module_name
    if _conf.debuginfo_server_address:
        _self_server_address = _conf.debuginfo_server_address
    _initialized = True

def get_writer(req_id, topic = 'debuginfo'):
    global _initialized
    global _self_hostname
    global _self_module_name
    global _tls
    if not (_initialized and _self_hostname and _self_module_name and _tls and req_id and topic):
        return None

    if not getattr(_tls, 'req_id', None):
        _tls.req_id = None
    if not getattr(_tls, 'topic_dict', None):
        _tls.topic_dict = {} 
    # with thread local storage, it also works in multi-threading environments.
    if _tls.req_id == req_id:
        if topic not in _tls.topic_dict:
            _tls.topic_dict[topic] = DebugInfoWriter(_self_hostname, _self_module_name, req_id, topic, _self_server_address)
        return _tls.topic_dict[topic]

    # create a writer
    if _tls.req_id and _tls.req_id != req_id:
        for w in _tls.topic_dict.values():
            del w

    _tls.req_id = req_id
    _tls.topic_dict = {}
    _tls.topic_dict[topic] = DebugInfoWriter(_self_hostname, _self_module_name, req_id, topic, _self_server_address)
    return _tls.topic_dict[topic]

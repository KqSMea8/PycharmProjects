# coding=utf-8
import logging
import time
import msgpack
import datetime

from lazy_object_proxy import Proxy

from pyutil.program.enum import Enum, IntEnum
from pyutil.program.functool import singleton, throttle


DITING_ACTION_TOPIC = 'diting_object_user_action_event'


def lazy(klass):
    def lazy_class(*args, **kwargs):
        return Proxy(lambda: klass(*args, **kwargs))
    lazy_class.__name__ = "lazy_" + klass.__name__
    return lazy_class


class DitingCollectMode(Enum):
    sync = 'sync'
    async = 'async'


@singleton
@lazy
class DitingProductType(Enum):
    """
    object type: group, item... any kind.
    """

    def __new__(cls, *args, **kwargs):
        cls._store = DitingStore()
        choices = (
            (t['product'], t['remarks']) for t in cls._store.get_product_type()
        )
        setattr(cls, 'choices', choices)
        return Enum.__new__(cls)

    def __init__(self):
        self._dict = {t['product']: t['product'] for t in self.get_info()}
        DitingObjectType.choices = (
            (t['product'], t['product']) for t in self.get_info()
        )

    def __getattr__(self, key):
        try:
            return self._dict[key]
        except KeyError:
            logging.warning(r"'DitingProductType' object has no attribute '%s'" % key)
            return 'unknown'

    @throttle(wait=1000 * 3600)
    def get_info(self):
        return self._store.get_product_type()


@singleton
@lazy
class DitingObjectType(Enum):
    """
    object type: group, item... any kind.
    """

    def __new__(cls, *args, **kwargs):
        cls._store = DitingStore()
        choices = (
            (t['obj_type'], t['remarks']) for t in cls._store.get_object_type()
        )
        setattr(cls, 'choices', choices)
        return Enum.__new__(cls)

    def __init__(self):
        self._dict = {t['obj_type']: t['obj_type'] for t in self.get_info()}
        DitingObjectType.choices = (
            (t['obj_type'], t['obj_type']) for t in self.get_info()
        )

    def __getattr__(self, key):
        try:
            return self._dict[key]
        except KeyError:
            logging.warning(r"'DitingObjectType' object has no attribute '%s'" % key)
            return 'unknown'

    @throttle(wait=1000 * 3600)
    def get_info(self):
        return self._store.get_object_type()


@singleton
@lazy
class DitingActionType(Enum):
    """
    action type: change_title, delete_object...
    """
    def __new__(cls, *args, **kwargs):
        cls._store = DitingStore()
        choices = (
            (t['action_type'], t['action_name']) for t in cls._store.get_action_type()
        )
        setattr(cls, 'choices', choices)
        return Enum.__new__(cls)

    def __init__(self):
        self._dict = {t['action_type']: t['action_type'] for t in self.get_info()}

    def __getattr__(self, key):
        try:
            return self._dict[key]
        except KeyError:
            logging.warning(r"'DitingActionType' object has no attribute '%s'" % key)
            return 'unknown'

    @throttle(wait=1000 * 3600)
    def get_info(self):
        return self._store.get_action_type()


class DitingMessage(object):
    """
    util class for diting message
    """

    @classmethod
    def encode(cls, raw_message):
        return msgpack.dumps(raw_message, default=cls._encode_datetime)

    @classmethod
    def decode(cls, raw_message):
        return msgpack.loads(raw_message, use_list=True, object_hook=cls._decode_datetime)

    @staticmethod
    def _decode_datetime(obj):
        if b'__datetime__' in obj:
            obj = datetime.datetime.fromtimestamp(obj['as_ts'])
        return obj

    @staticmethod
    def _encode_datetime(obj):
        if isinstance(obj, datetime.datetime):
            return {'__datetime__': True, 'as_ts': time.mktime(obj.timetuple())}
        return obj


@singleton
class DitingStore(object):
    """
    get data of object_type and action_type for diting
    """

    def __init__(self):
        from pyutil.etcd import etcd_client
        self.prefix = 'data/diting/'
        self.product_type_key = self.prefix + 'product_type'
        self.object_type_key = self.prefix + 'object_type'
        self.action_type_key = self.prefix + 'action_type'
        self.client = etcd_client.EtcdClient(read_timeout_seconds=10)

    def _get(self, key):
        try:
            data = msgpack.loads(self.client.get(key).value, use_list=True)
        except Exception as ex:
            logging.exception('[Diting] get %s info error: %s' % (key, ex))
            data = []
        return data

    def _set(self, key, data):
        data = msgpack.dumps(data)
        self.client.set(key, data)

    def get_product_type(self):
        return self._get(self.product_type_key)

    def get_object_type(self):
        return self._get(self.object_type_key)

    def get_action_type(self):
        return self._get(self.action_type_key)

    def set_product_type(self, data):
        self._set(self.product_type_key, data)

    def set_object_type(self, data):
        self._set(self.object_type_key, data)

    def set_action_type(self, data):
        self._set(self.action_type_key, data)

#coding=utf8
import datetime, re, operator, itertools
from django.core.paginator import InvalidPage
from django.contrib import admin
from django.contrib.admin.filterspecs import FilterSpec, DateFieldFilterSpec
from django.contrib.admin.views.main import ChangeList as DjangoChangeList
from django.contrib.admin.options import IncorrectLookupParameters
from django.db import models
from django.utils.encoding import force_unicode, smart_str
from django.utils.translation import ugettext_lazy as _

from pyutil.program.python import flatten

MAX_SHOW_ALL_ALLOWED = 200

# Changelist settings
ALL_VAR = 'all'
ORDER_VAR = 'o'
ORDER_TYPE_VAR = 'ot'
PAGE_VAR = 'p'
SEARCH_VAR = 'q'
TO_FIELD_VAR = 't'
IS_POPUP_VAR = 'pop'
ERROR_FLAG = 'e'

class ChangeList(DjangoChangeList):

    def __init__(self, *args, **kwargs):
        super(ChangeList, self).__init__(*args, **kwargs)

    def get_results(self, request):
        paginator = self.model_admin.get_paginator(request, self.query_set, self.list_per_page)
        # Get the number of objects, with admin filters applied.
        result_count = paginator.count

        # Get the total number of objects, with no admin filters applied.
        # Perform a slight optimization: Check to see whether any filters were
        # given. If not, use paginator.hits to calculate the number of objects,
        # because we've already done paginator.hits and the value is cached.
        full_result_count = result_count
        #if not self.query_set.query.where:
        #    full_result_count = result_count
        #else:
        #    full_result_count = self.root_query_set.count()

        can_show_all = result_count <= MAX_SHOW_ALL_ALLOWED
        multi_page = result_count > self.list_per_page

        # Get the list of objects to display on this page.
        if (self.show_all and can_show_all) or not multi_page:
            result_list = self.query_set._clone()
        else:
            try:
                result_list = paginator.page(self.page_num+1).object_list
            except InvalidPage:
                raise IncorrectLookupParameters

        self.result_count = result_count
        self.full_result_count = full_result_count
        self.result_list = result_list
        self.can_show_all = can_show_all
        self.multi_page = multi_page
        self.paginator = paginator

    def process_custom_lookup_params(self, lookup_params):
        pass

    def process_custom_ordering(self, qs):
        # Set ordering.
        if self.order_field:
            qs = qs.order_by('%s%s' % ((self.order_type == 'desc' and '-' or ''), self.order_field))
            #qs = qs.order_by('-id')
        return qs

    def get_query_set(self):
        qs = self.root_query_set
        lookup_params = self.params.copy() # a dictionary of the query string
        self.process_custom_lookup_params(lookup_params)
        for i in (ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR):
            if i in lookup_params:
                del lookup_params[i]
        for key, value in lookup_params.items():
            if not isinstance(key, str):
                # 'key' will be used as a keyword argument later, so Python
                # requires it to be a string.
                del lookup_params[key]
                lookup_params[smart_str(key)] = value
            ## if key ends with __in, split parameter into separate values
            if key.endswith('__in'):
                lookup_params[key] = value.split(',')
            if key.endswith('__md5'):
                import hashlib
                lookup_params[key[:-5]] = hashlib.md5(lookup_params.pop(key)).digest()

        # Apply lookup parameters from the query string.
        try:
            qs = qs.filter(**lookup_params)
        # Naked except! Because we don't have any other way of validating "params".
        # They might be invalid if the keyword arguments are incorrect, or if the
        # values are not in the correct type, so we might get FieldError, ValueError,
        # ValicationError, or ? from a custom field that raises yet something else 
        # when handed impossible data.
        except:
            raise IncorrectLookupParameters
        # Use select_related() if one of the list_display options is a field
        # with a relationship and the provided queryset doesn't already have
        # select_related defined.
        if not qs.query.select_related:
            if self.list_select_related:
                qs = qs.select_related()
            else:
                for field_name in self.list_display:
                    try:
                        f = self.lookup_opts.get_field(field_name)
                    except models.FieldDoesNotExist:
                        pass
                    else:
                        if isinstance(f.rel, models.ManyToOneRel):
                            qs = qs.select_related()
                            break
        qs = self.process_custom_ordering(qs)
        # Apply keyword searches.
        def construct_search(field_name):
            if field_name.startswith('^'):
                return "%s__istartswith" % field_name[1:]
            elif field_name.startswith('='):
                return "%s__iexact" % field_name[1:]
            elif field_name.startswith('@'):
                return "%s__search" % field_name[1:]
            else:
                return "%s__icontains" % field_name
        if self.search_fields and self.query:
            for bit in self.query.split():
                or_queries = [models.Q(**{construct_search(str(field_name)): bit}) for field_name in self.search_fields]
                qs = qs.filter(reduce(operator.or_, or_queries))
            for field_name in self.search_fields:
                if '__' in field_name:
                    qs = qs.distinct()
                    break
        return qs

class ModelAdmin(admin.ModelAdmin):

    def _parse_ne_param(self, request):
        rget = request.GET.copy() # request.GET is readonly, so make a copy and replace it
        request.GET = rget
        ne_kvs = []
        for k, v in rget.iteritems():
            if k.endswith('__ne'):
                ne_kvs.append((k, v))

        ne_params = {}
        for k, v in ne_kvs:
            rget.pop(k)
            k = k[:-4] # remove __ne
            ne_params[k] = v
        return ne_params

    def queryset(self, request):
        ne_params = self._parse_ne_param(request)
        qs = super(ModelAdmin, self).queryset(request)
        if ne_params:
            for k, v in ne_params.iteritems():
                qs = qs.exclude(**{k: v})

        if re.search('/\d+/$', request.path):
            return qs
        start_id_offset = self.start_id_offset if hasattr(self, 'start_id_offset') else 100000
        if not start_id_offset:
            return qs
        unlimit_fields = tuple(getattr(self, 'unlimit_fields', ()) or getattr(self, 'indexed_fields', ())) # use unlimit_fields instead of indexed_fields
        for k in ['id', 'pk']:
            if k not in unlimit_fields:
                unlimit_fields += (k,)
        unlimit_fields = flatten((x, x + '__id') for x in unlimit_fields)
        has_indexed_param = any(q in ['%s%s' % x for x in itertools.product(unlimit_fields,
            ('', '__in', '__gt', '__lt', '__lte', '__gte', '__range', '__exact'))]
            for q in request.GET)
        if not has_indexed_param:
            try:
                min_id = self.model._default_manager.get_query_set().order_by('-pk')[0].pk - start_id_offset
            except:
                min_id = 0
            min_id = min_id if min_id > 0 else 0
            if min_id:
                qs = qs.filter(pk__gte=min_id)
        return qs

    def get_changelist(self, request, **kwargs):
        return ChangeList

class CustomDateFieldFilterSpec(DateFieldFilterSpec):
    def __init__(self, field, request, params, model, model_admin, field_path):
        super(CustomDateFieldFilterSpec, self).__init__(
            field, request, params, model, model_admin, field_path)

        today = datetime.date.today()
        yesterday = today - datetime.timedelta(days=1)

        self.links = list(self.links)
        self.links.insert(2,
            (u'昨天', {'%s__year' % self.field_path: str(yesterday.year),
                       '%s__month' % self.field_path: str(yesterday.month),
                       '%s__day' % self.field_path: str(yesterday.day)})
        )

FilterSpec.filter_specs.insert(0,
        (lambda f: isinstance(f, models.DateField), CustomDateFieldFilterSpec)
        )

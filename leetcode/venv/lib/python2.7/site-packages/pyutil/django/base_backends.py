#!/usr/bin/env python
# coding: utf-8
__author__ = 'zhenghuabin'

import re
import ldap
from django.contrib.auth.backends import ModelBackend
from django_auth_ldap.backend import LDAPBackend
from django.core.cache import get_cache


class PermissionOnlyModelBackend(ModelBackend):
    """
    This backend is used along with ldap auth. It always auth fail, but it can be used to authorize permissions
    """

    def authenticate(self, username=None, password=None):
        return None


class AuthFrequencyControl:
    FAIL_LIMIT = 3
    FAIL_TIMEOUT = 5 * 60
    cache = get_cache("admin_auth_frequency")

    @classmethod
    def check_frequency(cls, username):
        if not cls.cache:
            return True
        key = cls.make_fail_key(username)
        fail_count = cls.cache.get(key) or 0
        if fail_count >= cls.FAIL_LIMIT:
            return False
        return True

    @classmethod
    def mark_failed(cls, username):
        if not cls.cache:
            return
        key = cls.make_fail_key(username)
        fail_count = cls.cache.get(key) or 0
        # incr will not update timeout, so use set
        cls.cache.set(key, fail_count + 1, cls.FAIL_TIMEOUT)

    @classmethod
    def make_fail_key(cls, username):
        return "admin_auth_%s_fail_cnt" % username.strip()


class FrequencyLDAPBackend(LDAPBackend):
    def authenticate(self, username, password):
        if not AuthFrequencyControl.check_frequency(username):
            return None
        ret = super(FrequencyLDAPBackend, self).authenticate(username, password)
        if not ret:
            AuthFrequencyControl.mark_failed(username)
        return ret


class FrequencyModelBackend(ModelBackend):
    def authenticate(self, username, password):
        # ldap内部用户只能通过ldap认证，不走django
        if is_ldap_user(username):
            return None
        if not AuthFrequencyControl.check_frequency(username):
            return None
        ret = super(FrequencyModelBackend, self).authenticate(username, password)
        if not ret:
            AuthFrequencyControl.mark_failed(username)
        return ret


class FrequencyDjangoModelBackend(ModelBackend):
    def authenticate(self, username, password):
        if not AuthFrequencyControl.check_frequency(username):
            return None
        ret = super(FrequencyDjangoModelBackend, self).authenticate(username, password)
        if not ret:
            AuthFrequencyControl.mark_failed(username)
        return ret


def is_ldap_user(username):
    ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, ldap.OPT_X_TLS_NEVER)
    trace_level = 0
    conn = ldap.initialize("ldaps://pool.ldap.d.byted.org", trace_level)
    # search user
    dn = "cn=search,dc=bytedance,dc=com"
    pw = "1ping2pong"
    ret = conn.bind_s(dn, pw)
    ret = conn.search_s('ou=groups,dc=bytedance,dc=com', ldap.SCOPE_ONELEVEL)
    names = re.findall('uid=([a-zA-Z0-9\.]+)', str(ret))
    return username in names


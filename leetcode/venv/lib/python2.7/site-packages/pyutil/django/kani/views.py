# coding=utf8
from __future__ import unicode_literals
from django.template import Context, loader
from django.http import HttpResponseForbidden

from pyutil.django.util import django_version_greater_than
from pyutil.django.admin_function.util import FunctionUrlPatternsCache
from pyutil.kani.utils import BadKaniRequest, kani_dsn
from pyutil.django.kani.utils import dj_kani_system_handler

KANI_PERM_URL = kani_dsn + 'kani/apps/{app_id}/resources/{resource_key}/'


def handler403(request):
    """
    403 error handler which includes ``request`` in the context.
    Templates: `403.html`
    Context: None
    """
    kani = dj_kani_system_handler()
    refresh = False

    def _get_resource_info(_key, _app_name=None, _model_name=None):
        try:
            _resource = kani.get_resource_info(_key) or {}
            if _resource.get('temporary_authorize'):
                _perm_url = KANI_PERM_URL.format(app_id=_resource.get('app_id'), resource_key=_resource.get('key'))
                _resource['perm_url'] = _perm_url
                return _resource, False
        except BadKaniRequest as ex:
            if _app_name in ['admin']:
                try:
                    from pyutil.django.kani.management import create_permissions
                    _url = request.build_absolute_uri()
                    create_permissions(app_label, verbosity=1, model_name=_model_name, url=_url)
                except Exception as ex:
                    return {}, False
                return {}, True
        return {}, False

    t = loader.get_template('kani/403.html')
    resources = []

    if not hasattr(request, 'resolver_match'):
        # for 1.3
        from django.core.urlresolvers import resolve
        request.resolver_match = resolve(request.path)

    if getattr(request, '_resource_key', None):
        resource, refresh = _get_resource_info(getattr(request, '_resource_key', None))
        if resource:
            resources.append(resource)
    elif request.resolver_match:
        url_name = request.resolver_match.url_name
        app_name = request.resolver_match.app_name
        if app_name in ['admin']:
            (app_label, _, model_name) = url_name.rpartition('_')[0].rpartition('_')
            resource_key = '%s.%s' % (app_label, model_name)
            resource, refresh = _get_resource_info(resource_key, _app_name=app_name, _model_name=model_name)
            if resource:
                resources.append(resource)
    else:
        url_pattern_cache = FunctionUrlPatternsCache()
        function_ids = url_pattern_cache.find_function_ids(request.path) or []
        resources = []
        for f_id in function_ids:
            resource_key = '%s.%s' % ('_function', f_id)
            resource, refresh = _get_resource_info(resource_key)
            if resource:
                resources.append(resource)
    context = {
        'request': request,
        'resources': resources,
        'refresh': refresh
    }
    if not django_version_greater_than('1.10.0'):
        # In Django 1.8+, the template's render method takes a dictionary for the context parameter.
        # Support for passing a Context instance is deprecated, and gives an error in Django 1.10+.
        context = Context(context)
    return HttpResponseForbidden(t.render(context))


# coding=utf8

'''
see yaml匹配规则设计与实现 http://wiki.bytedance.com/pages/viewpage.action?pageId=10224275
'''

import operator, re, logging, __builtin__

from pyutil.program.python import arg_to_iter, find, map_dict, compact
from pyutil.dsl.rule_plugin import TRANS_FUNCS

# Valid query types (a dictionary is used for speedy lookups).
QUERY_TERMS = {x: True for x in [
    'isnull', 'regex', 'contains', 'startswith', 'endswith',
    'in', 'intersect',
    'lt', 'le', 'lte', 'gt', 'ge', 'gte', 'eq', 'ne', 'exact',
    ]}
LIST_TERMS = ['intersect', 'in']

OP_AND = 'and'
OP_OR = 'or'
OPS = [OP_AND, OP_OR]

class BadRuleException(Exception):
    pass

# Separator used to split filter strings apart.
LOOKUP_SEP = '__'
TRANS_SEP = '$'
ARG_SEP = ','

def get_field_name_and_op(fname):
    '''
    >>> gfno = get_field_name_and_op
    >>> gfno('a__b__regex')
    ('a__b', 'regex', '', [])
    >>> gfno('a__b__regex__and,2')
    ('a__b', 'regex', 'and', ['2'])
    >>> gfno('a__b__or')
    ('a__b', '', 'or', [])
    >>> gfno('and,2')
    ('', '', 'and', ['2'])
    '''

    match_op, op, op_args = '', '', []
    fnames = fname.split(LOOKUP_SEP) # same with django url query

    lparts = fnames[-1].split(ARG_SEP)
    if lparts[0] in OPS:
        fnames = fnames[:-1]
        op, op_args = lparts[0], lparts[1:]

    if fnames and fnames[-1] in QUERY_TERMS:
        fnames, match_op = fnames[:-1], fnames[-1]

    fname = LOOKUP_SEP.join(fnames)
    return fname, match_op, op, op_args

def get_cascaded_val(tag_or_dict, fname, lookup_sep=LOOKUP_SEP, name_map=None):
    u'''
    return - 若为str, 转换为unicode

    >>> gcv = get_cascaded_val
    >>> gcv(dict(a=1), fname=None)
    {'a': 1}
    >>> gcv(dict(a=1), fname='')
    {'a': 1}
    >>> gcv(dict(a=1), fname='.', lookup_sep='.')
    {'a': 1}
    >>> gcv([1], fname='.', lookup_sep='.')
    [1]
    >>> gcv(dict(L1=dict(L2=dict(L3='foo'))), 'L1__L2__L3')
    u'foo'
    >>> gcv(dict(a=1), 'a__b')
    >>> gcv(dict(L1=dict(L2='foo')), 'L1__LX', name_map=dict(LX='L2'))
    u'foo'
    >>> gcv(dict(a='中'), 'a') == u'中'
    True
    >>> gcv(dict(a=u'中'), 'a') == u'中'
    True
    >>> gcv(dict(a='abc'), 'len$a')
    3
    >>> gcv(dict(a='<p>abcd</p>'), 'text_width$remove_tags$a')
    4
    >>> gcv(dict(a='abc'), 'str$len$a')
    '3'
    >>> gcv(dict(a=None), 'len$a')
    0
    >>> gcv(dict(a=100), 'len$a')
    0
    >>> gcv('foo', 'len$')
    3
    >>> gcv(dict(a=100), '')
    {'a': 100}
    >>> gcv(dict(a=['x', 'y']), 'a.0', lookup_sep='.')
    u'x'
    '''

    fname = fname or ''

    name_map = name_map or {}
    parts = fname.split(TRANS_SEP)
    trans_funcs, fname = parts[:-1], parts[-1]
    fnames = [x for x in fname.split(lookup_sep) if x]
    fv = tag_or_dict
    for fname in fnames:
        fname = name_map.get(fname, fname)
        if fv is None:
            pass
        elif isinstance(fv, dict):
            fv = fv.get(fname, None)
        elif isinstance(fv, (list, tuple)) and re.match('^\d+$', fname):
            index = int(fname)
            fv = fv[index] if 0 <= index < len(fv) else None
        else:
            fv = getattr(fv, fname, None)

    if isinstance(fv, str):
        fv = fv.decode('utf8')

    trans_funcs = reversed(trans_funcs)
    for tf in trans_funcs:
        tf = TRANS_FUNCS.get(tf, getattr(__builtin__, tf, None))
        if tf:
            fv = tf(fv)

    return fv

def match_and(field_val, match_op, match_vals, min_match_count, name_map, findall=False):
    if not isinstance(match_vals, (list, tuple)):
        return False, match_vals
    match_results = [match_field(field_val, match_op, match_val, name_map=name_map, findall=findall) for match_val in match_vals]
    ok_details = [mdetail for ok, mdetail in match_results if ok]
    return len(ok_details) >= (min_match_count or len(match_vals)), ok_details

def match_atom(lv, op, rv, findall=False):
    '''
    lv - left value (field value)
    rv - right value (rule value)

    >>> mbo = lambda *args, **kws: match_atom(*args, **kws)[0]
    >>> mbo(None, 'isnull', True), mbo('foo', 'isnull', True), mbo(None, 'isnull', False)
    (True, False, False)
    >>> mbo(None, 'regex', '.*')
    False
    >>> mbo('foo', 'regex', 'fo{2}')
    True
    >>> mbo('foo', 'startswith', 'f'), mbo('foo', 'startswith', 'o')
    (True, False)
    >>> mbo('foo', 'endswith', 'o')
    True
    >>> mbo('abc', 'contains', 'b')
    True
    >>> mbo([1, 2], 'intersect', [1, 3]), mbo([1, 2], 'intersect', [3, 4]), mbo([], 'intersect', [])
    (True, False, False)
    >>> mbo('a', 'in', 'a,b'), mbo('a', 'in', 'ax,b'), mbo('a', 'in', ['a', 'b']), mbo(1, 'in', '1,2')
    (True, False, True, True)
    >>> mbo('a', 'exact', 'a'), mbo('a', '', 'a'), mbo('a', '', 'b')
    (True, True, False)
    >>> mbo(1, 'gt', 0), mbo(1, 'ge', 1), mbo(1, 'gt', 2), mbo('a', 'lt', 'b'), mbo(1, 'lt', 2)
    (True, True, False, True, True)
    '''

    op = op or 'eq'
    op = dict(lte='le', gte='ge', exact='eq').get(op, op)

    m = False
    mdetail = getattr(rv, 'pattern', rv)
    if op not in QUERY_TERMS:
        logging.error('bad op: %s', op)
        return False, mdetail

    if op == 'isnull':
        m = lv is None if rv is True else lv is not None
    elif lv is None:
        m = False
    elif op == 'regex':
        try:
            if findall:
                _m = rv.finditer(lv) if hasattr(rv, 'finditer') else re.finditer(rv, lv, re.I)
                m = compact([x for x in _m])
                m = None if not m else m
            else:
                m = rv.search(lv) if hasattr(rv, 'search') else re.search(rv, lv, re.I)
            if m:
                mdetail = dict(match=compact(list(set([x.group() for x in m]))), pattern=getattr(rv, 'pattern', rv)) if findall else m.group(0)
        except:
            raise Exception('bad regex %s' % rv)
        m = m is not None
    elif op == 'contains':
        m = lv.find(rv) >= 0
    elif op == 'startswith':
        m = lv.startswith(rv)
    elif op == 'endswith':
        m = lv.endswith(rv)
    elif op == 'in':
        if not isinstance(rv, list):
            t = type(lv) # TODO: datetime
            if isinstance(rv, basestring):
                rv = [t(x) for x in re.split(',\s*', rv) if x]
            else:
                rv = [t(rv)]
        m = lv in rv
        if m:
            mdetail = lv
    elif op == 'intersect': # 存在交集
        if isinstance(lv, (set, list)) and isinstance(rv, (set, list)):
            m = bool(set(lv) & set(rv))
        else:
            m = False
    elif op in ['lt', 'le', 'gt', 'ge', 'eq', 'ne']:
        m = getattr(operator, op)(lv, rv)
    else:
        logging.error('bug, bad op: %s', op)

    return m, mdetail

def match_field(field_val, match_op, match_val, name_map, op=None, op_args=None, findall=False):
    name_map = name_map or {}
    if op == OP_OR: # or => and,1
        op, op_args = OP_AND, ['1']

    min_match_count = int(op_args[0]) if op_args else None

    if isinstance(match_val, dict):
        is_match, mdetail = _match_rule(field_val, match_val, default_match_op=match_op,
                min_match_count=min_match_count, name_map=name_map, findall=findall)
    elif isinstance(match_val, (list, tuple)) and match_op not in LIST_TERMS:
        is_match, mdetail = match_and(field_val, match_op, match_vals=match_val,
                min_match_count=min_match_count,
                name_map=name_map,
                findall=findall
                )
    else:
        is_match, mdetail = match_atom(field_val, match_op, match_val, findall=findall)
    return is_match, mdetail

def _match_rule(tag, rule, default_match_op=None, min_match_count=None, name_map=None, return_fail_reason=False, findall=False):
    """
    # if rule is matched, return match_detail
    # if rule is not matched and return_fail_reason is False, return {}
    # if rule is not matched and return_fail_reason is True, return failed_reason

    findall: find all match keywords or not
    """
    name_map = name_map or {}
    match_detail = {}
    failed_reason = {}

    match_count = 0
    for field_name_op, match_val in rule.items():
        negative = False
        field_name_op0 = field_name_op
        if field_name_op.startswith('-'):
            negative = True
            field_name_op = field_name_op[1:]
        fname, match_op, op, op_args = get_field_name_and_op(field_name_op)
        match_op = match_op or default_match_op
        field_val = get_cascaded_val(tag, fname, name_map=name_map)
        is_match, mdetail = match_field(field_val, match_op, match_val, op=op, op_args=op_args, name_map=name_map, findall=findall)
        if negative:
            is_match = not is_match
        if is_match:
            match_count += 1
            if mdetail:
                match_detail[field_name_op0] = mdetail
        else:
            failed_reason[field_name_op0] = match_val

    is_match = match_count >= (min_match_count or len(rule))
    if is_match:
        return is_match, match_detail
    elif return_fail_reason:
        return is_match, failed_reason
    else:
        return is_match, {}

''' exported functions '''

def compile_rule(rule, re_flags=0):
    '''
    >>> compile_rule({'a': 1})
    {'a': 1}
    >>> compile_rule([{'set': {'x': 1}}])
    [{'set': {'x': 1}}]
    >>> compile_rule([{'set1': {'x': 1}}])
    Traceback (most recent call last):
        ...
    BadRuleException: invalid statement: {'set1': {'x': 1}}
    >>> compile_rule([{'set': 'x'}])
    Traceback (most recent call last):
        ...
    BadRuleException: invalid statement: {'set': 'x'}
    '''
    statement_keys = ['if', 'elif', 'else', 'set', 'add']
    if isinstance(rule, list):
        for statement in rule:
            if (not isinstance(statement, dict) or
                    not any(x in statement for x in statement_keys) or
                    any(op in statement and not isinstance(statement[op], dict)
                        for op in ['set', 'add'])
                    ):
                raise BadRuleException('invalid statement: %s' % statement)
    def conv_kv(k, v, pkeys):
        return k, conv_v(v, pkeys + [k])
    def conv_v(v, pkeys):
        if isinstance(v, basestring) and any(re.search(r'(^|__)regex(__|$)', x) for x in pkeys):
            try:
                v = re.compile(v, re_flags)
            except:
                raise BadRuleException('invalid regex %s%s' % (v, ' for %s' % pkeys[-1] if pkeys else ''))
        return v
    return map_dict(rule, conv_kv, atom_op=conv_v)

def match_rule(obj_dict, rule, name_map=None, return_fail_reason=False, findall=False):
    '''
    obj_dict - class object or dict
    rule - dict
    name_map - 对rule中的name做转换
    return - is_match(bool), match_detail(dict)

    full rule yml example

    url__contains: foo.com # url包含foo.com
    len$url__gt: 10 # url长度>10
    url: # url包含foo.com且长度>10
      contains: foo.com
      len$__gt: 10
    -tag__in: blog,bbs # tag非blog, 也非bbs
    title__regex__or: # 所有条件取或
      - foo
      - and: [bar1, bar2] # 匹配列表中所有元素
      - and,2: [car1, car2, car3] # 匹配列表中所有元素中的至少2个
    content: # 内容匹配bar且长度>500
      regex: bar
      len$__gt: 500
    or:
      - title__regex: bar
      - content__regex: bar
    regex__or:
      - title: bar
      - content: bar
    regex__or: # 和上面规则等价
      title: bar
      content: bar
    content: # content包含foo和bar
      - foo
      - bar


    >>> mr = lambda *args, **kws: match_rule(*args, **kws)[0]
    >>> mr(dict(t='foo', c='bar', n=10), dict(t='foo'))
    True
    >>> mr(dict(t='foo', c='bar', n=10), {'-t': 'foo'}) # exclude
    False
    >>> mr(dict(t='foo', c='bar', n=10), dict(t='foo', c__exact='bar', n__gt=1)) # and
    True
    >>> mr(dict(t='foo', c='bar', n=10), dict(t='foo', n__lt=1)) # and
    False
    >>> mr(dict(t='foo'), dict(title='foo'))
    False
    >>> mr(dict(t='foo'), dict(title='foo'), name_map=dict(title='t')) # name map
    True
    >>> mr(dict(t='foo'), dict())
    True

    >>> mr(dict(item=dict(t='foo')), dict(item__t='foo'))
    True
    >>> mr(dict(item=dict(t='foo')), dict(item__t__or=['foo', 'bar']))
    True
    >>> mr(dict(item=dict(t='foo')), dict(item__t='bar'))
    False
    >>> mr(dict(item=dict(t='foo')), dict(item__t__x__isnull=True))
    True

    >>> mr(dict(t='中'), dict(t=u'\u4e2d')) # convert utf8 str to unicode when comparing
    True

    >>> mr(dict(t='abc'), {'len$t': 3}) # trans functions
    True

    >>> mr(dict(t='foo'), dict(t={'len$__gt': 1}))
    True
    >>> mr(dict(t='foo'), dict(t=dict(regex=['fo', 'oo']))) # and
    True
    >>> match_rule(dict(t='foo'), dict(t={'regex__and,2': [re.compile('fo'), 'oo', 'bar']}))
    (True, {'t': {'regex__and,2': [u'fo', u'oo']}})
    >>> mr(dict(t='foo'), dict(t={'regex__and,3': ['fo', 'oo', 'bar']}))
    False
    >>> mr(dict(t='foo'), {'t__regex__or': ['fo', 'bar']})
    True
    >>> match_rule(dict(t='foo', c='bar'), {'regex__or': [dict(t='f'), dict(c='f')]})
    (True, {'regex__or': [{'t': u'f'}]})
    >>> match_rule(dict(t='foo', c='bar'), {'regex__or': dict(t='f', c='f')})
    (True, {'regex__or': {'t': u'f'}})
    >>> match_rule(dict(t='foo', c='bar'), {'regex__and': dict(t='f', c='f')})
    (False, {})
    >>> match_rule(dict(t='foo', c='bar'), {'regex__and': {'t': 'f', '-c': 'f'}})
    (True, {'regex__and': {'t': u'f', '-c': 'f'}})
    >>> match_rule(dict(t='foo', c='bar'), {'regex__and': dict(t='f', c='b')})
    (True, {'regex__and': {'c': u'b', 't': u'f'}})
    >>> match_rule(dict(t='foo bar car df'), {'t__regex__or': ['x', {'and,2': ['bar','car']}]})
    (True, {'t__regex__or': [{'and,2': [u'bar', u'car']}]})
    >>> match_rule(dict(t='foo', c='bar'), {'t': 'foo', '-t__or': ['bar']})
    (True, {'t': 'foo'})
    >>> match_rule(dict(tag='news_politics', title='abc'), {'or': dict(tag__in=['news_politics', 'bar'], source__in=['a']), '-title__regex': 'weather'})
    (True, {'or': {'tag__in': u'news_politics'}, '-title__regex': 'weather'})
    >>> match_rule(dict(hub_rule_ids=[1,2]), {'hub_rule_ids__intersect': [1,3]})
    (True, {'hub_rule_ids__intersect': [1, 3]})
    >>> match_rule(dict(hub_rule_ids=[1,2]), {'hub_rule_ids__intersect': [0,3]})
    (False, {})
    '''

    return _match_rule(obj_dict, rule, name_map=name_map, return_fail_reason=return_fail_reason, findall=findall)

def eval_rule_statements(statements, context, log_id=''):
    '''
    >>> def ers(statements, context):
    ...     def norm(s):
    ...         return normalize_statement(s, if_prefix='url__regex')
    ...     return eval_rule_statements(map(norm, statements), context)[0]
    >>> statements = [
    ... {'if': '/ab', 'set': {'ab': 1}, 'add': {'y': 1}},
    ... {'elif': '/a', 'set': {'a': 1}},
    ... {'else': {'set': {'c': 1}}},
    ... {'set': {'d': 1}},
    ... {'elif': '/a', 'set': {'a': 'bad'}}, # bad statement, will ignore
    ... {'if': '/ab', 'set': {'x': 1}, 'add': {'y': 2}},
    ... {'if': '/c', 'set': {'c1': 1}},
    ... {'if': {'y': 3}, 'set': {'yy': 1}}, # 上面的规则给y赋值, 可以在后面的规则中使用
    ... {'elif': '/c', 'set': {'c2': 1}},
    ... ]
    >>> ers(statements, dict(url='http://foo.com/ab'))
    {'y': 3, 'x': 1, 'ab': 1, 'yy': 1, 'd': 1}
    >>> ers(statements, dict(url='http://foo.com/a'))
    {'a': 1, 'd': 1}
    >>> ers(statements, dict(url='http://foo.com/c'))
    {'c2': 1, 'c': 1, 'c1': 1, 'd': 1}
    '''
    attrs = dict()
    match_details = []
    state = 'init' # if_match, if_unmatch
    for r in statements:
        op = find(['if', 'elif', 'else'], lambda x: x in r)
        if not op:
            state = 'init'
        else:
            if state == 'init':
                if op != 'if':
                    logging.warning('%s expected if, got %s, statement=%s', log_id, op, r)
                    continue
            elif state == 'if_match':
                if op in ['elif', 'else']:
                    continue

            if op in ['if', 'elif']:
                is_match, mdetail = match_rule(dict(context, **attrs), r[op])
                if is_match:
                    state = 'if_match'
                    match_details.append(mdetail)
                else:
                    state = 'if_unmatch'
                    continue
            elif op: # else
                state = 'init'
        d = r[op] if op == 'else' else r
        if 'set' in d:
            attrs.update(d['set'])
        if 'add' in d:
            for k, v in d['add'].items():
                attrs[k] = attrs.get(k, 0) + v
    return attrs, match_details

def normalize_statement(s, if_prefix):
    '''
    >>> def ns(s):
    ...     return normalize_statement(s, if_prefix='url__regex')
    >>> ns({'if': 'foo', 'set': {'a': 1}})
    {'set': {'a': 1}, 'if': {'url__regex': 'foo'}}
    >>> ns({'if': ['foo', 'bar']})
    {'if': {'url__regex': ['foo', 'bar']}}
    >>> ns({'if__or': ['foo', 'bar']})
    {'if': {'url__regex__or': ['foo', 'bar']}}
    '''
    op = find(['if', 'elif', 'if__or', 'elif__or'], lambda x: x in s)
    if op:
        v = s[op]
        if (isinstance(v, basestring) or
                isinstance(v, list) and all(isinstance(x, basestring) for x in v)
                ):
            ns = dict(s)
            ns.pop(op)
            if op.endswith('__or'):
                op = op.split('__')[0]
                if_prefix = if_prefix + '__or'
            ns[op] = {if_prefix: v}
            return ns
    return s

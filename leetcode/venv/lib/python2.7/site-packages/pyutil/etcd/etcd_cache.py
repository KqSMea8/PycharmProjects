# coding: utf-8
import time
import pyutil.ttlogging as logger

from pyutil.program.lru import LRUCache
from exceptions import KeyError
import threading

DEFAULT_TIMEOUT = 60
DEFAULT_SIZE = 300
ETCD_CACHE_FILE_PREFIX = '/tmp/etcd_cache'

class EtcdEntry(object):
    def __init__(self, key, value, expire_time):
        self.key = key
        self.value = value
        self.expire_time = expire_time


class EtcdExpiringCache(object):
    """
       Cache底层依赖LRUCache
       Cache过期再次刷新cache时如果获取失败，会默认缓存之前的值(stale_read=True)或default值(stale_read=False)，并且在缓存失效前
       不会去尝试请求etcd更新为正确的值，可以防止etcd挂掉后频繁请求etcd
    """
    def __init__(self, fetcher, size=DEFAULT_SIZE, timeout=DEFAULT_TIMEOUT):
        size = int(size)
        if size < 1:
            raise ValueError('size must be >0')
        self.timeout = int(timeout)
        if self.timeout <= 0:
            raise ValueError('timeout must be >0')
        self.cache = LRUCache(size=size)
        self.fetcher = fetcher
        self.etcd_cache_map = {} # key: (etcd_result, empiring_time)

    def get_with_file(self, key, default, timeout=300, stale_read=False):
        """
        get from etcd and save to local cache file. if didn't get from etcd, load from file
        """
        import os
        result, err = self.get_with_except(key, default, timeout=timeout, stale_read=stale_read)
        key = key[1:] if key[0] == '/' else key
        key_str = key.replace('/', '-')
        if result:
            if self.etcd_cache_map.has_key(key_str) and self.etcd_cache_map[key_str][0] == result and time.time() <= self.etcd_cache_map[key_str][1]:
                self.etcd_cache_map[key_str] = (result, time.time() + timeout)
                return result, err
            else: # exceed time or config change or no cache
                self.etcd_cache_map[key_str] = (result, time.time() + timeout)
                if not os.path.exists(ETCD_CACHE_FILE_PREFIX):
                    os.mkdir(ETCD_CACHE_FILE_PREFIX)
                # save to cache file and return
                with open(os.path.join(ETCD_CACHE_FILE_PREFIX, key_str + '__' + str(os.getuid()) + '.etcd_cache'), 'w') as f:
                    f.write(result.encode('utf8'))
                return result, err
        else: # etcd request fails
            # Method 1: read from etcd cache map if within time limit
            cache = self.etcd_cache_map.get(key_str, None)
            if cache:
                default = cache[0]
                if time.time() <= cache[1]:
                    return cache[0], err
            # Method 2: read from etcd cache file and update cache map
            try:
                with open(os.path.join(ETCD_CACHE_FILE_PREFIX, key_str + '__' + str(os.getuid()) + '.etcd_cache'), 'r') as f:
                    result = f.read().decode()
                    self.etcd_cache_map[key_str] = (result, time.time() + timeout)
                    return result, err
            except Exception as e:
                if isinstance(err, KeyError):
                    logger.debug('Key Error: cannot request etcd & no etcd cache file, key: {%s}, error %s' % (key, e))
                else:
                    logger.warn('Key Error: cannot request etcd & no etcd cache file, key: {%s}, error %s' % (key, e))
                return default, e

    def get_with_except(self, key, default, timeout=None, stale_read=False):
        entry = self.cache.get(key, None)
        value = None
        err = None
        if entry is not None:
            value = entry.value
            if time.time() < entry.expire_time:
                return value, err
        try:
            result = self.fetcher(key)
            value = result.value
        except KeyError as e:
            err = e
        except Exception as e:
            logger.warn(e)
            err = e
        finally:
            if err is not None:
                value = value if stale_read and value is not None else default
            timeout = self.timeout if timeout is None else timeout
            if entry:
                entry.value = value
                entry.expire_time = time.time()+timeout
            else:
                entry = EtcdEntry(key, value, time.time()+timeout)
            self.cache.put(key, entry)
            return value, err

class EtcdExpiringCacheSingleton(EtcdExpiringCache):
    _instance_lock = threading.Lock()
    def __init__(self, fetcher, size=DEFAULT_SIZE, timeout=DEFAULT_TIMEOUT):
        super(EtcdExpiringCacheSingleton, self).__init__(fetcher, size, timeout)

    @classmethod
    def instance(cls, *args, **kwargs):
        with EtcdExpiringCacheSingleton._instance_lock:
            if not hasattr(EtcdExpiringCacheSingleton, "_instance"):
                EtcdExpiringCacheSingleton._instance = EtcdExpiringCacheSingleton(*args, **kwargs)
        return EtcdExpiringCacheSingleton._instance
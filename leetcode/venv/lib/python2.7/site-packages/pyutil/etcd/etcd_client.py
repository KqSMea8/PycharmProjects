# -*-coding: utf-8 -*-
import os
from random import shuffle
import base64
import time

from _etcd.client import Client
from _etcd.common import EtcdException
import pyutil.program.metrics2 as metrics
import pyutil.ttlogging as logger
from pyutil.program.conf import Conf


METRICS_PREFIX = 'etcd.req'
CONSUL_CACHE_TIME = 10


def etcd_metrics(method):
    def wrapper(self, *args, **kwargs):
        method_name = method.__name__
        start_time = time.time()
        try:
            return method(self, *args, **kwargs)
        except:
            metrics.emit_counter(method_name + '.error.count', 1, METRICS_PREFIX)
            raise
        finally:
            time_used = time.time() - start_time
            metrics.emit_counter(method_name + ".count", 1, METRICS_PREFIX)
            metrics.emit_timer(method_name + ".latency", int(time_used * 1000000), METRICS_PREFIX)

    return wrapper


class EtcdClient(Client):
    _BD_BASE64_PREFIX = '_ETCD_BASE64_PREFIX_'

    def __init__(self, conf=None, read_timeout_seconds=0.25, compress_response=False, etcd_consul_name="toutiao.etcd.proxy"):
        """
        Args:
            conf (pyutil.program.conf.Conf): conf object
            read_timeout_seconds (float): timeout
            compress_response (bool): if you want to transmit get response in compressed format,
                turn it on when your value is large, eg > 1k
        """
        self.etcd_consul_name = etcd_consul_name
        self.consul_update_at = 0
        self.use_consul = True
        host_port_list = []

        if conf is None and self._check_dev_env():
            conf = Conf('/etc/ss_conf/etcd.conf')

        if conf is not None:
            self.use_consul = False
            for hp in conf.get_values("etcd_host_port"):
                (host, port) = hp.split(':')
                host_port_list.append((host, int(port)))
        else:
            try:
                host_port_list = self._get_endpoints_from_consul()
            except Exception as ex:
                logger.error(ex)
        shuffle(host_port_list)
        self.host_port_tuple = tuple(host_port_list)
        self._define_metrics()
        super(EtcdClient, self).__init__(host=self.host_port_tuple,
                                         read_timeout=read_timeout_seconds,
                                         compress_response=compress_response)
    @property
    def machines(self):
        ret = []
        if self.use_consul and (time.time()-self.consul_update_at) > CONSUL_CACHE_TIME:
            try:
                host_port_list = self._get_endpoints_from_consul()
                shuffle(host_port_list)
                self.host_port_tuple = tuple(host_port_list)
            except Exception as ex:
                logger.error(ex)
            # refresh consul_update_at even if fetch endpoints failed
            self.consul_update_at = time.time()
        for hp in self.host_port_tuple:
            ret.append("http://%s:%d" % (hp[0], hp[1]))
        return ret


    def _check_dev_env(self):
        conf = Conf('/etc/ss_conf/etcd.conf')
        if conf.get("env", "prod").strip() == "dev":
            return True
        return False


    def _get_endpoints_from_consul(self):
        from pyutil.consul.bridge import translate_one

        endpoint_list = translate_one(self.etcd_consul_name)
        for endpoint in endpoint_list:
            if type(endpoint) != tuple:
                raise Exception("ETCD: endpoint of etcd is not tuple, etcd_consul_name:%s, endpoint_list:%s"
                                % (self.etcd_consul_name, str(endpoint_list)))

        if len(endpoint_list) == 0:
            raise Exception("ETCD: endpoint list of etcd is empty, etcd_consul_name:%s" % self.etcd_consul_name)
        return endpoint_list


    def _define_metrics(self):
        metrics.define_counter('write.count', prefix=METRICS_PREFIX)
        metrics.define_counter('read.count', prefix=METRICS_PREFIX)
        metrics.define_counter('delete.count', prefix=METRICS_PREFIX)
        metrics.define_counter('write.error.count', prefix=METRICS_PREFIX)
        metrics.define_counter('read.error.count', prefix=METRICS_PREFIX)
        metrics.define_counter('delete.error.count', prefix=METRICS_PREFIX)
        metrics.define_timer('write.latency', prefix=METRICS_PREFIX)
        metrics.define_timer('read.latency', prefix=METRICS_PREFIX)
        metrics.define_timer('delete.latency', prefix=METRICS_PREFIX)

    @etcd_metrics
    def read(self, key, **kwdargs):
        """
        Returns the value of the key ‘key’.

        Args:
            key (str): Key.
            Recognized kwd args
            recursive (bool): If you should fetch recursively a dir
            wait (bool): If we should wait and return next time the key is changed
            waitIndex (int): The index to fetch results from.
            sorted (bool): Sort the output keys (alphanumerically)
            timeout (int): max seconds to wait for a read.

        Returns:
            client.EtcdResult (or an array of client.EtcdResult if a subtree is queried)

        Raises:
            KeyValue: If the key doesn’t exists.
            urllib3.exceptions.TimeoutError: If timeout is reached.
        """
        self._check_read_right(key, **kwdargs)
        result = super(EtcdClient, self).read(key, **kwdargs)
        self._decode_from_base64_recursive(result)

        return result

    @etcd_metrics
    def write(self, key, value, ttl=None, dir=False, append=False, **kwdargs):
        """
        Writes the value for a key, possibly doing atomit Compare-and-Swap

        Args:
            key (str): Key.
            value (str): value to set
            ttl (int): Time in seconds of expiration (optional).
            dir (bool): Set to true if we are writing a directory; default is false.
            append (bool): If true, it will post to append the new value to the dir, creating a sequential key. Defaults
            to false.
            Other parameters modifying the write method are accepted:
            prevValue (str): compare key to this value, and swap only if corresponding (optional).
            prevIndex (int): modify key only if actual modifiedIndex matches the provided one (optional).
            prevExist (bool): If false, only create key; if true, only update key.

        Returns:
            client.EtcdResult
        Note:
            1, urllib.urlencode can not encode 'utf-8', so unicode str must be encoded before transport
            2, bytearray that can not be decode to utf-8 is not valid json string

        """
        self._check_update_right(key)
        if isinstance(value, str):
            try:
                value.decode('utf-8')
            except:
                value = self._BD_BASE64_PREFIX + base64.b64encode(value)
        elif isinstance(value, unicode):
            value = value.encode('utf-8')

        result = super(EtcdClient, self).write(key, value, ttl, dir, append, **kwdargs)
        self._decode_from_base64_recursive(result)

        return result

    @etcd_metrics
    def delete(self, key, recursive=None, dir=None, **kwdargs):
        """
        Removed a key from etcd.

        Args:
            key (str): Key.
            recursive (bool): if we want to recursively delete a directory, set
            it to true
            dir (bool): if we want to delete a directory, set it to true
    
            prevValue (str): compare key to this value, and swap only if
            corresponding (optional).
            prevIndex (int): modify key only if actual modifiedIndex matches the
            provided one (optional).
        Returns:
            client.EtcdResult
        Raises:
            KeyValue: If the key doesn’t exists.
        """
        self._check_update_right(key)
        result = super(EtcdClient, self).delete(key, recursive, dir, **kwdargs)
        self._decode_from_base64_recursive(result)
        return result

    def _check_read_right(self, key, **kwdargs):
        if not kwdargs.get('recursive'):
            return
        key = os.path.normpath(key).strip('/')
        if len(key.split('/')) < 1:
            raise Exception("not allowed to get recursively for this key: key=%s" % key)

    def _check_update_right(self, key):
        """
        throw Exception if update is not allowed
        """
        key = os.path.normpath(key).strip('/')
        if len(key.split('/')) < 1:
            raise EtcdException("update operation is not allowed for this key: key=%s" % key)

    @classmethod
    def _decode_from_base64_recursive(cls, result):
        """
        decode etcd result's value field
        param result: EtcdResult
        """
        if not result:
            return
        if result.value:
            if result.value.startswith(cls._BD_BASE64_PREFIX):
                result.value = base64.b64decode(result.value[len(cls._BD_BASE64_PREFIX):])
        for child in result.children:
            if child == result:
                break
            cls._decode_from_base64_recursive(child)



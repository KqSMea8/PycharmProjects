#coding=utf8
from pyutil.cache.cache_class import CacheClass
import logging
from struct import pack, pack_into, calcsize, unpack_from
from pyutil.cache.local_cache import LocMemCache
import pdb, hashlib, MySQLdb, os
from pyutil.memcache import MemcacheClient
from pyutil.futil.smart_futil_client import ThriftFutilClient

from pyutil.program import metrics2 as metrics
KEY_TMPL = 'feature_id_name_map_%s_v1'
from ss_data.profile.conf import sys_conf
from ss_thrift_gen.futil.ttypes import IdMGetReq,FnameMGetReq,IdMPutReq,FamilyIdGetReq,FeatureMetaGetReq

class Id2FeatureCache:
    def __init__(self, profile_dal, cache=None, channel=False, futil_client=None):
        self.cache = cache if cache else LocMemCache(
                max_entries=10000, lock=True, copy=False)

        self.profile_dal = profile_dal
        self.relevance_recall_cache = MemcacheClient(sys_conf.get_values('memcache_profile_online'),
                                                     key_tmpl=KEY_TMPL, timeout=3600*24*180)

        self.is_channel = channel
        self.level_category_cache = self.load_level_category_file(os.path.join(os.path.dirname(__file__), 'level_category_fids.txt'))
        self.futil_client = futil_client

    def load_level_category_file(self, input_file):
        ret = {}
        with open(input_file, 'r') as f:
            for line in f:
                raw = line.strip().split()
                if len(raw)<2:
                    continue
                fid = int(raw[0])
                fname = raw[1]
                ret[fid] = fname
        return ret

    def mget(self, fids):
        ret = {}
        nfids = []
        for fid in fids:
            f = self.cache.get(fid)
            if f == None:
                nfids.append(fid)
            else:
                ret[fid] = f
        
        if nfids:
            if self.futil_client:
                rsp = None
                try:
                    rsp = self.futil_client.fname_mget(FnameMGetReq(nfids))
                except:
                    logging.exception("futil service fname_mget failed")
                if rsp == None:
                    logging.warn("futil service fname_mget failed resp is none")
                    return ret
                if rsp.BaseResp.StatusCode != 0:
                    logging.warn("futil service fname_mget failed error code:%d",rsp.BaseResp.StatusCode)
                    return ret

                for fid,fname in rsp.fnames.items():
                    ret[fid] = fname
                    self.cache.set(fid,fname)
            else:
                if not self.is_channel:
                    self.profile_dal.execute('select id, origin from feature_id_map where id in (%s)' % \
                            ','.join([str(fid) for fid in nfids]))
                    rows = self.profile_dal.cursor.fetchall()
                    for r in rows:
                        fid, origin = r['id'], r['origin'].encode('utf8')
                        ret[fid] = origin
                        self.cache.set(fid, origin)
                else:
                    _nfids = []
                    for fid in nfids:
                        fname = self.level_category_cache.get(fid, '')
                        if fname:
                           ret[fid] = fname
                        else:
                            _nfids.append(fid)

                    cnt = 0
                    k_v_map = self.relevance_recall_cache.mget(_nfids)
                    for fid, name in k_v_map.iteritems():
                        if not name:
                            cnt += 1
                            continue
                        if type(name) is unicode:
                            name = name.encode('utf8')
                        ret[fid] = name
                        self.cache.set(fid, name)

                    metrics.emit_counter('feature_util.miss.count', len(fids)-len(ret) + cnt)
        return ret


class Feature2IdCache:
    def __init__(self, profile_dal, cache=None, futil_client=None):
        self.cache = cache if cache else LocMemCache(
                max_entries=10000, lock=True, copy=False)
        self.profile_dal = profile_dal
        self.write_profile_dal = self._get_write_profile_dal()
        self.futil_client = futil_client

    def _get_write_profile_dal(self):
        # tmp logic for i18n sg TODO
        from pyutil.program.conf2 import Conf
        from pyutil.program.db import DAL
        # if idc.conf is not exists, idc_conf and idc_region will be empty
        idc_conf = Conf('/opt/tiger/ss_conf/ss/idc.conf')
        idc_region = idc_conf.get('idc_region')
        if idc_region in ['sg','alisg']: # TODO
            db_profile_conf = Conf('/opt/tiger/ss_conf/ss/db_profile.conf')
            return DAL(
                host=db_profile_conf.get('profile_feature_id_mapping_write_host'),
                port=db_profile_conf.get('profile_feature_id_mapping_write_port'),
                user=db_profile_conf.get('profile_feature_id_mapping_write_user'),
                passwd=db_profile_conf.get('profile_feature_id_mapping_write_password'),
                name=db_profile_conf.get('profile_db_name'))

        return self.profile_dal # return the old one

    def make_key(self, family_id, f):
        f_ = f
        if type(f) is unicode:
            f_ = f.encode('utf8')
        return '%s:%s' % (family_id, f_)

        #if type(feature) is not unicode:
        #    feature = feature.decode('utf8')
        #    feature = feature.encode('utf8')
        #return '%s:%s'%(family_id, hashlib.md5(feature).hexdigest())

    def gen_sign(self, f):
        f_  = f
        if type(f) is unicode:
            f_ = f.encode('utf8')
        return hashlib.md5(f_).digest()

    def mget(self, family_id, features, save_new=True):
        kmap = {f:self.make_key(family_id, f) for f in features}
        kvs = self.cache.get_multi(kmap.values())
        ret = {}
        nfsigns = {}
        nforigin = [] 
        for f in features:
            k = kmap[f]
            v = kvs.get(k)
            if v == None:
                nfsigns[self.gen_sign(f)] = f
                nforigin.append(f);
                continue
            ret[f] = v

        if nfsigns:
            nfkvs = {}
            if self.futil_client:
                rsp = None
                try:
                    rsp = self.futil_client.id_mget(IdMGetReq(family_id,nforigin))
                except:
                    logging.exception("futil service id_mget failed")
                if rsp == None:
                    logging.warn("futil service id_mget failed resp is none")
                    return ret
                if rsp.BaseResp.StatusCode != 0:
                    logging.warn("futil service id_mget failed error code:%d",rsp.BaseResp.StatusCode)
                    return ret
                
                for fname,fid in rsp.ids.items():
                    ret[fname] = fid
                    nfkvs[kmap[fname]]=fid
                mis = [origin for origin in nforigin if origin not in ret.keys()]
                if mis and save_new:
                    try:
                        rsp = self.futil_client.id_mput(IdMPutReq(family_id,mis))
                    except:
                        logging.exception("futil service id_mput failed")
                    if rsp == None:
                        logging.warn("futil service id_mget failed resp is none")
                        return ret
                    if rsp.BaseResp.StatusCode != 0:
                        logging.warn("futil service id_mput failed error code:%d",rsp.BaseResp.StatusCode)
                        return ret
                    try:
                        rsp = self.futil_client.id_mget(IdMGetReq(family_id,mis))
                    except:
                        logging.exception("futil service id_mget failed when save_new")
                    if rsp == None:
                        logging.warn("futil service id_mget failed resp is none")
                        return ret
                    if rsp.BaseResp.StatusCode != 0:
                        logging.warn("futil service id_mget failed error code:%d",rsp.BaseResp.StatusCode)
                        return ret
                    for fname,fid in rsp.ids.items():
                        ret[fname] = fid
                        nfkvs[kmap[fname]] = fid
                self.cache.set_multi(nfkvs)
            else:
                nkvs = {}
                signs = nfsigns.keys()
                sql = 'select id, sign from feature_id_map where family_id=%s and sign in (%s)' % (family_id, ','.join(['%s']*len(signs)))
                self.profile_dal.execute(sql, *signs)

                rows = self.profile_dal.cursor.fetchall()
                for r in rows:
                    fid, sign = r['id'], r['sign']
                    f = nfsigns[sign]
                    ret[f] = fid
                    nkvs[kmap[f]] = fid

                nfsigns_ = {sign:f for sign, f in nfsigns.iteritems() if f not in ret}
                if nfsigns_ and save_new:
                    sqls = []
                    params = []
                    for sign, f in nfsigns_.iteritems():
                        sqls.append('(%s, %s, %s)')
                        params.append(family_id)
                        params.append(f)
                        params.append(sign)

                    self.write_profile_dal.execute('insert ignore into feature_id_map (family_id, origin, sign) values %s' % ','.join(sqls), *params)

                    signs = nfsigns_.keys()
                    sql = 'select id, sign from feature_id_map where family_id=%s and sign in (%s)' % (family_id, ','.join(['%s']*len(signs)))
                    self.write_profile_dal.execute(sql, *signs)

                    rows = self.write_profile_dal.cursor.fetchall()
                    for r in rows:
                        fid, sign = r['id'], r['sign']
                        f = nfsigns_[sign]
                        ret[f] = fid
                        nkvs[kmap[f]] = fid

                self.cache.set_multi(nkvs)
        return ret

class FeatureMetaCache:
    def __init__(self, profile_dal, cache=None,futil_client=None):
        self.cache = cache if cache else LocMemCache(
                max_entries=10000, lock=True, copy=False)
        self.profile_dal = profile_dal
        self.futil_client = futil_client

    def get(self, feature_name):
        meta = self.cache.get(feature_name)
        if meta == None:
            if self.futil_client:
                rsp = None
                try:
                    rsp = self.futil_client.feature_meta_get(FeatureMetaGetReq(feature_name))
                except:
                    logging.exception("futil service get feature meta failed")
                if rsp == None:
                    logging.warn("futil service id_mget failed resp is none")
                    return meta
                if rsp.BaseResp.StatusCode != 0:
                    logging.warn("futil service feature_meta_get failed error code:%d",rsp.BaseResp.StatusCode)
                    return meta
                meta = rsp.feature_meta
                meta['default_version'] = int(meta['default_version'])
                meta['family_id'] = int(meta['family_id'])
                self.cache.set(feature_name,meta)
            else:
                self.profile_dal.execute('select * from feature_meta where feature_name=%s', feature_name)
                row = self.profile_dal.cursor.fetchone()
                meta = row if row else {}
                self.cache.set(feature_name, meta)
        return meta

class FeatureCache:
    def __init__(self, profile_dal, cache=None, futil_client=None):
        self.cache = cache if cache else LocMemCache(
                max_entries=10000, lock=True, copy=False)
        self.profile_dal = profile_dal
        self.futil_client = futil_client

    def get(self, fid):
        if self.futil_client:
            raise Exception("unimpl method")
        feature = self.cache.get(fid)
        if feature == None:
            self.profile_dal.execute('select * from feature_id_map where id=%s', fid)
            row = self.profile_dal.cursor.fetchone()
            feature = row if row else {}
            self.cache.set(fid, feature)
        return feature

class FeatureUtil:
    def __init__(self, profile_dal, f2id_cache=None, id2f_cache=None, meta_cache=None, feature_cache=None, channel=False, use_futil_service=False,caller_psm="unknown",ip_addr="unknown",time_out=1,conn_timeout=0.1,target_psm="data.futilservice.master"):
        self.futil_client = None
        if use_futil_service :
            self.futil_client = ThriftFutilClient(target_psm,caller_psm,ip_addr,time_out,conn_timeout);
        self.profile_dal = profile_dal
        self.feature_cache = FeatureCache(profile_dal, feature_cache,self.futil_client)
        self.use_futil_service = use_futil_service
        self.feature_id_cache = Feature2IdCache(profile_dal, f2id_cache, self.futil_client)
        self.id_feature_cache = Id2FeatureCache(profile_dal, id2f_cache, channel, self.futil_client)
        self.meta_cache = FeatureMetaCache(profile_dal, meta_cache,self.futil_client)

    def gen_profile_str(self, family_id, profile, encode=False):
        if encode:
            p = {}
            for k, v in profile.iteritems():
                k_ = k.encode('utf8') if type(k) is unicode else k
                p[k_] = p.get(k_, 0.0) + v

            fid_map = self.feature_id_cache.mget(family_id, p.keys())
            p = {fid_map[k]:v for k, v in p.iteritems()}
        else:
            p = profile

        profile_str = ''
        items = p.items()
        items.sort(key=lambda i:i[1], reverse=True)
        for f, v in items:
            try:
                profile_str += pack('If', f, v)
            except:
                logging.exception("Unexpected Feature: %s:%s" % (f, v))
        return profile_str

    def unpack_profile_str(self, raw_value, decode=False):
        item_size = calcsize('If')
        offset = 0
        profile = {}
        while offset < len(raw_value):
            k, v = unpack_from('If', raw_value, offset)
            profile[k] = v
            offset += item_size

        if decode:
            profile = self.decode_profile(profile)
        return profile

    def decode_profile(self, profile):
        ret = {}
        for k, v in profile.iteritems():
            k_ = self.get_feature_name(k)
            ret[k_] = v
        return ret

    def get_feature_id(self, family_id, feature, save_new=True):
        fs = feature if type(feature) is list else [feature]
        utf8_unicode = {}
        fs_utf8 = []
        for ft in fs:
            encode_key = ft
            if type(ft) is unicode :
                encode_key = ft.encode('utf8')
                utf8_unicode[encode_key] = ft
                fs_utf8.append(encode_key) #将所有的unicode编码的字串改为utf8编码
            else:
                utf8_unicode[ft] = ft
                fs_utf8.append(ft)  
        fid_map = self.feature_id_cache.mget(family_id, fs_utf8, save_new)
        fid_map = {utf8_unicode[k]:v for k,v in fid_map.iteritems()}#将所有的原本为unicode编码的字串变回unicode编码
        if type(feature) is not list:
            return fid_map.get(feature)
        return fid_map


    def get_feature_name(self, fid):
        fids = fid if type(fid) is list else [fid]
        ret = self.id_feature_cache.mget(fids)
        if type(fid) is not list:
            return ret.get(fid)
        return ret


    def get_feature(self, fid):
        if self.use_futil_service:
            logging.warn("this method not impl")
            raise Exception("unimpl method")
        return self.feature_cache.get(fid)


    def get_feature_meta(self, fname):
        return self.meta_cache.get(fname)


    def init_feature_cache(self, f2id=True, id2f=True):
        if self.use_futil_service:
            logging.warn("this method not impl")
            return

        start = 0
        while True:
            self.profile_dal.execute('select id, origin from feature_id_map where id>%s order by id limit 10000' % start)
            rows = self.profile_dal.cursor.fetchall()
            if not rows:
                break

            if f2id:
                kvs = {r['origin']:r['id'] for r in rows}
                self.feature_id_cache.cache.set_multi(kvs)

            if id2f:
                kvs = {r['id']:r['origin'] for r in rows}
                self.id_feature_cache.cache.set_multi(kvs)

            start = rows[-1]['id']


if __name__ == '__main__':
    from ss_data.profile.conf import profile_dal

    futil = FeatureUtil(profile_dal,use_futil_service=True,time_out=1,conn_timeout=2,target_psm="data.futilservice.master")
    futil = FeatureUtil(profile_dal,use_futil_service=True,time_out=1,conn_timeout=2)
    features = [str(i) for i in range(100)]
    fids = futil.get_feature_id(7, features)
    print fids

    fname = fids.values()
    fid = futil.get_feature_name(fname)
    print fid

    fname = 'dl_128_topic'

    meta = futil.get_feature_meta(fname);
    print meta

    feature = [u'清和',u'正言']
    fids = futil.get_feature_id(1,feature)
    print "fid ",fids
    feature = ['清和','正言']
    fids = futil.get_feature_id(1,feature)
    print "fid ",fids



#coding=utf-8

import logging
import socket
from pyutil.program.fmtutil import pformat
from pyutil.program.functool import retries

log = logging

class HBaseDal(object):
    """ Wrapper for happybase.
    """
    dry_run = False

    def __init__(self, pool, table, coder=None, dry_run=None,
            max_retries=3, retry_exceptions=(socket.timeout,),
            retry_methods=None,
            ):
        """
        :param pool: happybase.pool.ConnectionPool instance
        :param str table: table name
        :param bool dry_run: 为None表示尊重类级别的设置
        :param int max_retries: 异常重试的次数
        :param retry_exceptions: 进行重试的异常
        :param retry_methods: 失败重试的方法, list of method names
        """
        self.pool = pool
        self._table = table
        self._coder = coder
        self.max_retries = max_retries
        self.retry_exceptions = retry_exceptions
        if dry_run is not None:
            self.dry_run = dry_run
        self.read_methods = ['row', 'rows', 'cells', 'scan', 'counter_get']
        table_methods = [
                'delete',
                'counter_get', 'counter_set', 'counter_inc', 'counter_dec',
                ]
        if retry_methods is None:
            retry_methods = self.read_methods + ['counter_set', 'delete', 'batch_put'] # 近似冥等(idempotent)
        for name in table_methods:
            setattr(self, name, self._wrap_table_method(name))
        for name in set(retry_methods) - set(['put', 'row']):
            setattr(self, name, self._wrap_retries(name))


    def _wrap_table_method(self, method_name):
        def wrapper(*args, **kwargs):
            with self.pool.connection() as conn:
                tbl = conn.table(self._table)
                method_ = getattr(tbl, method_name)
                if self.dry_run:
                    method = self._get_dry_method(tbl, method_name)
                else:
                    method = method_
                return method(*args, **kwargs)
        return wrapper

    def _wrap_retries(self, method_name):
        method = getattr(self, method_name)
        if self.max_retries:
            method = retries(max_tries=self.max_retries + 1,
                    exceptions=self.retry_exceptions)(method)
        return method

    def _get_dry_method(self, tbl, method_name):
        def dry_write(*args, **kwargs):
            log.info('[dry] hbase %s for table %s', method, self._table)

        dry_methods = {}
        if method_name in self.read_methods:
            return getattr(tbl, method_name)
        return dry_methods.get(method_name, dry_write)


    def row(self, row, columns=None, timestamp=None, include_timestamp=False):
        rows = self.rows([row], columns, timestamp, include_timestamp)
        return rows[0][1] if rows else {}

    def rows(self, rows, columns=None, timestamp=None, include_timestamp=False):
        with self.pool.connection() as conn:
            tbl = conn.table(self._table)
            rowds = tbl.rows(rows, columns, timestamp, include_timestamp)
            new_rowds = []
            for row, data in rowds:
                try:
                    rowd = self._decode_row(data, include_timestamp)
                    new_rowds.append((row, rowd))
                except Exception as e:
                    log.exception('ignore bad row, row_key=%s, row_data=%s, exception=%s',
                            row, data, e)
            return new_rowds

    def cells(self, row, column, versions=None, timestamp=None,
                          include_timestamp=False):
        with self.pool.connection() as conn:
            tbl = conn.table(self._table)
            cells = tbl.cells(row, column, versions, timestamp, include_timestamp)
            return [self._decode_cell(column, cell, include_timestamp) for cell in cells]

    def scan(self, *args, **kwargs):
        with self.pool.connection() as conn:
            tbl = conn.table(self._table)
            for row, data in tbl.scan(*args, **kwargs):
                yield row, self._decode_row(data, kwargs.get('include_timestamp', False))


    def put(self, row, data, timestamp=None, wal=True):
        if self.dry_run:
            log.info('[dry] hbase put row %r={%s} for table %s', row, pformat(data, max_v_limit=100)[:200], self._table)
            return
        return self.batch_put([(row, data)], timestamp, wal)


    def batch_put(self, rows, timestamp=None, wal=True):
        if not rows:
            return
        if self.dry_run:
            log.info('[dry] hbase batch_put %s rows for table %s: %r={%s}',
                    len(rows), self._table, rows[0][0],
                    pformat(rows[0][1], max_v_limit=100)[:200]
                    )
            return
        with self.pool.connection() as conn:
            tbl = conn.table(self._table)
            with tbl.batch(timestamp, wal=wal) as b:
                for row_key, row in rows:
                    b.put(row_key, self._encode_row(row))


    def _encode_row(self, row):
        if not self._coder: return row
        return {k: self._coder.encode(k, v) for k, v in row.items()}

    def _decode_cell(self, cn, cell, include_timestamp):
        if not self._coder:
            return cell
        return (self._coder.decode(cn, cell[0]), cell[1]) if include_timestamp else self._coder.decode(cn, cell)

    def _decode_row(self, row, include_timestamp):
        if not self._coder: return row
        return {k: self._decode_cell(k, v, include_timestamp) for k, v in row.items()}

#coding=utf-8
import json
from datetime import datetime
from pyutil.program.json_utils import json_dumps

class EmptyCoder(object):
    @staticmethod
    def encode(v): return v
    @staticmethod
    def decode(v): return v


class HDateTimeCoder(object):
    @staticmethod
    def encode(dt):
        if dt is None: return None
        if isinstance(dt, basestring):
            return dt
        else:
            return dt.strftime('%Y-%m-%d %H:%M:%S')

    @staticmethod
    def decode(dt_str):
        if dt_str is None or isinstance(dt_str, datetime):
            return dt_str
        if isinstance(dt_str, int):
            return datetime.fromtimestamp(dt_str)
        else:
            return datetime.strptime(dt_str, '%Y-%m-%d %H:%M:%S')

class HBoolCoder(object):
    @staticmethod
    def encode(v):
        if v is None: return None
        return str(int(v))

    @staticmethod
    def decode(v):
        if v is None: return None
        return bool(int(v))


class HTypeCoder(object):
    def __init__(self, for_type):
        self.for_type = for_type

    def encode(self, v):
        return str(v)

    def decode(self, v):
        return self.for_type(v)

class HJsonCoder(object):
    def __init__(self, for_type):
        self.for_type = for_type

    def encode(self, v):
        """
        >>> coder = HJsonCoder(list)
        >>> coder.encode([10])
        '[10]'
        >>> coder.encode(10)
        Traceback (most recent call last):
        ...
        ValueError: <type 'list'> expected, got <type 'int'>
        """
        if not isinstance(v, self.for_type):
            raise ValueError('%s expected, got %s' % (self.for_type, type(v)))
        return json_dumps(v)

    def decode(self, v):
        """
        >>> coder = HJsonCoder(list)
        >>> coder.decode('[10]')
        [10]
        >>> coder.decode('10')
        Traceback (most recent call last):
        ...
        ValueError: <type 'list'> expected, got <type 'int'>
        """
        dv = json.loads(v)
        if not isinstance(dv, self.for_type):
            raise ValueError('%s expected, got %s' % (self.for_type, type(dv)))
        return dv

class HIntsCoder(object):
    @staticmethod
    def encode(v):
        """
        >>> HIntsCoder.encode([])
        ''
        >>> HIntsCoder.encode([1, 2])
        '1,2'
        """

        return ','.join(map(str, v))

    @staticmethod
    def decode(v):
        """
        >>> HIntsCoder.decode('')
        []
        >>> HIntsCoder.decode('1,2')
        [1, 2]
        """
        if not v: return []
        return map(int, v.split(','))

class HCompositionCoder(object):
    """
    多个coder的合成。使用第一个coder进行encode, 使用第一个能成功decode的coder进行decode
    主要用于属性改变类型时做兼容性处理.

    >>> coder = HCompositionCoder(HJsonCoder(list), HIntsCoder)
    >>> coder.encode([1,2])
    '[1,2]'
    >>> coder.decode('[1, 2]')
    [1, 2]
    >>> coder.decode('1,2')
    [1, 2]
    >>> coder.decode('x')
    Traceback (most recent call last):
    ...
    ValueError: invalid literal for int() with base 10: 'x'
    """
    def __init__(self, *coders):
        self.coders = coders

    def encode(self, v):
        return self.coders[0].encode(v)

    def decode(self, v):
        for i, coder in enumerate(self.coders):
            try:
                return coder.decode(v)
            except:
                if i == len(self.coders) - 1:
                    raise


TYPE2CODER = {
        datetime: HDateTimeCoder,
        int: HTypeCoder(int),
        float: HTypeCoder(float),
        bool: HBoolCoder,
        list: HJsonCoder(list),
        dict: HJsonCoder(dict),
        }

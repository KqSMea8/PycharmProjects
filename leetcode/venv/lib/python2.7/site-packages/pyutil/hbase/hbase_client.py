#!/usr/bin/env python
#coding:utf-8

"""
    Hbase Thrift Client
    对hbase thrift client适度封装，线程不安全，提供多thrift server支持，切换失效thrift server功能。

    以下是部分Hbase client使用示例
        import hbase_client
        from pyutil.program.sys_conf import Conf

        conf = Conf('/home/huxiao/repos/ss_conf/ss/hbase.conf')
        client = hbase_client.HbaseClient(conf.hbase_thrift_proxy_farm)
        rows = []
        for i in xrange(48):
            row = "rowkey_%02d"%i
            value = "value_%d"%i
            rows.append((row, value))
            mutations=[Mutation(column="c:a",value=value)]
            client.mutate_row(self.table_name, row, mutations, None) #单条写入
            logging.debug("process row %s"%row)

        results = client.get_row(self.table_name, "rowkey_24", None) #单条随机读
        logging.debug("get rowkey_24 result %s"%results)

        client.put_kv_rows(self.table_name, rows, "c:b") #批量kv方式写入，rows元素是tuple (k,v), 所有rows元素必须在一个columnFamily:column下
        logging.debug("batch put rows")

        results = client.scan_rows_results(self.table_name, "rowkey_0", "rowkey_a", None) #顺序查询，线程不安全， 返回迭代器
        index = 0
        for r in results:
            logging.debug(r)
            index += 1
"""


import time, logging, re, random, threading, socket
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from ss_thrift_gen.hbase import Hbase
from ss_thrift_gen.hbase.ttypes import *
from pyutil.consul import bridge


class HbaseClient(object):
    """
        HbaseClient is a wrapper for hbase thrift client, include some client switch, exception handle
        Attention: Not Thread Safe
    """
    lock = threading.Lock()
    def __init__(self, servers, retry_num = 1, scan_retry_num = 5, dead_time = 10, timeout=500, lb_service_name=None, service_name=None):
        self.retry_num = retry_num
        self.scan_retry_num = scan_retry_num
        self.dead_time = dead_time
        if not isinstance(servers, (tuple, list)):
            raise ValueError("servers must be tuple or list")
        self.server_num = len(servers)
        self.service_name = service_name
        self.timeout_s = timeout / 1000.0
        if not self.server_num and lb_service_name is None and service_name is None:
            raise ValueError('hbase thrift servers must not be null.')
        if lb_service_name is None:
            if service_name is None:
                self.servers = [_HbaseClientProxy(s, self.dead_time, timeout) for s in servers]
            else:
                self.servers = []
                self._refresh_servers()
        else:
            self.servers = [_HbaseClientProxy(None, self.dead_time, timeout, use_lb=True, lb_service_name=lb_service_name)]
        self.client, self.server = self.get_client()
        self.failed_num = 0

    def _refresh_servers(self):
        old = {s.host: s for s in self.servers}
        new_servers = ['{}:{}'.format(host, port) for host, port in bridge.translate_one(self.service_name)]
        new = []
        for s in new_servers:
            if s in old:
                new.append(old[s])
                del old[s]
            else:
                new.append(_HbaseClientProxy(s, self.dead_time, self.timeout_s * 1000))
        self.servers = new
        for s in old.itervalues():
            s._close_transport()

    def _check_client(self, force = False):
        if self.failed_num >= 10 or force:
            logging.info("try to reconnect server...")
            self.server.mark_dead("too many io exception, change hbase client.")
            if self.service_name is not None:
                self._refresh_servers()
            self.client, self.server = self.get_client()
            self.failed_num = 0

    def get_client(self):
        logging.info("server_list: %s" % self.servers)
        server_list = self.servers[:]
        random.shuffle(server_list)
        for i in range(10):
            with HbaseClient.lock:
                for server in server_list:
                    client = server.connect()
                    if client:
                        return client, server
                    else:
                        logging.info("ignore thrift server %s"%str(server))
            time.sleep(i)
        raise Exception("no available hbase client")

    def put_kv_rows(self, table_name, rows, column):
        """
            批量kv写入接口， rows是dict，key是rowkey， value是value
            此函数限制在于一个rowkey只能写入一个"cf:c"的数据，如需一个rowkey写入多个"cf:c"数据，请使用
                def mutate_rows(self, table_name, row_batches, attributes=None)函数
        """
        if not column:
            raise Exception("column must not be none")
        batch_mutations = []
        for kv in rows:
            if not isinstance(kv, tuple):
                raise Exception("put_kv_rows must be tuple, and your kv is %s"%str(kv))
            (key, value) = kv
            m = Mutation(column=column, value=value)
            bm = BatchMutation(row=key, mutations=[m])
            batch_mutations.append(bm)
        return self.mutate_rows(table_name, batch_mutations, None)

    def scan_rows_results(self, table_name, start_row, stop_row, columns=None, attributes=None, limit=None, reversed=False):
        """
            批量读接口，返回迭代器，防止一次返回数据过多。
            当thriftserver出现异常时，自动切换，同时记录之前访问位置
            自动关闭scan打开的scanner，防止在regionserver端占用过多资源
            线程不安全
        """
        start = start_row
        stop = stop_row
        result = None
        exception = False
        max_count = 2 ** 31
        if limit:
            try:
                max_count = int(limit)
            except:
                raise ValueError("limit must be integer..., this limit is %s", limit)
        index = 0
        for i in range(self.scan_retry_num):
            #hbase-0.98.6.1 支持反向scan了
            #if start >= stop:
            #    logging.info("start_row [%s] >= stop_row [%s]"%(start, stop))
            #    break
            self._check_client(exception)
            exception = False
            scan = TScan(startRow=start, stopRow=stop, columns=columns, reversed=reversed)
            idx = None
            try:
                idx = self.client.scannerOpenWithScan(table_name, scan, attributes)
                while True:
                    results = self.client.scannerGetList(idx, nbRows=1024)
                    logging.debug("scannerGetList results len is %d"%len(results))
                    if not results:
                        logging.info("finish scan table %s, start row: %s, stop row: %s"%(table_name, start_row, stop_row))
                        return
                    for r in results:
                        result = r
                        index += 1
                        if index > max_count:
                            return
                        yield r
            except socket.timeout, ex:
                logging.info("scan exception : %s"%str(ex))
                exception = True
                if result:
                    start = result.row
                if idx:
                    self.client.scannerClose(idx)
                self.server._close_transport()
            except Exception, ex:
                logging.info("scan exception : %s"%str(ex))
                exception = True
                if result:
                    start = result.row
                if idx:
                    self.client.scannerClose(idx)
                self.server._close_transport()
                time.sleep(min(2**i, self.timeout_s))
            finally:
                if idx and not exception:
                    self.client.scannerClose(idx)

    def mutate_row(self, table_name, row, mutations, attributes=None):
        """
            封装hbase thrift mutateRow接口,单次写入
        """
        self._process_cmd("mutateRow", table_name, row, mutations, attributes)

    def mutate_rows(self, table_name, row_batches, attributes=None):
        """
            封装hbase thrtift mutateRows接口，批量写入
        """
        return self._process_cmd("mutateRows", table_name, row_batches, attributes)

    def get_row(self, table_name, row, attributes=None):
        """
            封装hbase thrift getRow接口，随机读指定rowkey数据，返回list
        """
        return self._process_cmd("getRow", table_name, row, attributes)

    def get_row_columns(self, table_name, row, columns, attributes=None):
        """
            封装hbase thrift getRow接口，随机读指定rowkey+ cf:column数据，返回list
        """
        return self._process_cmd("getRowColumns", table_name, row, columns, attributes)

    def get_row_with_columns(self, table_name, row, columns, attributes=None):
        """
            封装hbase thrift getRow接口，随机读指定rowkey+ cf:column数据，返回list
        """
        return self._process_cmd("getRowWithColumns", table_name, row, columns, attributes)


    def get_rows(self, table_name, rows, attributes=None):
        """
            封装hbase thrift getRows接口，随机批量读指定rowkey数据集合，返回结果list
        """
        return self._process_cmd("getRows", table_name, rows, attributes)

    def atomicIncrement(self, table_name, row, column, value):
        """
            封装hbase thrift atomicIncrement接口
        """
        return self._process_cmd("atomicIncrement", table_name, row, column, value)

    def incrementRows(self, increments):
        """
            封装hbase thrift incrementsRows接口
        """
        return self._process_cmd("incrementRows", increments)

    def deleteAllRow(self, tableName, row, attributes=None):
        """
            封装hbase thrift deleteAllRow接口
        """
        return self._process_cmd("deleteAllRow", tableName, row, attributes)

    def _process_cmd(self, method, *args, **kargs):
        for i in range(self.retry_num):
            self._check_client()
            try:
                result = getattr(self.client, method)(*args, **kargs)
                return result if method != "mutateRows" else True   # trick,批量写成功返回True，失败False
            except socket.timeout, ex:
                self.failed_num = 10
                logging.warning("table exception, %s", str(ex))
                self.server._close_transport()
            except Exception, ex:
                self.failed_num = 10
                logging.warning("table exception, %s", str(ex))
                self.server._close_transport()
                time.sleep(min(2**i, self.timeout_s))
        return None if method != "mutateRows" else False

class _HbaseClientProxy(object):
    def __init__(self, host, dead_time, timeout=500, use_lb=False, lb_service_name=None, lb_request_id=None, framed=False):
        self.host = host
        self.dead_time = dead_time
        self.transport = None
        self.deaduntil = 0
        self.use_lb = use_lb
        self.framed = framed
        if not use_lb:
            m = re.match(r'(.+?):(\d+)$', host)
            if not m:
                raise ValueError('Unable to parse connection string: "%s"' % host)
            self.ip = m.group(1)
            self.port = m.group(2)
        else:
            self.lb_service_name = lb_service_name
            self.lb_request_id = lb_request_id
            if self.lb_service_name.find('-nb') > -1:
                self.framed = True
        self.timeout = timeout

    def __del__(self):
        self._close_transport()

    def __str__(self):
        if self.use_lb:
            return '%s/%s' % (self.lb_service_name, self.lb_request_id)
        return "%s:%s"%(self.ip, self.port)

    def connect(self):
        """
            返回hbase thrift client instance
        """
        transport = self._get_transport()
        if transport:
            protocol = TBinaryProtocol.TBinaryProtocol(transport)
            client = Hbase.Client(protocol)
            return client
        else:
            return None

    def mark_dead(self, msg):
        """
            标记失效，一段时间有效
        """
        if not self.use_lb:
            self.deaduntil = time.time() + self.dead_time
            logging.info("mark dead,%s"%str(msg))
        self._close_transport()

    def _check_dead(self):
        if self.deaduntil and self.deaduntil > time.time():
            return 1
        else:
            return 0

    def _get_transport(self):
        if self._check_dead():
            return None
        if self.transport:
            return self.transport
        if self.use_lb:
            from pyutil.lb import LBTSocket
            transport = LBTSocket(self.lb_service_name, request_id=self.lb_request_id, timeout=self.timeout/1000.0, interact_timeout=self.timeout/1000.0)
        else:
            transport = TSocket.TSocket(self.ip, int(self.port))
        transport.setTimeout(self.timeout)
        if self.framed:
            logging.info('Using framed transport for hbase')
            transport = TTransport.TFramedTransport(transport)
        else:
            transport = TTransport.TBufferedTransport(transport)
        try:
            transport.open()
        except Exception as ex:
            self.mark_dead(str(ex))
            return None
        self.transport = transport
        logging.debug("Connect to [%s]", str(self))
        return transport

    def _close_transport(self):
        if self.transport:
            self.transport.close()
            self.transport = None


def main():
    print __doc__

if __name__ == "__main__":
    main()

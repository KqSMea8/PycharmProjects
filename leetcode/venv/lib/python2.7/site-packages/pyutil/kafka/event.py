#coding=utf-8
from collections import namedtuple
from datetime import datetime, date
from pyutil.program.json_utils import json_dumps
from pyutil.program.python import compact, map_dict
from .coder import get_type_coder
Field = namedtuple('Field', 'name coder')

def kafka_send_key_events(producer, topic, events, sender=None, log_id=''):
    """ Batch send KafkaEvent to given kafka topic.
    :param producer: KeyedProducer
    :param topic: topic name
    :param events: list of KafkaEvent
    """
    if not events:
        return
    for ev in events:
        ev.event_enqueue_time = ev.event_enqueue_time or datetime.now()
        ev.event_sender = ev.event_sender or sender
    msgs = [(e.event_key, e.as_json()) for e in events]
    non_str_ekeys = [event_key for event_key, _ in msgs if not isinstance(event_key, str)]
    if non_str_ekeys:
        raise ValueError('non-str event_key: %r', non_str_ekeys[0])
    producer.send_key_messages(topic, msgs)

class KafkaEvent(object):
    EVENT_KEY_NAME = None
    event_type = None
    event_spec = (
            'event_local_id', # 仅用于标识
            'event_subtype',
            ('event_priority', int),
            'event_sender',
            'event_sender_addr',
            ('event_enqueue_time', datetime),
            ('event_tracks', list),
            ('event_track_num', int),
            )
    payload_spec = ()

    def __init__(self, **kwargs):
        for f in self.fields().values():
            if f.name in kwargs:
                try:
                    setattr(self, f.name, f.coder.decode(kwargs[f.name]))
                except ValueError as e:
                    raise ValueError('field %s: %s, coder=%s' % (f.name, e, f.coder))
            else:
                setattr(self, f.name, None)

    @classmethod
    def _get_fields(cls, spec, cache_name):
        if hasattr(cls, cache_name):
            return getattr(cls, cache_name)
        fields = {f.name: f for f in map(cls._parse_field, spec)}
        setattr(cls, cache_name, fields)
        return fields

    @classmethod
    def payload_fields(cls):
        return cls._get_fields(cls.payload_spec, '_payload_fields')

    @classmethod
    def fields(cls):
        return cls._get_fields(tuple(cls.event_spec) + tuple(cls.payload_spec), '_fields')


    @property
    def event_key(self):
        """ 用于kafka partition的分发 """
        if ':' in self.EVENT_KEY_NAME:
            event_key = ':'.join([str(getattr(self, k)) for k in self.EVENT_KEY_NAME.split(':')])
        else:
            event_key = str(getattr(self, self.EVENT_KEY_NAME)) if self.EVENT_KEY_NAME else None
        return event_key

    @property
    def log_id(self):
        return '%s(%s)' % ('.'.join(compact([self.event_type, self.event_subtype])), self.event_key)

    def __str__(self):
        return '%s(%s %s)' % (self.__class__.__name__, self.event_subtype, self.event_key)

    def as_json(self):
        return json_dumps(self.as_json_dict())

    def as_json_dict(self):
        '''
        转为可json dumps的dict
        '''
        d = self.encode(self)
        d = map_dict(d,lambda k, v, pkeys: ((k, v.strftime('%Y-%m-%d %H:%M:%S')) if isinstance(v, date) else (k, v)))
        return d

    def payload(self):
        """
        排除None和属性event_*,_*
        :rtype: dict
        """
        return {k: getattr(self, k) for k in self.payload_fields() if getattr(self, k) is not None}

    @property
    def event_delay(self):
        '''
        :rtype float: process delay in seconds
        '''
        if self.event_enqueue_time is None:
            return None
        return (datetime.now() - self.event_enqueue_time).total_seconds()

    @classmethod
    def from_json(cls, json_str):
        return cls.decode(json.loads(json_str))

    @classmethod
    def encode(cls, ev_obj):
        if ev_obj is None: return None
        d = dict(event_type=cls.event_type)
        for f in cls.fields().values():
            k = f.name
            v = getattr(ev_obj, k, None)
            if v is not None:
                d[k] = f.coder.encode(v)
        return d

    @classmethod
    def decode(cls, ev_dict, skip_values=[], **extra):
        if ev_dict is None: return None
        if isinstance(ev_dict, cls):
            if not extra:
                return ev_dict
            else:
                ev_dict = ev_dict.__dict__
        ev_dict = dict(ev_dict, **extra)
        if skip_values:
            ev_dict = {k: v for k, v in ev_dict.items() if v not in skip_values}
        return cls(**ev_dict)

    @staticmethod
    def _parse_field(f):
        type_ = basestring
        if isinstance(f, basestring):
            name = f
        else: # tuple
            if len(f) == 1:
                name = f
            else:
                name, type_ = f
        coder = get_type_coder(type_)
        return Field(name=name, coder=coder)

    def append_track_info(self, parent_event, **track_info):
        if parent_event is None or parent_event.event_tracks is None:
            parent_tracks = []
        else:
            parent_tracks = parent_event.event_tracks
        self.event_tracks = parent_tracks + [dict(track_info, append_time=datetime.now())]
        self.event_track_num = (parent_event.event_track_num or 0 if parent_event else 0) + 1

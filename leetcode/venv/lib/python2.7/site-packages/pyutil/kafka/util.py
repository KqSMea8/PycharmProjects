#coding=utf-8
import logging
import msgpack
import json
import ujson
from collections import namedtuple

ExtendedMessage = namedtuple("ExtendedMessage", 'meta message unpacked_value message_id')
MessageMeta = namedtuple('MessageMeta', 'topic group partition offset')

logger = logging.getLogger(__name__)

def json_decode(v):
    """
    >>> json_decode('9223372036854775808') # 2**63
    9223372036854775808L
    >>> json_decode('9223372036854775807') # 2**63 - 1
    9223372036854775807L
    >>> json_decode('x')
    Traceback (most recent call last):
    ...
    ValueError: No JSON object could be decoded
    """
    # ujson不能处理超过64-bit signed integer范围的整数，所以做此trick
    try:
        decoded_v = ujson.loads(v)
    except ValueError as e:
        decoded_v = json.loads(v)
    return decoded_v

def extend_message(topic, group, partition, offset, message, message_format):
    """
    :param kafka.common.Message message: namedtuple("Message", ["magic", "attributes", "key", "value"])
    """
    try:
        if message_format == 'json':
            decoded_v = json_decode(message.value)
        elif message_format == 'msgpack':
            decoded_v = msgpack.unpackb(message.value, use_list=True)
        elif message_format == 'raw':
            decoded_v = message.value
        else:
            decoded_v = message.value
    except Exception as e:
        decoded_v = None
        logger.exception('Fail to transform message(%s,%s,%s), e=%s',
                topic, partition, offset, e)
    message_id = '%s,%s,%s' % (topic, partition, offset)
    return ExtendedMessage(MessageMeta(topic, group, partition, offset), message, decoded_v, message_id)

#!/usr/bin/python

from lb_agent_protocol_pb2 import *
from peer_cache import pick_nearest_peer
import pyutil.program.metrics2 as metrics
import sys, fdunix, socket, struct, threading

LB_AGENT_SOCK = '/opt/tmp/lb_agent.sock'
RECV_BUFFER_SIZE = 65536

AGENT_LOCAL=0
AGENT_REMOTE=1
REMOTE_PORT=2284

tls_control = threading.local()

metrics.define_counter('bootstrap.remote', prefix='inf.lb_agent')
metrics.define_counter('bootstrap.error', prefix='inf.lb_agent')
metrics.define_counter('bootstrap.fail', prefix='inf.lb_agent')
metrics.define_counter('bootstrap.no_peer', prefix='inf.lb_agent')

class ControlConnection:
    __slots__ = ['sock', 'stream', 'timeout']

    def __init__(self, agent_type, peer, timeout):
        self.timeout = timeout
        if agent_type == AGENT_LOCAL:
            self.stream = False
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sock.settimeout(timeout)
            self.sock.connect(LB_AGENT_SOCK)
        else:
            self.header_struct = struct.Struct('>I')
            self.stream = True
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(timeout)
            self.sock.connect(peer)

    def send_proto(self, message):
        payload = message.SerializeToString()
        if self.stream:
            header = self.header_struct.pack(len(payload))
            self.sock.send(header)
        self.sock.send(payload)

    def recv_proto(self, message):
        if self.stream:
            flags = socket.MSG_WAITALL
            header = self.sock.recv(self.header_struct.size, flags)
            buffer_size = self.header_struct.unpack(header)[0]
        else:
            flags = 0
            buffer_size = RECV_BUFFER_SIZE
        payload = self.sock.recv(buffer_size, flags)
        message.ParseFromString(payload)

    def recv_fd(self):
        return fdunix.receive_socket(self.sock, self.timeout)

def create_control_connection(timeout, remote):
    if remote:
        peer = pick_nearest_peer()
        if peer is None:
            metrics.emit_counter('bootstrap.no_peer', 1, prefix='inf.lb_agent')
            remote = False
    return ControlConnection(
        AGENT_REMOTE if remote else AGENT_LOCAL,
        (peer, REMOTE_PORT) if remote else None,
        timeout
    )

def release_control_connection():
    tls_control.conn = None

def get_control_connection(timeout):
    if not hasattr(tls_control, 'conn') or tls_control.conn is None:
        try:
            tls_control.conn = create_control_connection(timeout, False)
        except:
            metrics.emit_counter('bootstrap.remote', 1, prefix='inf.lb_agent')
            tls_control.conn = create_control_connection(timeout, True)
    return tls_control.conn

def build_request(name, request_id, require_client_connect, weight, ttl, require_passive=None):
    req = BootstrapRequest()
    req.serviceName = name
    if request_id is not None:
        req.requestId = str(request_id)
    if require_client_connect:
        req.requireClientConnect = require_client_connect
    if weight is not None:
        req.weight = weight
    if ttl is not None:
        req.ttl = ttl
    if require_passive is not None:
        req.requirePassive = require_passive
    return req

def request_bootstrap_attempt(req, timeout):
    try:
        ctrl = get_control_connection(timeout)
    except:
        release_control_connection()
        return None, None
    resp = BootstrapResponse()
    should_release = False
    try:
        ctrl.send_proto(req)
        ctrl.recv_proto(resp)
        return resp, ctrl
    except:
        release_control_connection()
        return None, None

def bootstrap_attempt(req, timeout):
    resp, ctrl = request_bootstrap_attempt(req, timeout)
    if resp is None:
        # Bootstrap connection failed.
        return
    if resp.status != OK:
        raise socket.error("LB returned %s" % resp.status)
    if resp.transportType == DELEGATE_FD:
        try:
            return ctrl.recv_fd()
        except Exception, e:
            # cannot tell whether something went wrong with lbagent or remote endpoint yet
            # by releasing the control connection and recreate one, if lbagent goes wrong, connect will fail
            release_control_connection()
            raise e
    if resp.transportType == PROXY:
        proxy_sock = ctrl.sock
        release_control_connection()
        return proxy_sock
    if resp.transportType == CLIENT_CONNECT:
        service_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        host, port = resp.endpointAddress.split(':')
        service_sock.settimeout(timeout)
        service_sock.connect((host, int(port), ))
        return service_sock

def get_service_connection(name, request_id=None, require_client_connect=False, weight=None, ttl=None, timeout=1.0, max_retries=5):
    req = build_request(name,
        request_id=request_id,
        require_client_connect=require_client_connect,
        weight=weight,
        ttl=ttl)
    i = 0
    while i < max_retries:
        sock = bootstrap_attempt(req, timeout)
        if sock is not None:
            return sock
        metrics.emit_counter('bootstrap.error', 1, prefix='inf.lb_agent')
        i += 1
    metrics.emit_counter('bootstrap.fail', 1, prefix='inf.lb_agent')
    raise socket.error("LB agent unavailable")

def get_thrift_socket(service_name, request_id=None, timeout=1.0):
    from thrift_support import LBTSocket
    return LBTSocket(service_name, request_id=request_id, timeout=1.0)

if __name__ == '__main__':
    from thrift.transport import *
    from thrift.protocol import TBinaryProtocol
    from ss.group_comments import GroupCommentsService
    from ss.group_comments.ttypes import Request
    from ss.group_comments.ttypes import ProductType
    from ss.group_comments.ttypes import SortType
    from thrift_support import LBTSocket
    socket = LBTSocket('comment_service2', request_id='1231')
    transport = TTransport.TBufferedTransport(socket)
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
    client = GroupCommentsService.Client(protocol)
    transport.close()
    transport.open()
    request = Request(
        group_id=long(6270706037101707522), offset=0,
        user_ids=set(),
        uids=set(),
        count=20,
        order_by=SortType.SMART_HOT,
        user_id=0,
        device_id=123456,
        flags=None,
        ab_params=None
    )
    print client.get(request)
    transport.close()
    transport.open()
    request = Request(
        group_id=long(6270706037101707522), offset=0,
        user_ids=set(),
        uids=set(),
        count=20,
        order_by=SortType.SMART_HOT,
        user_id=0,
        device_id=123456,
        flags=None,
        ab_params=None
    )
    print client.get(request)

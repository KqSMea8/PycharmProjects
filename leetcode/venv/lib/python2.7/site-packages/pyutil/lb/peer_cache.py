#!/usr/bin/python
import errno
import random, time, logging
from pyutil.net.get_local_ip import get_local_ip
from pyutil.net.ip import ip2int, int2ip

SERF_SNAPSHOT_PATH = '/tmp/consul_agent/serf/local.snapshot'

RACK_BITS = 26
DC_BITS = 16

DISTANCE_LOCAL_RACK = 0
DISTANCE_LOCAL_DC = 1
DISTANCE_REMOTE = 2
PEER_REFRESH_INTERVAL = 3600

SORTED_PEERS = None

def load_serf_snapshot():
    nodes = []
    try:
        with open(SERF_SNAPSHOT_PATH, 'r') as f:
            for line in f:
                cols = line.strip().split(' ')
                if len(cols) != 3 or cols[0] != 'alive:':
                    continue
                pos = cols[2].find(':')
                if pos <= 0:
                    continue
                nodes.append(cols[2][0:pos])
    except IOError as e:
        if e.errno != errno.ENOENT:
            raise
    return nodes

def distance(int0, int1):
    rack0 = int0 >> (32-RACK_BITS)
    rack1 = int1 >> (32-RACK_BITS)
    if rack0 == rack1:
        return DISTANCE_LOCAL_RACK
    dc0 = int0 >> (32-DC_BITS)
    dc1 = int1 >> (32-DC_BITS)
    if dc0 == dc1:
        return DISTANCE_LOCAL_DC
    return DISTANCE_REMOTE

def calculate_sorted_peers():
    nodes = load_serf_snapshot()
    local_ip = get_local_ip()
    nodes_int = map(ip2int, nodes)
    local_ip_int = ip2int(local_ip)
    by_distance = [[], []]
    for i in range(0, len(nodes)):
        if nodes_int[i] == local_ip_int:
            continue
        dist = distance(local_ip_int, nodes_int[i])
        if dist > DISTANCE_LOCAL_DC:
            continue
        by_distance[dist].append(nodes[i])
    return by_distance

def refresh_sorted_peers():
    global SORTED_PEERS, SORTED_PEERS_TTL
    SORTED_PEERS = calculate_sorted_peers()
    SORTED_PEERS_TTL = time.time()

def ensure_sorted_peers():
    global SORTED_PEERS, SORTED_PEERS_TTL
    if SORTED_PEERS is None or time.time() - SORTED_PEERS_TTL > PEER_REFRESH_INTERVAL:
        try:
            refresh_sorted_peers()
        except Exception, e:
            logging.exception(e)
            return False
    return True

def pick_nearest_peer():
    global SORTED_PEERS
    if not ensure_sorted_peers():
        return None
    peers = SORTED_PEERS
    if len(peers[0]) > 0:
        return random.choice(peers[0])
    else:
        return peers[1]

if __name__ == '__main__':
    for i in range(0, 100):
        print pick_nearest_peer()

#!/usr/bin/env python
# coding=utf8

import logging
import os
import sys
import smtplib, base64
import time
# For guessing MIME type based on file name extension
import mimetypes

from email import encoders
from email.header import Header
from email.message import Message
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

COMMASPACE = ', '
EMAIL_HOST_PASSWORD = '906jiaoye'
EMAIL_HOST_USER = 'deliverer@admin.bytedance.com'
EMAIL_HOST_PORT = 25
#EMAIL_HOST = '192.168.20.38'
EMAIL_HOST = '10.4.16.240'
DEFAULT_FROM_EMAIL = 'deliverer@admin.bytedance.com'

def config_send_mail(conf):
    if hasattr(conf, 'email_host_password'):
        EMAIL_HOST_PASSWORD = conf.email_host_password
    if hasattr(conf, 'email_host_user'):
        EMAIL_HOST_USER = conf.email_host_user
    if hasattr(conf, 'email_host'):
        EMAIL_HOST = conf.email_host
    if hasattr(conf, 'email_host_port'):
        EMAIL_HOST_PORT = conf.email_host_port
    if hasattr(conf, 'default_from_email'):
        DEFAULT_FROM_EMAIL = conf.default_from_email

def send_report_mail(subject, message, recipient_list, from_email=None, from_name=None, fail_silently=False, attachments=[], subtype='plain', charset='utf8', cc_recipient_list=None, bcc_recipient_list=None, mail_user_name=None, mail_user_passwd=None):
    return send_mail(subject, message, recipient_list, 'report@bytedance.com', from_name, fail_silently, attachments, subtype, charset, cc_recipient_list, bcc_recipient_list, mail_user_name='report@bytedance.com', mail_user_passwd='A5yhuKftWvJmQ')


def send_mail(subject, message, recipient_list,from_email=None, from_name=None, fail_silently=False, attachments=[], subtype='plain', charset='utf8', cc_recipient_list=None, bcc_recipient_list=None, mail_user_name=None, mail_user_passwd=None):
    try:
        if isinstance(subject, unicode):
            subject = subject.encode('utf8')
        if isinstance(message, unicode):
            message = message.encode('utf8')
        if isinstance(from_name, unicode):
            from_name = from_name.encode('utf8')
        if not isinstance(recipient_list, list):
            recipient_list = [recipient_list, ]

        if cc_recipient_list and not isinstance(cc_recipient_list, list):
            cc_recipient_list = [cc_recipient_list, ]

        if bcc_recipient_list and not isinstance(bcc_recipient_list, list):
            bcc_recipient_list = [bcc_recipient_list, ]

        from_email = from_email or DEFAULT_FROM_EMAIL
        if from_name:
            from_email = '"%s" <%s>' % (from_name, from_email)
        outer = MIMEMultipart()
        outer['Subject'] = '%s' % Header(subject, 'utf-8')
        outer['To'] = COMMASPACE.join(recipient_list)
        if cc_recipient_list:
            outer['Cc'] = COMMASPACE.join(cc_recipient_list)
            recipient_list.extend(cc_recipient_list)
        if bcc_recipient_list:
            outer['Bcc'] = COMMASPACE.join(bcc_recipient_list)
            recipient_list.extend(bcc_recipient_list)

        outer['From'] = from_email
        outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

        msg = MIMEText(message, _subtype=subtype, _charset=charset)
        outer.attach(msg)

        for path in attachments:
            if not os.path.isfile(path):
                continue
            # Guess the content type based on the file's extension.  Encoding
            # will be ignored, although we should check for simple things like
            # gzip'd or compressed files.
            ctype, encoding = mimetypes.guess_type(path)
            if ctype is None or encoding is not None:
                # No guess could be made, or the file is encoded (compressed), so
                # use a generic bag-of-bits type.
                ctype = 'application/octet-stream'
            maintype, subtype = ctype.split('/', 1)
            if maintype == 'text':
                fp = open(path)
                # Note: we should handle calculating the charset
                msg = MIMEText(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'image':
                fp = open(path, 'rb')
                msg = MIMEImage(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'audio':
                fp = open(path, 'rb')
                msg = MIMEAudio(fp.read(), _subtype=subtype)
                fp.close()
            else:
                fp = open(path, 'rb')
                msg = MIMEBase(maintype, subtype)
                msg.set_payload(fp.read())
                fp.close()
                # Encode the payload using Base64
                encoders.encode_base64(msg)
            filename = os.path.split(path)[1]
            # Set the filename parameter
            msg.add_header('Content-Disposition', 'attachment', filename=filename)
            msg.add_header('Content-ID', '<%s>' % filename)
            outer.attach(msg)
        # Now send or store the message
        composed = outer.as_string()
        s = __get_smtp__(mail_user_name, mail_user_passwd)
        s.sendmail(from_email, recipient_list, composed)
        s.quit()
        s.close()
        return True
    except:
        if not fail_silently:
            raise
        return False

def send_image_mail(subject, message, recipient_list, from_email=None,
        from_name=None, fail_silently=False, attachments=[], subtype='plain', charset='utf8'):
    if not attachments:
        return False
    try:
        if isinstance(subject, unicode):
            subject = subject.encode('utf8')
        if isinstance(message, unicode):
            message = message.encode('utf8')
        if isinstance(from_name, unicode):
            from_name = from_name.encode('utf8')
        if not isinstance(recipient_list, list):
            recipient_list = [recipient_list, ]
        from_email = from_email or DEFAULT_FROM_EMAIL
        if from_name:
            from_email = '%s <%s>' % (from_name, from_email)
        outer = MIMEMultipart()
        outer['Subject'] = subject
        outer['To'] = COMMASPACE.join(recipient_list)
        outer['From'] = from_email
        outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

        curr_image_id = 0
        for path in attachments:
            if not os.path.isfile(path):
                continue
            msg_alternative = MIMEMultipart('alternative')
            outer.attach(msg_alternative)

            msg_txt = MIMEText('image: %s' % path, _subtype=subtype, _charset=charset)
            msg_alternative.attach(msg_txt)

            msg_txt = MIMEText('<img src="cid:image%s"><br>' % curr_image_id, 'html', _charset=charset)
            msg_alternative.attach(msg_txt)
            curr_image_id += 1

        curr_image_id = 0
        for path in attachments:
            if not os.path.isfile(path):
                continue
            # Guess the content type based on the file's extension.  Encoding
            # will be ignored, although we should check for simple things like
            # gzip'd or compressed files.
            ctype, encoding = mimetypes.guess_type(path)
            if ctype is None or encoding is not None:
                # No guess could be made, or the file is encoded (compressed), so
                # use a generic bag-of-bits type.
                ctype = 'application/octet-stream'
            maintype, subtype = ctype.split('/', 1)
            if maintype == 'text':
                fp = open(path)
                # Note: we should handle calculating the charset
                msg = MIMEText(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'image':
                fp = open(path, 'rb')
                msg = MIMEImage(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'audio':
                fp = open(path, 'rb')
                msg = MIMEAudio(fp.read(), _subtype=subtype)
                fp.close()
            else:
                fp = open(path, 'rb')
                msg = MIMEBase(maintype, subtype)
                msg.set_payload(fp.read())
                fp.close()
                # Encode the payload using Base64
                encoders.encode_base64(msg)
            filename = os.path.split(path)[1]
            # Set the filename parameter
            msg.add_header('Content-ID', '<image%d>' % curr_image_id)
            outer.attach(msg)
            curr_image_id += 1
        # Now send or store the message
        composed = outer.as_string()
        s = __get_smtp__()
        s.sendmail(from_email, recipient_list, composed)
        s.quit()
        s.close()
        return True
    except:
        if not fail_silently:
            raise
        return False

def __get_smtp__(email_host_user=None, email_host_password=None):
    smtp = smtplib.SMTP(EMAIL_HOST, EMAIL_HOST_PORT)
    if email_host_user and email_host_password:
        smtp.login(email_host_user, email_host_password)
    else:
        smtp.login(EMAIL_HOST_USER, EMAIL_HOST_PASSWORD)
    return smtp

from pyutil.alarm.alarm_handler import AlarmHandler
class MailHandler(AlarmHandler):
    pass # FOR COMPAT ONLY, please use AlarmHandler.

# -*- coding: utf-8 -*-

import logging

from pyutil.springdb import SpringDBClient
from pyutil.memcache import MemcacheClient
from pyutil.program.lru import ExpiringLRUCache
import redis

class SpringMemcacheClient(object):
    '''
    设计目的：
      1. 支持简单场景里高频度访问数据的持久化
      2. 支持以往把memcache当作持久化存储使用的场景迁移

    组合三层存储，方便使用
      db: springdb
      mc: memcache, 可以disable
      lc: local cache by ExpiringLRUCache, 为进一步降低mc的压力, 可以disable

    数据一致性：
      这个组合的数据一致性弱，即，可能存在mc和springdb里的数据不一致
      对数据有比较强一致性要求，或者对超时时间有额外要求的，不要使用本客户端，直接使用mc或springdb

    Example: (pyutil/memcache/tests/example.py)
      #memcache和springdb需要找维护者确认集群或表名，请不要擅自复用已有的集群或表

      from pyutil.program.conf2 import Conf
      conf = Conf('/opt/tiger/ss_conf/ss/memcache.conf')

      from pyutil.memcache import SpringMemcacheClient
      # 依次传入SpringDBClient、MemcacheClient的参数
      # 更多的参数请见构造函数：local cache的参数、disable_mc、disable_lc
      c = SpringMemcacheClient({'cluster': 'springdb_sandbox', 'table': 'sandbox'},
                               {'memcache_servers': conf.get_values('memcache_11211')})

      # SpringMemcacheClient的接口和MemcacheClient的类似，暂时不支持key_tmpl
      result = c.set('a', 'aaa', 60)
      if result != True:
          print 'set failed'
      else:
          print 'set ok'

      result = c.get('a')
      if result == None:
          print 'get failed or not found'
      else:
          print 'get result:', result

      result = c.mset({'a': 1, 'b': 2}, 60)
      if result != []:
          print 'mset failed. failed keys: %s' % result
      else:
          print 'mset ok'

      result = c.mget(['a', 'b'])
      print 'mget result:', result

    过期时间：
      local cache永远使用默认的过期时间(而不是不过期)，是为了避免本地的数据不更新
      set/mset传入的过期时间仅仅会对mc和springdb起作用

      回填mc和lc均分别使用对应的默认过期时间。
      发生在：当mc或lc中not found，而springdb中可以读取到时，会回填到mc和lc里。

      强烈建议设置过期时间。可以设置一个比较大的值，比如14天，这样springdb里旧
      数据的空间可以及时被回收

      timeout为0表示不过期，详见set函数

    注意：
      NOT THREAD-SAFE (受MemcacheClient影响)
      使用方式和返回值向MemcacheClient靠齐，因此连接类失败不会抛出异常
      目前不支持key的tmpl
      目前ExpiringLRUCache为对象级作用域，待改进
    '''

    def __init__(self, db_args, mc_args=None, lc_args=None,
                 disable_mc=False, disable_lc=False):
        if not mc_args:
            disable_mc = True
        if not lc_args:
            disable_lc = True
        if disable_mc and disable_lc:
            raise ValueError('SpringMemcacheClient should specify lc or mc args')
        self.db = SpringDBClient(**db_args)
        self.mc = MemcacheClient(**mc_args) if not disable_mc else None
        self.lc = ExpiringLRUCache(**lc_args) if not disable_lc else None

    def set(self, key, value, timeout=None):
        '''
        @param timeout 过期时间
               set函数传入的过期时间仅仅对mc和springdb起作用。
               如果为None，mc会使用默认配置，springdb则设置为不过期
               如果timeout为0, 表示不过期，详见函数内的注释
               
        @return 以springdb更新的结果为准，1为成功，0为失败
                如果memcache set失败，会忽略错误，有遗留脏数据的风险
        '''

        if self.lc:
            self.lc.put(key, value, None)

        if self.mc:
            self.mc.set(key, value, timeout)

        # memcache和springdb/redis对timeout为0的行为不同，
        # memcache视0为不过期，springdb/redis视0为立即过期
        # 这里的策略向memcache看齐，并且设置一个立即过期是极少数的行为
        # 因此，如果为0，操作springdb时设置为不过期
        try:
            if timeout == 0 or timeout is None:
                result = self.db.set(key, value)
            else:
                result = self.db.setex(key, value, timeout)
        except Exception, ex:
            logging.exception('SpringMemcacheClient: set into springdb failed')
            return 0
        return 1

    def mset(self, mapping, timeout=None):
        '''
        @param timeout 同set函数

        @return 同MemcacheClient，返回未设置成功的key列表
        '''

        if self.lc:
            for key, value in mapping.items():
                self.lc.put(key, value, None)

        if self.mc:
            self.mc.mset(mapping, timeout)

        # TODO: SpringDBClient暂时不支持mset，这里使用set代替
        final = [] # keys failed to be stored
        saved_exception = None
        for key, value in mapping.items():
            try:
                if timeout == 0 or timeout is None:
                    result = self.db.set(key, value)
                else:
                    result = self.db.setex(key, value, timeout)
            except Exception, ex:
                final.append(key)
                saved_exception = ex
        if final:
            logging.warning('SpringMemcacheClient: mset into springdb failed '
                            '%d keys out of %d keys. error: %s', len(final),
                            len(mapping), str(saved_exception))
        return final

    def get(self, key):
        if self.lc:
            result = self.lc.get(key)
            #print 'lc result %r' % result
            if result is not None:
                return result
        if self.mc:
            result = self.mc.get(key)
            #print 'mc result %r' % result
            if result is not None:
                self.fill_back(key, result, only_lc=True)
                return result
        try:
            result = self.db.get(key)
            self.fill_back(key, result)
            #print 'db result %r' % result
            return result
        except Exception, ex:
            logging.exception('SpringMemcacheClient: get from springdb failed')
            return None

    def mget(self, keys, fill_back_num=1):
        '''
        @param fill_back_num fill back all missing keys may take a long time,
                             so we only fill back limited number
        '''
        final = {}
        keys_left = keys

        if self.lc and len(keys_left) > 0:
            keys_not_found = []
            for key in keys_left:
                result = self.lc.get(key)
                if result is not None:
                    final[key] = result
                else:
                    keys_not_found.append(key)
            keys_left = keys_not_found

        if self.mc and len(keys_left) > 0:
            keys_not_found = []
            result = self.mc.mget(keys_left)
            for key in keys_left:
                if key in result:
                    final[key] = result[key]
                else:
                    keys_not_found.append(key)
            keys_left = keys_not_found

            # fill back all keys may take a long time, we only fill back some
            if result:
                fill_back_count = 0
                for key, value in result.items():
                    self.fill_back(key, value)
                    fill_back_count += 1
                    if fill_back_count >= fill_back_num:
                        break

        if len(keys_left) > 0:
            try:
                result = self.db.mget(keys_left)
                if isinstance(result, list) and len(result) == len(keys_left):
                    fill_back_count = 0
                    for i in xrange(len(result)):
                        key = keys_left[i]
                        value = result[i]
                        if (value is not None
                            and not isinstance(value, redis.RedisError)):
                            final[key] = value

                            # fill back all keys may take a long time, we only
                            # fill back some
                            if fill_back_count < fill_back_num:
                                self.fill_back(key, value)
                                fill_back_count += 1
                else:
                    logging.error('SpringMemcacheClient: unexpected mget result'
                                  ' type from springdb')
            except Exception, ex:
                logging.exception('SpringMemcacheClient: mget from springdb failed')

        return final

    def fill_back(self, key, value, only_lc=False):
        if value == None:
            return

        ''' 使用默认的过期时间 '''
        if self.lc:
            self.lc.put(key, value, None)
        if self.mc and not only_lc:
            self.mc.set(key, value)

if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s %(levelname)s %(message)s')
    logging.getLogger().setLevel(logging.DEBUG)

    c = SpringMemcacheClient({'cluster': 'springdb_sandbox', 'table': 'sandbox'},
                             {'memcache_servers': ['192.168.20.41:11211']})


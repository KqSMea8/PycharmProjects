# -*- coding: utf-8 -*-
from pyutil.program.conf2 import Conf
from client import MemcacheClient


class MdcMemcacheClient(object):
    def __init__(self, mc_name, key_tmpl=None, timeout=900, client=None, cpp_server_hash=True, hash_ring=False, prefix=None, use_proxy=False, socket_timeout=0.25, stats_interval=None, failure_limit=10, **kwargs):
        from pyutil.program.conf2 import Conf
        conf = Conf('/opt/tiger/ss_conf/ss/memcache.conf')
        self.lconf = conf.get(mc_name)
        self.lconf = [x.strip() for x in self.lconf.split()]
        self.lconf_name = None
        self.mc_conf_map = MemcacheClient.get_servers(mc_name)
        for k, v in self.mc_conf_map.items():
            if v == self.lconf:
                #TODO Be sure the lconf_name must not be None
                self.lconf_name = k
        self.mc_map = {}
        for k,v in self.mc_conf_map.items():
            self.mc_map[k] = MemcacheClient(v, key_tmpl, timeout, client, cpp_server_hash, hash_ring, prefix, use_proxy, socket_timeout, stats_interval, failure_limit, **kwargs)

    def set(self, key, val, timeout=None, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.set(key, val, timeout, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s set failure!"%(except_list, self.__class__.__name__))
        return ret

    def get(self, key):
        return self.mc_map[self.lconf_name].get(key)

    def add(self, key, val, timeout=None, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.add(key, val, timeout, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s add failure!"%(except_list, self.__class__.__name__))
        return ret

    def append(self, key, val, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.append(key, val, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s append failure!"%(except_list, self.__class__.__name__))
        return ret

    def delete(self, key, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.delete(key, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s delete failure!"%(except_list, self.__class__.__name__))
        return ret

    def mset(self, mapping, timeout=None, key_tmpl=None, split_num=1024):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                result = mc.mset(mapping, timeout, key_tmpl, split_num)
                ret = len(result) == 0
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s mset failure!"%(except_list, self.__class__.__name__))
        return ret

    def set_multi(self, mapping, timeout=None, key_tmpl=None, split_num=1024):
        return self.mset(mapping, timeout, key_tmpl, split_num)

    def get_multi(self, keys, key_tmpl=None, split_num=1024):
        return self.mget(keys, key_tmpl, split_num)

    def mget(self, keys, key_tmpl=None, split_num=1024):
        return self.mc_map[self.lconf_name].mget(keys, key_tmpl, split_num)

    def replace(self, key, val, timeout=0, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.replace(key, val, timeout, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s replace failure!"%(except_list, self.__class__.__name__))
        return ret

    def prepend(self, key, val, timeout=0, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.prepend(key, val, timeout, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s prepend failure!"%(except_list, self.__class__.__name__))
        return ret

    def cas(self, key, val, timeout=0, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.cas(key, val, timeout, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s cas failure!"% (except_list, self.__class__.__name__))
        return ret

    def reset_cas(self):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.reset_cas()
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s reset_cas failure!"% (except_list, self.__class__.__name__))
        return ret

    def gets(self, key, key_tmpl=None):
        self.mc_map[self.lconf_name].gets(key, key_tmpl)

    def incr(self, key, delta=1, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.incr(key, delta, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s incr failure!"%(except_list, self.__class__.__name__))
        return ret

    def decr(self, key, delta=1, key_tmpl=None):
        ret = False
        except_list = []
        for name, mc in self.mc_map.iteritems():
            try:
                ret = mc.decr(key, delta, key_tmpl)
            except:
                except_list.append(name)
        if except_list:
            raise Exception("%s %s decr failure!"%(except_list, self.__class__.__name__))
        return ret


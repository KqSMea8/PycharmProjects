#!/usr/bin/env python
# -*- coding: utf-8 -*-
import unittest
import time, string, random, logging
from pyutil.memcache import MemcacheClient, MemcacheClientPair
#from pyutil.memcache.extensions import MemcacheClient, MemcacheClientPair
from pyutil.memcache import SpringMemcacheClient

# all following server is twemporxy, use twemproxy's config to control timeout or error
NORMAL_SERVER_LIST = ['127.0.0.1:5096', '127.0.0.1:5096', '127.0.0.1:5096', '127.0.0.1:5096'] 
ALL_TIMEOUT_SERVER_LIST = ['127.0.0.1:5097', '127.0.0.1:5097', '127.0.0.1:5097', '127.0.0.1:5097'] 
ONE_TIMEOUT_SERVER_LIST = ['127.0.0.1:5097', '127.0.0.1:5096', '127.0.0.1:5096', '127.0.0.1:5096'] 
ERROR_SERVER_LIST = ['127.0.0.1:5098', '127.0.0.1:5098', '127.0.0.1:5098', '127.0.0.1:5098'] 
ALL_CONNECT_TIMEOUT_SERVER_LIST = ['192.168.100.100:11211', '192.168.100.101:11211', '192.168.100.102:11211', '192.168.100.103:11211'] 
USE_SALT = 1
SOCKET_TIMEOUT = 0.25
EXPTIME = 600

# for combo client
SPRINGDB_CLUSTER = 'springdb_sandbox'
SPRINGDB_TABLE = 'sandbox'

import memcache
CONNECT_TIMEOUT = memcache._CONNECT_TIMEOUT
GET_SERVER_RETRY = memcache.Client._SERVER_RETRIES

def rand_str(n=10, prefix=''):
    #return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(n))
    if prefix:
        prefix = str(prefix) + '_'
    return str(prefix) + ''.join(random.choice(string.ascii_uppercase) for _ in xrange(n))

seq_i = 0
def gen_seq():
    global seq_i
    seq_i += 1
    return seq_i

def gen_kv_pair(num=16, rand=True):
    if rand:
        return {rand_str(16, i) : rand_str(64, i) for i in xrange(0, num)}
    else:
        return {str(i) : str(i) for i in xrange(0, num)}

class TestBasic(unittest.TestCase):
    def setUp(self):
        if USE_SALT:
            self.salt = 'pyutil_memcache_unittest_%d' % gen_seq() # 防止受上次运行结果的影响
        else:
            self.salt = 'pyutil_memcache_unittest'
        self.mc_list = {
            'mc_no_key_tmpl': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, socket_timeout=SOCKET_TIMEOUT), # no salt
            'mc': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=SOCKET_TIMEOUT),
            'mc_hash_ring': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', hash_ring=True, socket_timeout=SOCKET_TIMEOUT),
            'mc_with_prefix': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl='mc_with_prefix_%s', prefix=self.salt, socket_timeout=SOCKET_TIMEOUT),
            'mc_use_proxy': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', use_proxy=True, socket_timeout=SOCKET_TIMEOUT),
            'mc_use_proxy_with_prefix': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl='mc_with_prefix_%s', prefix=self.salt, use_proxy=True, socket_timeout=SOCKET_TIMEOUT)}

    def test_setget(self):
        k = rand_str(16)
        v = rand_str(64)

        for name, mc in self.mc_list.items():
            self.assertTrue(mc.set(k, v), name)
            self.assertEqual(mc.get(k), v, name)

    def test_setget_random_hitrate(self):

        for name, mc in self.mc_list.items():
            for i in range(32):
                k = rand_str(16)
                v = rand_str(64)
                miss = True
                if (random.randrange(2) < 1):
                    miss = False
                    self.assertTrue(mc.set(k, v), name)

                if miss:
                    self.assertEqual(mc.get(k), None, name)
                else:
                    self.assertEqual(mc.get(k), v, name)

    def test_msetmget(self):
        kv_pair = gen_kv_pair(64)

        for name, mc in self.mc_list.items():
            self.assertEqual(mc.mset(kv_pair), [], name)
            #print mc.mget(kv_pair.keys())
            self.assertEqual(mc.mget(kv_pair.keys()), kv_pair, name)

    def test_msetmget_random_hitrate(self):
        kv_pair = gen_kv_pair(16)
        keys = kv_pair.keys()
        # random remove some elements
        kv_pair = {k : v for k,v in kv_pair.items() if random.randrange(2) < 1}

        for name, mc in self.mc_list.items():
            self.assertEqual(mc.mset(kv_pair), [], name)
            #print mc.mget(kv_pair.keys())
            self.assertEqual(mc.mget(keys), kv_pair, name)

    def test_delete(self):
        k = rand_str(16)
        v = rand_str(64)

        for name, mc in self.mc_list.items():
            self.assertTrue(mc.set(k, v), name)
            self.assertEqual(mc.get(k), v, name)
            self.assertTrue(mc.delete(k), name)
            self.assertEqual(mc.get(k), None, name)

    def test_tmpl(self):
        k = rand_str(16)
        v = rand_str(64)

        self.assertTrue(self.mc_list['mc'].set(k, v))
        self.assertEqual(self.mc_list['mc'].get(k), v)

        self.assertEqual(self.mc_list['mc_no_key_tmpl'].get(self.salt + '_mc_%s' % k), v)

    def test_prefix(self):
        k = rand_str(16)
        v = rand_str(64)

        self.assertTrue(self.mc_list['mc_with_prefix'].set(k, v))
        self.assertEqual(self.mc_list['mc_with_prefix'].get(k), v)

        self.assertEqual(self.mc_list['mc_no_key_tmpl'].get('[%s]mc_with_prefix_%s' % (self.salt, k)), v)

    def test_reuse_client(self):
        saved_config = MemcacheClient._enable_reuse_client
        MemcacheClient._enable_reuse_client = True

        #if not MemcacheClient._enable_reuse_client:
            #print 'enable_reuse_client is false. skip test_reuse_client'
            #return

        MemcacheClient.clear_saved_client()

        server_list1 = ['127.0.0.1:9901', '127.0.0.1:9902']
        server_list2 = ['127.0.0.1:9902', '127.0.0.1:9901']
        #server_list3 = ['127.0.0.1:9901', '127.0.0.1:9902', '127.0.0.1:9903', '127.0.0.1:9904']

        case_list = [[{'memcache_servers':server_list1}, False],
                     [{'memcache_servers':server_list1}, True], #create it again
                     [{'memcache_servers':server_list2}, False],
                     [{'memcache_servers':server_list1, 'use_proxy':True}, False],
                     [{'memcache_servers':server_list1, 'hash_ring':True}, False],
                     [{'memcache_servers':server_list1, 'socket_timeout':10}, False],
                     [{'memcache_servers':server_list1, 'key_tmpl':'prefix_%s'}, True],
                     [{'memcache_servers':server_list1, 'prefix':'prefix'}, True]]

        for case in case_list:
            argument = case[0]
            result = case[1]
            mc = MemcacheClient(**argument)
            self.assertEqual(mc.reuse_client, result)

        MemcacheClient._enable_reuse_client = saved_config

    #def test_with_sys_conf(self):
        #from pyutil.program.sys_conf import SysConf
        #sys_conf = SysConf('./ss_conf')
        ##sys_conf = SysConf('/opt/tiger/ss_conf/ss')
        #print sys_conf.memcache1

    def test_detect_cluster(self):
        #print 'You may need to verify the server_list in unittest if memcache.conf changed'
        server_list = ['10.4.18.65:11411', '10.4.18.66:11411', '10.4.18.67:11411', '10.4.18.68:11411']
        mc = MemcacheClient(server_list)
        self.assertEqual(mc.cluster, 'memcache_recommend_preset')


class TestExtra(unittest.TestCase):
    '''some time consuming cases'''

    def setUp(self):
        if USE_SALT:
            self.salt = 'pyutil_memcache_unittest_%d' % gen_seq() # 防止受上次运行结果的影响
        else:
            self.salt = 'pyutil_memcache_unittest'
        self.mc_list = {
            'mc_no_key_tmpl': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, socket_timeout=SOCKET_TIMEOUT), # no salt
            'mc': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=SOCKET_TIMEOUT),
            'mc_hash_ring': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', hash_ring=True, socket_timeout=SOCKET_TIMEOUT),
            'mc_with_prefix': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl='mc_with_prefix_%s', prefix=self.salt, socket_timeout=SOCKET_TIMEOUT),
            'mc_use_proxy': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', use_proxy=True, socket_timeout=SOCKET_TIMEOUT),
            'mc_use_proxy_with_prefix': MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl='mc_with_prefix_%s', prefix=self.salt, use_proxy=True, socket_timeout=SOCKET_TIMEOUT)}

    def test_mset_non_split(self):
        return # skip

        #num = 1234567 # will trigger a lot of error
        num = 123456
        kv_pair = gen_kv_pair(num, False)

        for name, mc in self.mc_list.items():
            if name != 'mc_hash_ring' and name != 'mc_use_proxy':
                continue # skip others
            print 'TestBasic.test_mset_non_split. %s. very large mset(%d), please wait...' % (name, num)
            self.assertEqual(mc.mset(kv_pair, split_num=9999999999999999), [], name)
            self.assertEqual(mc.mget(kv_pair.keys(), split_num=9999999999999999), kv_pair, name)

    def test_mset_split(self):
        #num = 1234567 # will trigger a lot of error
        num = 12345
        print 'TestBasic.test_mset_split. very large mset(%d), please wait...' % (num)
        kv_pair = gen_kv_pair(num, False)

        for name, mc in self.mc_list.items():
            if name != 'mc_hash_ring' and name != 'mc_use_proxy':
                continue # skip others
            self.assertEqual(mc.mset(kv_pair), [], name)
            self.assertEqual(mc.mget(kv_pair.keys()), kv_pair, name)

class TestException(unittest.TestCase):
    def setUp(self):
        if USE_SALT:
            self.salt = 'pyutil_memcache_unittest_%d' % gen_seq() # 防止受上次运行结果的影响
        else:
            self.salt = 'pyutil_memcache_unittest'

        print
        print 'TestException. maybe some ERROR logs'
        MemcacheClient.clear_saved_client()

    def expectCostGreater(self, actual, expected):
        if actual > expected:
            return
        print 'actual cost is less than we expected. you can ignore this. actual: %.4f, expected: %.4f' % (actual, expected)

    def test_simple_read_timeout(self):
        return
        socket_timeout = CONNECT_TIMEOUT * 2
        # 当前的模拟方式还会触发connect过程的no route to host，该过程的超时为3s
        # 因此，即使socket_timeout设置为大于3s的时间，也会在3s的时候超时
        mc = MemcacheClient(['192.168.100.100:55555'], socket_timeout=socket_timeout)
        ts = time.time()
        self.assertEqual(mc.set('a', 'a'), 0)
        te = time.time()
        self.expectCostGreater(te - ts, CONNECT_TIMEOUT)
        self.assertLess(te - ts, socket_timeout)

    def test_mset_timeout_result(self):
        '''fixed the bug in memcache.py'''

        kv_pair = gen_kv_pair(16)

        mc = MemcacheClient(ALL_TIMEOUT_SERVER_LIST, timeout=EXPTIME, socket_timeout=SOCKET_TIMEOUT)
        self.assertGreater(len(mc.mset(kv_pair)), 0)

    def test_all_connect_timeout(self):
        '''connect should not accumulate timeout'''
        socket_timeout = 0.2
        num = 32
        server_list = ALL_CONNECT_TIMEOUT_SERVER_LIST

        # we try to caculate the expected_cost
        failure_limit = 5
        min_expected_cost = CONNECT_TIMEOUT * min(GET_SERVER_RETRY * num, failure_limit) # if all hit the one server
        max_expected_cost = CONNECT_TIMEOUT * min(GET_SERVER_RETRY * num, failure_limit * len(server_list))

        kv_pair = gen_kv_pair(num)

        mc = MemcacheClient(server_list, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout, failure_limit=failure_limit)

        # mget
        ts = time.time()
        self.assertEqual(mc.mget(kv_pair.keys()), {})
        te = time.time()
        print 'expected timeout: [%.4f,%.4f], actual: %.4f' % (min_expected_cost, max_expected_cost, te - ts)
        self.expectCostGreater(te - ts, min_expected_cost)
        self.assertLess(te - ts, max_expected_cost * 1.1)

    def test_all_read_timeout(self):
        '''mget should not accumulate timeout'''
        socket_timeout = 0.2 # remember the timeout*len(server_list) MUST be less than timeout between twemproxy and memcached

        kv_pair = gen_kv_pair(32)

        # only one server
        mc = MemcacheClient(ALL_TIMEOUT_SERVER_LIST[:1], timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout, failure_limit=30)

        ts = time.time()
        self.assertEqual(mc.mget(kv_pair.keys()), {})
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

        # assume more than one server
        if len(ALL_TIMEOUT_SERVER_LIST) < 2:
            print 'ALL_TIMEOUT_SERVER_LIST is less than we need, skip TestClientPair.test_all_read_timeout'

        mc = MemcacheClient(ALL_TIMEOUT_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout)

        # mget
        ts = time.time()
        self.assertEqual(mc.mget(kv_pair.keys()), {})
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

        # mget again, to verify set the timeout back
        ts = time.time()
        self.assertEqual(mc.mget(kv_pair.keys()), {})
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

        # mset
        ts = time.time()
        self.assertGreater(len(mc.mset(kv_pair)), 0)
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

        # mset again
        ts = time.time()
        self.assertGreater(len(mc.mset(kv_pair)), 0)
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

    def test_one_read_timeout(self):
        socket_timeout = 0.2

        kv_pair = gen_kv_pair(32)

        # set the keys first
        mc = MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout)
        self.assertEqual(mc.mset(kv_pair), [])

        # get and we expect not all failed
        mc = MemcacheClient(ONE_TIMEOUT_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout)

        # mget
        print 'mget'
        ts = time.time()
        result = mc.mget(kv_pair.keys())
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)
        self.assertGreater(len(result), 0)
        self.assertLess(len(result), len(kv_pair))

        # mget again
        print 'mget again'
        ts = time.time()
        result = mc.mget(kv_pair.keys())
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)
        self.assertGreater(len(result), 0)
        self.assertLess(len(result), len(kv_pair))

        # mset
        print 'mset'
        ts = time.time()
        self.assertGreater(len(mc.mset(kv_pair)), 0)
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

        # mset again
        print 'mset again'
        ts = time.time()
        self.assertGreater(len(mc.mset(kv_pair)), 0)
        te = time.time()
        self.expectCostGreater(te - ts, socket_timeout)
        self.assertLess(te - ts, socket_timeout * 1.1)

    def test_all_read_error(self):
        '''all api should return error immediately'''
        socket_timeout = 1
        mc = MemcacheClient(ERROR_SERVER_LIST, timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', socket_timeout=socket_timeout)

        ts = time.time()
        self.assertEqual(mc.set('a', 'a'), 0)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(mc.add('a', 'a'), 0)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(mc.append('a', 'a'), 0)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(mc.get('a'), None)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(mc.delete('a'), 0)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(mc.mget(['a', 'b']), {})
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

        ts = time.time()
        self.assertEqual(len(mc.mset({'a':'a', 'b':'b'})), 2)
        te = time.time()
        self.assertLess(te - ts, socket_timeout)

class TestProxy(unittest.TestCase):
    def setUp(self):
        MemcacheClient.clear_saved_client()

    def test_use_same_server(self):
        mc = MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, use_proxy=True)

        self.assertEqual(mc.client.last_server, None)

        self.assertEqual(mc.set('a', 'a'), True)
        last_server = mc.client.last_server

        # no matter which key, it should use the last connection
        for i in range(32):
            self.assertEqual(mc.set(str(i), str(i)), True)
            self.assertEqual(mc.client.last_server, last_server)

    def test_detect_use_proxy(self):
        from pyutil.program.conf2 import Conf
        conf = Conf('/opt/tiger/ss_conf/ss/memcache.conf')

        # cluster without proxy
        mc_servers = conf.get_values('memcache_11211')
        mc = MemcacheClient(mc_servers)
        self.assertEqual(mc.use_proxy, False)
        keys = ['test_%s' % i for i in range(100)]
        mc.mget(keys)

        # cluster with proxy
        mc_servers = conf.get_values('memcache_recommend_offline')
        mc = MemcacheClient(mc_servers)
        self.assertEqual(mc.use_proxy, True)
        keys = ['test_%s' % i for i in range(100)]
        mc.mget(keys)

class TestProxyException(unittest.TestCase):
    def setUp(self):
        if USE_SALT:
            self.salt = 'pyutil_memcache_unittest_%d' % gen_seq() # 防止受上次运行结果的影响
        else:
            self.salt = 'pyutil_memcache_unittest'

        print
        print 'TestProxyException. maybe some ERROR logs'
        MemcacheClient.clear_saved_client()

    def tearDown(self):
        MemcacheClient.clear_saved_client()

    def test_failover(self):
        if len(NORMAL_SERVER_LIST) < 2:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_mset'
            return

        mc = MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, use_proxy=True, failure_limit=1)

        self.assertEqual(mc.client.last_server, None)

        self.assertEqual(mc.set('a', 'a'), True)
        server1 = mc.client.last_server
        server1.mark_dead('MARK IT DEAD ON PURPOSE')

        # will retry another a server
        self.assertEqual(mc.set('a', 'a'), True)
        server2 = mc.client.last_server
        self.assertNotEqual(server1, server2)

    def test_all_dead(self):
        mc = MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, use_proxy=True)

        self.assertEqual(mc.client.last_server, None)

        for i in range(128):
            mc.set(str(i), str(i))
            if mc.client.last_server:
                mc.client.last_server.mark_dead('MARK IT DEAD ON PURPOSE')

    def test_failure_limit(self):
        failure_limit = 10
        mc = MemcacheClient(NORMAL_SERVER_LIST[:1], timeout=EXPTIME, key_tmpl=self.salt + '_mc_%s', use_proxy=True, socket_timeout=SOCKET_TIMEOUT, failure_limit=failure_limit)

        self.assertEqual(mc.set('a', 'a'), True)
        for i in range(failure_limit - 1):
            mc.client.last_server.mark_dead('MARK IT DEAD ON PURPOSE')
        self.assertEqual(mc.set('a', 'a'), True)

        for i in range(failure_limit):
            mc.client.last_server.mark_dead('MARK IT DEAD ON PURPOSE')
        self.assertEqual(mc.set('a', 'a'), 0)

class TestClientPair(unittest.TestCase):
    def setUp(self):
        if USE_SALT:
            self.salt = 'pyutil_memcache_unittest_%d' % gen_seq() # 防止受上次运行结果的影响
        else:
            self.salt = 'pyutil_memcache_unittest'

    def test_set(self):
        if len(NORMAL_SERVER_LIST) < 4:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_set'
            return

        server_list1 = NORMAL_SERVER_LIST[0:1]
        server_list2 = NORMAL_SERVER_LIST[1:2]
        server_list3 = NORMAL_SERVER_LIST[2:3]
        mc1 = MemcacheClient(server_list1, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(server_list2, timeout=EXPTIME, prefix=self.salt)
        mc3 = MemcacheClient(server_list3, timeout=EXPTIME, prefix=self.salt)

        mc_pair = MemcacheClientPair([mc1, mc2, mc3])

        k = rand_str(16)
        v = rand_str(64)

        self.assertEqual(mc_pair.set(k, v), True, 'mc_pair set failed')

        self.assertEqual(mc1.get(k), v, 'mc1 get failed')
        self.assertEqual(mc2.get(k), v, 'mc2 get failed')
        self.assertEqual(mc3.get(k), v, 'mc3 get failed')

    def test_get(self):
        if len(NORMAL_SERVER_LIST) < 4:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_set'
            return

        server_list1 = NORMAL_SERVER_LIST[0:1]
        server_list2 = NORMAL_SERVER_LIST[1:2]
        server_list3 = NORMAL_SERVER_LIST[2:3]
        mc1 = MemcacheClient(server_list1, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(server_list2, timeout=EXPTIME, prefix=self.salt)
        mc3 = MemcacheClient(server_list3, timeout=EXPTIME, prefix=self.salt)

        mc_pair = MemcacheClientPair([mc1, mc2, mc3])

        k = rand_str(16)
        v = rand_str(64)

        self.assertEqual(mc1.set(k, v), True, 'mc1 set failed')
        self.assertEqual(mc_pair.get(k), v, 'mc_pair get failed')

        v = rand_str(64)

        self.assertEqual(mc2.set(k, v), True, 'mc2 set failed')
        self.assertEqual(mc_pair.get(k), v, 'mc_pair get failed')

    def test_set_failed(self):
        mc1 = MemcacheClient(NORMAL_SERVER_LIST, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(ERROR_SERVER_LIST, timeout=EXPTIME, prefix=self.salt)
        mc_pair = MemcacheClientPair([mc1, mc2])

        k = rand_str(16)
        v = rand_str(64)

        self.assertEqual(mc_pair.set(k, v), 0, 'mc_pair set failed')

    def test_mset(self):
        if len(NORMAL_SERVER_LIST) < 4:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_mset'
            return

        kv_pair = gen_kv_pair(4096)

        server_list1 = NORMAL_SERVER_LIST[0:1]
        server_list2 = NORMAL_SERVER_LIST[1:2]
        server_list3 = NORMAL_SERVER_LIST[2:3]
        mc1 = MemcacheClient(server_list1, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(server_list2, timeout=EXPTIME, prefix=self.salt)
        mc3 = MemcacheClient(server_list3, timeout=EXPTIME, prefix=self.salt)

        mc_pair = MemcacheClientPair([mc1, mc2, mc3])

        self.assertEqual(mc_pair.mset(kv_pair), [], 'mc_pair mset failed')

        self.assertEqual(mc1.mget(kv_pair.keys()), kv_pair, 'mc1 mget failed')
        self.assertEqual(mc2.mget(kv_pair.keys()), kv_pair, 'mc2 mget failed')
        self.assertEqual(mc3.mget(kv_pair.keys()), kv_pair, 'mc3 mget failed')

    def test_mget1(self):
        if len(NORMAL_SERVER_LIST) < 4:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_mget'
            return

        num = 4096
        kv_pair1 = {i : 'value_%d' % i for i in range(0, num/8*3)}
        kv_pair2 = {i : 'value_%d' % i for i in range(num/8*2, num/8*6)}
        kv_pair3 = {i : 'value_%d' % i for i in range(num/8*5, num)}
        kv_pair = dict(kv_pair1.items() + kv_pair2.items() + kv_pair3.items())
        #print kv_pair1
        #print kv_pair2
        #print kv_pair3

        server_list1 = NORMAL_SERVER_LIST[0:1]
        server_list2 = NORMAL_SERVER_LIST[1:2]
        server_list3 = NORMAL_SERVER_LIST[2:3]
        mc1 = MemcacheClient(server_list1, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(server_list2, timeout=EXPTIME, prefix=self.salt)
        mc3 = MemcacheClient(server_list3, timeout=EXPTIME, prefix=self.salt)

        mc_pair = MemcacheClientPair([mc1, mc2, mc3])

        self.assertEqual(mc1.mset(kv_pair1), [], 'mc1 mset failed')
        self.assertEqual(mc2.mset(kv_pair2), [], 'mc2 mset failed')
        self.assertEqual(mc3.mset(kv_pair3), [], 'mc3 mset failed')

        self.assertEqual(mc_pair.mget(kv_pair.keys()), kv_pair, 'mc_pair mget failed')

    def test_mget2(self):
        if len(NORMAL_SERVER_LIST) < 4:
            print 'NORMAL_SERVER_LIST is less than we need, skip TestClientPair.test_mget2'
            return

        num = 64
        kv_pair1 = {i : 'value_%d' % i for i in range(0, num)}
        kv_pair2 = {i : 'value_%d' % i for i in range(0, num)}
        kv_pair3 = {i : 'value_%d' % i for i in range(0, num)}
        kv_pair = dict(kv_pair1.items() + kv_pair2.items() + kv_pair3.items())
        #print kv_pair1
        #print kv_pair2
        #print kv_pair3

        server_list1 = NORMAL_SERVER_LIST[0:1]
        server_list2 = NORMAL_SERVER_LIST[1:2]
        server_list3 = NORMAL_SERVER_LIST[2:3]
        mc1 = MemcacheClient(server_list1, timeout=EXPTIME, prefix=self.salt)
        mc2 = MemcacheClient(server_list2, timeout=EXPTIME, prefix=self.salt)
        mc3 = MemcacheClient(server_list3, timeout=EXPTIME, prefix=self.salt)

        mc_pair = MemcacheClientPair([mc1, mc2, mc3])

        self.assertEqual(mc1.mset(kv_pair1), [], 'mc1 mset failed')
        self.assertEqual(mc2.mset(kv_pair2), [], 'mc2 mset failed')
        self.assertEqual(mc3.mset(kv_pair3), [], 'mc3 mset failed')

        self.assertEqual(mc_pair.mget(kv_pair.keys()), kv_pair, 'mc_pair mget failed')

class TestClientCombo(unittest.TestCase):
    def setUp(self):
        db_args = {'cluster': SPRINGDB_CLUSTER, 'table': SPRINGDB_TABLE}
        mc_args = {'memcache_servers': NORMAL_SERVER_LIST}
        lc_args = {'size': 102400, 'default_timeout': 3600}
        self.combo = SpringMemcacheClient(db_args, mc_args, lc_args)

    def test_init(self):
        db_args = {'cluster': SPRINGDB_CLUSTER, 'table': SPRINGDB_TABLE}
        mc_args = {'memcache_servers': NORMAL_SERVER_LIST}
        lc_args = {'size': 102400, 'default_timeout': 3600}

        combo = SpringMemcacheClient(db_args, lc_args=lc_args)
        self.assertNotEqual(combo.lc, None)
        self.assertEqual(combo.mc, None)

        combo = SpringMemcacheClient(db_args, mc_args)
        self.assertEqual(combo.lc, None)
        self.assertNotEqual(combo.mc, None)

    def test_bad_init(self):
        with self.assertRaises(Exception):
            db = SpringMemcacheClient(
                {'cluster': SPRINGDB_CLUSTER, 'table': SPRINGDB_TABLE},
            )
        
        #with self.assertRaises(Exception):
            #db = SpringMemcacheClient(
                #{'cluster': '', 'table': SPRINGDB_TABLE},
                #{'memcache_servers': NORMAL_SERVER_LIST}
            #)

    def test_get_set(self):
        # set
        k = rand_str()
        v = rand_str()
        self.assertEqual(self.combo.set(k, v), 1)
        self.assertEqual(self.combo.lc.get(k), v)
        self.assertEqual(self.combo.mc.get(k), v)
        self.assertEqual(self.combo.db.get(k), v)

        # get from lc
        k = rand_str()
        v = rand_str()
        self.combo.lc.put(k, v)
        self.assertEqual(self.combo.get(k), v)

        # get from mc
        k = rand_str()
        v = rand_str()
        self.assertEqual(self.combo.mc.set(k, v), 1)
        self.assertEqual(self.combo.lc.get(k), None)
        self.assertEqual(self.combo.get(k), v)

        # get from db
        k = rand_str()
        v = rand_str()
        self.assertEqual(self.combo.db.set(k, v), 1)
        self.assertEqual(self.combo.lc.get(k), None)
        self.assertEqual(self.combo.mc.get(k), None)
        self.assertEqual(self.combo.get(k), v)

        # fill back from db
        k = rand_str()
        v = rand_str()
        self.assertEqual(self.combo.db.set(k, v), 1)
        self.assertEqual(self.combo.lc.get(k), None)
        self.assertEqual(self.combo.mc.get(k), None)
        self.assertEqual(self.combo.db.get(k), v)
        # get from combo, it will fill back
        self.assertEqual(self.combo.get(k), v)
        self.assertEqual(self.combo.lc.get(k), v)
        self.assertEqual(self.combo.mc.get(k), v)

    def test_expire(self):
        # ttl in set is only set to mc and springdb
        k = rand_str()
        v = rand_str()
        self.assertEqual(self.combo.set(k, v, 1), 1)
        time.sleep(1.1)
        self.assertEqual(self.combo.lc.get(k), v)
        self.assertEqual(self.combo.mc.get(k), None)
        self.assertEqual(self.combo.db.get(k), None)

        # short ttl on lc
        db_args = {'cluster': SPRINGDB_CLUSTER, 'table': SPRINGDB_TABLE}
        mc_args = {'memcache_servers': NORMAL_SERVER_LIST}
        lc_args = {'size': 100, 'default_timeout': 1}
        combo = SpringMemcacheClient(db_args, mc_args, lc_args)

        k = rand_str()
        v = rand_str()

        self.assertEqual(combo.set(k, v, 1), 1)
        self.assertEqual(combo.lc.get(k), v)
        self.assertEqual(combo.mc.get(k), v)
        self.assertEqual(combo.db.get(k), v)
        self.assertEqual(combo.get(k), v)

        time.sleep(1.1)
        self.assertEqual(combo.lc.get(k), None)
        self.assertEqual(combo.mc.get(k), None)
        self.assertEqual(combo.db.get(k), None)
        self.assertEqual(combo.get(k), None)

    def test_empty_value(self):
        # test get empty string or 0

        # combo should return the '' in lc, means that combo got '' and return
        # that is, '' or 0 can be cached in lc or mc, and will not breakthrough
        # to springdb
        k = rand_str()
        self.combo.lc.put(k, '')
        self.assertEqual(self.combo.mc.set(k, 'a'), 1)
        self.assertEqual(self.combo.get(k), '')

        k = rand_str()
        self.assertEqual(self.combo.mc.set(k, 0), 1)
        self.assertEqual(self.combo.db.set(k, 'a'), 1)
        self.assertEqual(self.combo.get(k), 0)

    def test_mset_mget1(self):
        # mset
        kv_pair = gen_kv_pair()
        self.assertEqual(self.combo.mset(kv_pair), [])

        # mget
        self.assertEqual(self.combo.mget(kv_pair.keys()), kv_pair)

    def test_mset_mget2(self):
        # mget gather result from lc/mc/db

        kv_pair1 = gen_kv_pair(32)
        kv_pair2 = gen_kv_pair(32)
        kv_pair3 = gen_kv_pair(32)
        kv_pair = dict(kv_pair1.items() + kv_pair2.items() + kv_pair3.items())

        # set
        for k, v in kv_pair1.items():
            self.combo.lc.put(k, v)
        self.assertEqual(self.combo.mc.mset(kv_pair2), [])
        for k, v in kv_pair3.items():
            self.assertEqual(self.combo.db.set(k, v), 1)

        # mget
        self.assertEqual(self.combo.mget(kv_pair.keys()) , kv_pair)

        # we only fill back some key in every mget,
        # fill back should finish after N times
        for i in xrange(len(kv_pair)):
            self.assertEqual(self.combo.mget(kv_pair.keys()) , kv_pair)
        # check fill back result
        for key, value in kv_pair.items():
            self.assertEqual(self.combo.lc.get(key), value)
        # mc can't be fully filled, because some results only in lc
        self.assertEqual(self.combo.mc.mget(kv_pair3.keys()) , kv_pair3)

    def test_mset_mget3(self):
        kv_pair1 = gen_kv_pair(32)
        kv_pair2 = gen_kv_pair(32)
        kv_pair = dict(kv_pair1.items() + kv_pair2.items())

        # set
        self.assertEqual(self.combo.mc.mset(kv_pair1), [])
        for k, v in kv_pair2.items():
            self.assertEqual(self.combo.db.set(k, v), 1)

        # mget
        self.assertEqual(self.combo.mget(kv_pair.keys(), fill_back_num=9999) , kv_pair)

        # check fill back result
        for key, value in kv_pair.items():
            self.assertEqual(self.combo.lc.get(key), value)
        self.assertEqual(self.combo.mc.mget(kv_pair.keys()) , kv_pair)

    def test_failure(self):
        #mset failed
        pass

class TestBytesLen(unittest.TestCase):

    def test_len(self):
        ''' test len function in MemcacheClient '''

        mc = MemcacheClient([])

        v = None
        self.assertEqual(mc._len(v), 0)
        v = True
        self.assertEqual(mc._len(v), 0)
        v = False
        self.assertEqual(mc._len(v), 0)
        v = '0'
        self.assertEqual(mc._len(v), 1)
        v = '123'
        self.assertEqual(mc._len(v), 3)
        v = 0
        self.assertEqual(mc._len(v), 1)
        v = 0.0
        self.assertEqual(mc._len(v), 3)
        v = 0.00
        self.assertEqual(mc._len(v), 3)
        v = 1234
        self.assertEqual(mc._len(v), 4)
        v = []
        self.assertEqual(mc._len(v), 0)
        v = ()
        self.assertEqual(mc._len(v), 0)
        v = {}
        self.assertEqual(mc._len(v), 0)
        v = ('1', 12)
        self.assertEqual(mc._len(v), 3)
        v = ['123', 12]
        self.assertEqual(mc._len(v), 5)
        v = {'a': 0, 'bb': ['a']}
        self.assertEqual(mc._len(v), 5)

if __name__ == '__main__':
    #TODO add server checking before test

    FORMAT = '%(asctime)s %(levelname)s %(message)s'
    logging.basicConfig(format=FORMAT)
    logging.getLogger().setLevel(logging.INFO)
    #logging.getLogger().setLevel(logging.DEBUG)
    unittest.main()


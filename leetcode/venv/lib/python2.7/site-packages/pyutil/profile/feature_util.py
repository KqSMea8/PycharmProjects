from pyutil.cache.cache_class import CacheClass
from pyutil.cache.locmem import LocMemCache
from struct import pack, pack_into
import pdb, hashlib, MySQLdb


class Id2FeatureCache(CacheClass):
    def __init__(self, profile_dal, cache):
        self.cache = cache
        self.profile_dal = profile_dal

    def _mget(self, fids):
        self.profile_dal.execute('select id, origin from feature_id_map where id in (%s)' % \
                ','.join([str(fid) for fid in fids]))
        rows = self.profile_dal.cursor.fetchall() 
        return {r['id']:r['origin'] for r in rows}


class Feature2IdCache:
    def __init__(self, profile_dal, cache):
        self.cache = cache
        self.profile_dal = profile_dal

    def make_key(self, family_id, feature):
        if type(feature) is unicode:
            feature = feature.encode('utf8')
        return '%s:%s'%(family_id, hashlib.md5(feature).hexdigest()) 

    def gen_sign(self, feature):
        if type(feature) is unicode:
            feature = feature.encode('utf8')
        return hashlib.md5(feature).digest() 

    def mget(self, family_id, features, save_new=True):
        kmap = {f:self.make_key(family_id, f) for f in features}
        kvs = self.cache.get_multi(kmap.values())
        ret = {}
        nfsigns = [] 
        for f in features:
            k = kmap[f]
            v = kvs.get(k)
            if v == None:
                nfsigns.append((f, self.gen_sign(f)))
                continue
            ret[f] = v

        if nfsigns:
            nkvs = {}
            signs = [f[1] for f in nfsigns]
            sql = 'select id, origin from feature_id_map where family_id=%s and sign in (%s)' % (family_id, ','.join(['%s']*len(signs)))
            self.profile_dal.execute(sql, *signs)

            rows = self.profile_dal.cursor.fetchall()
            for r in rows:
                f, fid = r['origin'], r['id']
                ret[f] = fid
                nkvs[kmap[f]] = fid 

            nfsigns_ = [(f, sign) for f, sign in nfsigns if f not in ret]
            if nfsigns_ and save_new:
                sqls = []
                params = []
                for f, sign in nfsigns_:
                    sqls.append('(%s, %s, %s)')
                    params.append(family_id)
                    params.append(f)
                    params.append(sign)

                self.profile_dal.execute('insert ignore into feature_id_map (family_id, origin, sign) values %s' % ','.join(sqls), *params)

                signs = [f[1] for f in nfsigns_]
                sql = 'select id, origin from feature_id_map where family_id=%s and sign in (%s)' % (family_id, ','.join(['%s']*len(signs)))
                self.profile_dal.execute(sql, *signs)

                rows = self.profile_dal.cursor.fetchall()
                for r in rows:
                    f, fid = r['origin'], r['id']
                    ret[f] = fid
                    nkvs[kmap[f]] = fid 

            self.cache.set_multi(nkvs)
        return ret

class FeatureMetaCache:
    def __init__(self, profile_dal):
        self.cache = LocMemCache('feature_meta_cache', use_lock=False, use_copy=False, params={'max_entries':1000})
        self.profile_dal = profile_dal

    def get(self, feature_name):
        meta = self.cache.get(feature_name)
        if meta == None:
            self.profile_dal.execute('select * from feature_meta where feature_name=%s', feature_name)
            row = self.profile_dal.cursor.fetchone()
            meta = row if row else {}
            self.cache.set(feature_name, meta, timeout=3600)
        return meta


class FeatureUtil:
    def __init__(self, profile_dal, f2id_cache=None, id2f_cache=None):
        self.profile_dal = profile_dal

        if not f2id_cache:
            f2id_cache = LocMemCache('f2id_cache', 
                    use_lock=False, use_copy=False, params={'max_entries':5000000})
        
        if not id2f_cache:
            id2f_cache = LocMemCache('id2f_cache', 
                    use_lock=False, use_copy=False, params={'max_entries':5000000})
            
        self.feature_id_cache = Feature2IdCache(profile_dal, f2id_cache)
        self.id_feature_cache = Id2FeatureCache(profile_dal, id2f_cache)
        self.meta_cache = FeatureMetaCache(profile_dal) 

    def gen_profile_str(self, family_id, profile):
        fid_map = self.feature_id_cache.mget(family_id, profile.keys())
        profile_str = ''
        items = profile.items()
        items.sort(key=lambda i:i[1], reverse=True)
        for f, v in items:
            profile_str += pack('If', fid_map[f], v)
        return profile_str 

    def get_feature_id(self, family_id, feature, save_new=True):
        fs = feature if type(feature) is list else [feature]
        fid_map = self.feature_id_cache.mget(family_id, fs, save_new)
        if type(feature) is not list:
            return fid_map.get(feature)
        return fid_map


    def get_feature_name(self, fid):
        fids = fid if type(fid) is list else [fid]
        ret = self.id_feature_cache.mget(fids)
        if type(fid) is not list:
            return ret.get(fid)
        return ret 


    def get_feature_meta(self, fname):
        return self.meta_cache.get(fname) 

        
    def init_feature_cache(self, f2id=True, id2f=True):
        start = 0
        while True:
            self.profile_dal.execute('select id, origin from feature_id_map where id>%s order by id limit 10000' % start)
            rows = self.profile_dal.cursor.fetchall() 
            if not rows:
                break

            if f2id:
                kvs = {r['origin']:r['id'] for r in rows}
                self.feature_id_cache.cache.set_multi(kvs)

            if id2f:
                kvs = {r['id']:r['origin'] for r in rows}
                self.id_feature_cache.cache.set_multi(kvs)

            start = rows[-1]['id']

def shrink(features, ratio=0.9):
    cut_power = sum(features) * ratio
    float_features = [(idx, f) for idx, f in enumerate(features)]
    float_features.sort(key=lambda x:x[1], reverse=True)
    shrinked = []
    curr_sum = 0
    for idx, f in float_features:
        shrinked.append((idx, f))
        curr_sum += f
        if curr_sum >= cut_power:
            break
    return shrinked

if __name__ == '__main__':
    from conf import profile_dal, cache

    futil = FeatureUtil(profile_dal, cache)
    features = [str(i) for i in range(512)]
    fids = futil.get_feature_id(8, features)
    print fids
    features = [str(i) for i in range(100)]
    fids = futil.get_feature_id(7, features)
    print fids


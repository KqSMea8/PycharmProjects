'''
To see supported namespaces and countspaces, visit http://10.8.47.109:9500/reload
'''
import os
import time
import logging
import random
import threading
from conf2 import Conf
from pyutil.program import metrics2 as metrics
from urllib3 import connection_from_url, Timeout

logger = logging.getLogger("idgenerator")
rand = random.SystemRandom()

TIMEOUT = 4
CLUSTERS = {
    "LANGFANG": ["http://10.8.60.32:8082/", "http://10.11.41.146:8082/"],
}

SUCCESS_THROUGHPUT = "req.success.throughput"
SUCCESS_LATENCY = "req.success.latency"
ERROR_THROUGHPUT = "req.error.throughput"
ERROR_LATENCY = "req.error.latency"
METRICS_PREFIX = "idgenerator"

metrics.define_counter(SUCCESS_THROUGHPUT, prefix=METRICS_PREFIX)
metrics.define_timer(SUCCESS_LATENCY, prefix=METRICS_PREFIX)
metrics.define_counter(ERROR_THROUGHPUT, prefix=METRICS_PREFIX)
metrics.define_timer(ERROR_LATENCY, prefix=METRICS_PREFIX)


def _define_tagkv(tagkv):
    for tagk, tagv in tagkv.iteritems():
        if not metrics.has_defined_tagkv(tagk, tagv):
            metrics.define_tagkv(tagk, [tagv])


class IDGeneratorClient(object):
    def __init__(self, cluster="LANGFANG", max_retries=3):
        conf_file = '/opt/tiger/ss_conf/ss/id_generator.conf'
        if cluster == "AWS":
            conf = Conf(conf_file)
            self.servers = conf.id_generator_addr.split(',')
        elif os.path.exists(conf_file):
            conf = Conf(conf_file)
            self.servers = conf.id_generator_addr.split(',')
        else:
            self.servers = CLUSTERS.get(cluster)
        if not self.servers:
            raise ValueError("cluster '%s' not exists" % cluster)
        self.max_retries = max_retries
        self.lock = threading.Lock()

    def pick_conn(self, new=False):
        with self.lock:
            conn = getattr(self, "conn", None)
            if new is False and conn:
                return conn
            s = rand.choice(self.servers)
            self.conn = connection_from_url(s,
                                            maxsize=4,
                                            timeout=Timeout(TIMEOUT))
            return self.conn

    def gen_v0(self, namespace):
        """
        gen_v0 generates 52bit unique ID
        timestamp = $ID >> 20
        """
        return self.gen_multi_v0(namespace, 1)[0]

    def gen_multi_v0(self, namespace, count):
        """
        gen_multi_v0 generates count# of 52bit unique ID list
        """
        tagkv = {"namespace": namespace, "countspace": "default", "count": str(count), "language": "py", "length": "52"}
        _define_tagkv(tagkv)
        conn = self.pick_conn()
        retries = self.max_retries
        url = "/v0/gen?ns=%s&count=%d" % (namespace, count)
        while 1:
            msg_start = time.time()
            try:
                r = conn.request("GET", url)
                msg_end = time.time()
                content = r.data
                assert r.status == 200, "http status(%d) != 200 : %s" % (
                    r.status, content
                )
                metrics.emit_counter(SUCCESS_THROUGHPUT, 1, tagkv=tagkv, prefix=METRICS_PREFIX)
                metrics.emit_timer(SUCCESS_LATENCY, (msg_end - msg_start) * 1000, tagkv=tagkv, prefix=METRICS_PREFIX)
                return [int(i) for i in content.split(",")]
            except Exception as e:
                msg_end = time.time()
                metrics.emit_counter(ERROR_THROUGHPUT, 1, tagkv=tagkv, prefix=METRICS_PREFIX)
                metrics.emit_timer(ERROR_LATENCY, (msg_end - msg_start) * 1000, tagkv=tagkv, prefix=METRICS_PREFIX)
                logger.warn("%s %s %s", conn, url, e)
                conn = self.pick_conn(new=True)
                retries -= 1
                if retries < 0:
                    raise

    def gen(self, namespace, countspace):
        """
        gen generates 64bit unique ID
        timestamp = $ID >> 32
        """
        return self.gen_multi(namespace, countspace, 1)[0]

    def gen_multi(self, namespace, countspace, count):
        """
        gen_multi generates count# of 64bit unique ID list
        """
        conn = self.pick_conn()
        retries = self.max_retries
        tagkv = {"namespace": namespace, "countspace": countspace, "count": str(count), "language": "py", "length": "64"}
        _define_tagkv(tagkv)
        url = "/gen?ns=%s&cs=%s&count=%d" % (namespace, countspace, count)
        while 1:
            msg_start = time.time()
            try:
                r = conn.request("GET", url)
                msg_end = time.time()
                content = r.data
                assert r.status == 200, "http status(%d) != 200 : %s" % (
                    r.status, content
                )
                metrics.emit_counter(SUCCESS_THROUGHPUT, 1, tagkv=tagkv, prefix=METRICS_PREFIX)
                metrics.emit_timer(SUCCESS_LATENCY, (msg_end - msg_start) * 1000, tagkv=tagkv, prefix=METRICS_PREFIX)
                return [int(i) for i in content.split(",")]
            except Exception as e:
                msg_end = time.time()
                metrics.emit_counter(ERROR_THROUGHPUT, 1, tagkv=tagkv, prefix=METRICS_PREFIX)
                metrics.emit_timer(ERROR_LATENCY, (msg_end - msg_start) * 1000, tagkv=tagkv, prefix=METRICS_PREFIX)
                logger.warn("%s %s %s", conn, url, e)
                conn = self.pick_conn(new=True)
                retries -= 1
                if retries < 0:
                    raise

idgenerator_aws = IDGeneratorClient("AWS")
idgenerator = IDGeneratorClient()

if __name__ == "__main__":
    print(idgenerator.gen_v0("global"))
    print(idgenerator.gen_multi_v0("global", 3))
    print(idgenerator.gen("global", "group"))
    print(idgenerator.gen_multi("global", "group", 3))

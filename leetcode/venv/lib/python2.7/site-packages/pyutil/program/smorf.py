import logging
import argparse
import os

import pyutil.program.metrics as metrics


class Smorf(object):
    """
    Simple Mapper Only long-time Running script Framework.
    Supported by TCE, see https://wiki.bytedance.net/pages/viewpage.action?pageId=78379434

    Example Code:

    class HelloSmorf(Smorf):

        def init(self):
            logging.info("Init HelloSmorf, psm=%s, splits=%s"%(self._psm, self._splits))
            logging.info("My opts.x is %s" % self._opts.x)
            self.count = 100

        def init_argparse(self, parser):
            parser.add_argument("-x", help="A dummy arg")

        def process(self):
            print("HelloSmorf, %d" % self.count)
            time.sleep(0.5)
            return self.count, 0


    if __name__ == "__main__":
        s = HelloSmorf()
        s.run()
    """

    PSM_ENV_KEY = "TCE_PSM"
    LKEXEC_PARAM_ENV_KEY = "LKEXEC_PARAM"
    __METRIC_KEY_THROUGHPUT = "throughput"
    __EMITTING_COUNTERS = (__METRIC_KEY_THROUGHPUT,)

    def __my_init(self, args=None):
        self._parser = argparse.ArgumentParser(description="A script using the 'Simple Mapper Only long-time Running script Framework'\n"
                                               "\n\n"
                                               "Will emit standard throughput metric in format 'PSM.script.throughput'\n"
                                               "'PSM' value can read from %s env(when run in tce) or --psm.\n"
                                               "\n\n"
                                               "And support lkexec tool, see https://code.byted.org/inf/lkexec" %
                                                           Smorf.PSM_ENV_KEY)
        self._parser.add_argument("--psm",
                                  help="P.S.M name of this script, DO NOT use when %s env is available" %
                                  Smorf.PSM_ENV_KEY)
        self._parser.add_argument("--lkexec_param",
                                  help="lkexec_param of this script will process, for debugging propose only" + \
                " DO NOT use when %s env is available" % Smorf.LKEXEC_PARAM_ENV_KEY)

        self.init_argparse(self._parser)

        self._opts = self._parser.parse_args(args=args)

        if Smorf.PSM_ENV_KEY in os.environ and self._opts.psm is not None:
            logging.error("PSM is both provided in %s env, and --psm opts, you should only use one of them" %
                          Smorf.PSM_ENV_KEY)
            self._parser.print_help()
            self._parser.exit(1)

        if Smorf.LKEXEC_PARAM_ENV_KEY in os.environ and self._opts.lkexec_param is not None:
            logging.error("lkexec_param is both provided in %s env, and --lkexec_param opts, "
                          "you should only use one of them" % Smorf.LKEXEC_PARAM_ENV_KEY)
            self._parser.print_help()
            self._parser.exit(1)

        if Smorf.PSM_ENV_KEY in os.environ:
            self._psm = os.environ.get(Smorf.PSM_ENV_KEY)
        elif self._opts.psm is not None:
            self._psm = self._opts.psm
        else:
            logging.error("psm not found")
            self._parser.print_help()
            self._parser.exit(1)

        if Smorf.LKEXEC_PARAM_ENV_KEY in os.environ:
            self.__lkexec_param = os.environ.get(Smorf.LKEXEC_PARAM_ENV_KEY)
        elif self._opts.lkexec_param is not None:
            self.__lkexec_param = self._opts.lkexec_param
        else:
            self.__lkexec_param = None

        self._splits = []
        self._prefix = "%s.script" % self._psm
        self._tagkv = {"type": ["success", "fail"]}

        for c in Smorf.__EMITTING_COUNTERS:
            metrics.define_counter(c, prefix=self._prefix)

        if self.__lkexec_param is not None:
            self._tagkv["lkexec_param"] = [self.__lkexec_param]
            self._splits = self.__lkexec_param.split(",")
        for tagk, tagv_list in self._tagkv.items():
            metrics.define_tagkv(tagk, tagv_list)

        logging.info("Instance of Smorf starting, PSM='%s', processing split='%s'" % (self._psm,
                                                                                  ",".join(self._splits)))
        logging.info("I will emitting the flowing metric:")
        for c in Smorf.__EMITTING_COUNTERS:
            logging.info("  %s.%s" %(self._prefix, c))

        self.init()

    def init(self):
        """
        Override this method to do initialize work before run
        :return:
        """
        pass

    def init_argparse(self, parser):
        """
        Override this method to add more argument to argparse
        :param parser: Instance of argparse.ArgumentParser
        :return:
        """
        pass

    def process(self):
        """
        Process 1 on batch of records from source.

        Batch process is encouraged, but DO NOT block too long, for example more than 30 seconds
        return number of success and fail records processed

        :return: (success_count, fail_count)
        """
        raise RuntimeError("Smorf.process must be overwrited")

    def run(self):
        self.__my_init()

        while True:
            success_count, fail_count = self.process()

            metrics.emit_counter(Smorf.__METRIC_KEY_THROUGHPUT, success_count, tagkv={"type": "success"},
                                 prefix=self._prefix)
            metrics.emit_counter(Smorf.__METRIC_KEY_THROUGHPUT, fail_count, tagkv={"type": "fail"},
                                 prefix=self._prefix)

#!/usr/bin/env python
# coding: utf-8
__author__ = 'zhenghuabin'

import logging
from time import time as get_time

from cache_metrics import CacheMetrics, NullMetrics
from conf_discover import get_cluster_info
from memcache_connection import ClusterClient

_METRIC_PREFIX = "memcache.client"

class MemcacheClient(object):
    version = 1

    def __init__(self, cluster, psm=None, servers=None, key_tmpl=None, timeout=60, enable_metrics=True, **kwargs):
        """
        """
        cluster, psm, servers = get_cluster_info(cluster, psm, servers)
        if servers:
            logging.info("MemcacheClient get servers info, Cluster:%s, Servers:%s, PSM:%s", cluster, servers, psm)
        else:
            logging.error("MemcacheClient get servers Error, Cluster:%s, Servers:%s, PSM:%s", cluster, servers, psm)
        self.cluster = cluster
        self.psm = psm
        self.servers = servers
        self.key_tmpl = key_tmpl
        self.timeout = timeout
        self.enable_metrics = enable_metrics
        self.kwargs = kwargs
        self.client = ClusterClient.get(cluster, servers, **kwargs)
        if enable_metrics:
            self.metrics = CacheMetrics(cluster, _METRIC_PREFIX, psm)
        else:
            self.metrics = NullMetrics()

    def __del__(self):
        if ClusterClient:
            ClusterClient.release(self.client, self.cluster, self.servers, **self.kwargs)

    def _make_key(self, key, key_tmpl=None):
        if key_tmpl:
            key = key_tmpl % key
        elif self.key_tmpl:
            key = self.key_tmpl % key
        return key

    def _get_timeout(self, timeout):
        return timeout if timeout!=None else self.timeout

    def _get_args(self, key, key_tmpl, timeout):
        return self._make_key(key, key_tmpl), self._get_timeout(timeout)

    def set(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()

        key, time = self._get_args(key, key_tmpl, time)
        try:
            result = self.client.set(key, val, time, min_compress_len)
        except Exception as e:
            logging.error("memcache set error, %s", e)
            self.metrics.add_call_metrics('set', get_time() - ts, False)
            return None
        self.metrics.add_call_metrics('set', get_time() - ts, result != 0)
        return result

    def get(self, key, key_tmpl=None):
        ts = get_time()
        try:
            key = self._make_key(key, key_tmpl)
            result = self.client.get(key)
        except Exception as e:
            logging.error("memcache get error, %s", e)
            self.metrics.add_call_metrics('get', get_time() - ts, False)
            return None
        self.metrics.add_call_metrics('get', get_time() - ts, True)
        self.metrics.add_hit_miss_metrics('get', 1 if result != None else 0, 1 if result == None else 0)
        return result

    def add(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()

        key, time = self._get_args(key, key_tmpl, time)
        result = self.client.add(key, val, time, min_compress_len)

        self.metrics.add_call_metrics('add', get_time() - ts, True)
        return result

    def append(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()

        key, time = self._get_args(key, key_tmpl, time)
        result = self.client.append(key, val, time, min_compress_len)

        self.metrics.add_call_metrics('append', get_time() - ts, result != 0)
        return result

    def delete(self, key, time=0, key_tmpl=None):
        ts = get_time()

        key, time = self._get_args(key, key_tmpl, time)
        time = None
        result = self.client.delete(key, time)

        self.metrics.add_call_metrics('delete', get_time() - ts, result != 0)
        return result

    def _mset(self, mapping, time=0, key_prefix='', min_compress_len=0, key_tmpl=None):
        ts = get_time()

        time = self._get_timeout(time)
        ret = []
        if len(key_prefix) > 0:
            ret = self.client.set_multi(mapping, time, key_prefix, min_compress_len)
        else:
            key_map = {key: self._make_key(key, key_tmpl) for key in mapping.iterkeys()}
            reverse_key_map = {v: k for k, v in key_map.iteritems()}
            notset_keys = self.client.set_multi(
                {key_map[key]: val for key, val in mapping.iteritems()},
                time, '', min_compress_len)
            ret = [reverse_key_map[key] for key in notset_keys]

        self.metrics.add_call_metrics('mset', get_time() - ts, len(ret) == 0)
        return ret

    def mset(self, mapping, time=0, key_prefix='', min_compress_len=0, key_tmpl=None, split_num=1024):
        split_count = 0
        final = []
        if len(mapping) <= split_num:
            final = self._mset(mapping, time, key_prefix, min_compress_len, key_tmpl)
        else:
            def push_result(result):
                if isinstance(result, list):
                    for k in result:
                        final.append(k)

            sending = {}
            for key, value in mapping.items():
                sending[key] = value
                if len(sending) >= split_num:
                    push_result(self._mset(mapping, time, key_prefix, min_compress_len, key_tmpl))
                    split_count += 1
                    sending.clear()
            if len(sending):
                push_result(self._mset(mapping, time, key_prefix, min_compress_len, key_tmpl))
                split_count += 1

        self.metrics.add_batch_num_metrics('mset', len(mapping), split_count)
        return final

    def set_multi(self, mapping, time=0, key_prefix='', min_compress_len=0, key_tmpl=None, split_num=1024):
        return self.mset(mapping, time, key_prefix, min_compress_len, key_tmpl, split_num)

    def get_multi(self, keys, key_prefix='', key_tmpl=None, split_num=1024):
        return self.mget(keys, key_prefix, key_tmpl, split_num)

    def _mget(self, keys, key_prefix='', key_tmpl=None):
        ts = get_time()

        result = {}
        if len(key_prefix) > 0:
            result = self.client.get_multi(keys, key_prefix)
        else:
            key_map = {key: self._make_key(key, key_tmpl) for key in keys}
            reverse_key_map = {v: k for k, v in key_map.iteritems()}
            mapping = self.client.get_multi([key_map[key] for key in keys])
            result = {reverse_key_map[key]: val for key, val in mapping.iteritems()}

        self.metrics.add_call_metrics('mget', get_time() - ts, True)
        return result

    def mget(self, keys, key_prefix='', key_tmpl=None, split_num=1024):
        split_count = 0
        final = {}
        if len(keys) <= split_num:
            final = self._mget(keys, key_prefix, key_tmpl)
        else:
            def push_result(result):
                if isinstance(result, dict):
                    if isinstance(result, dict):
                        for k, v in result.items():
                            final[k] = v

            sending = []
            for key in keys:
                sending.append(key)
                if len(sending) >= split_num:
                    push_result(self._mget(sending, key_prefix, key_tmpl))
                    split_count += 1
                    sending = []
            if len(sending):
                push_result(self._mget(sending, key_prefix, key_tmpl))
                split_count += 1

        self.metrics.add_hit_miss_metrics('mget', len(final), len(keys) - len(final))
        self.metrics.add_batch_num_metrics('mget', len(keys), split_count)
        return final

    def delete_multi(self, keys, time=0, key_prefix='', key_tmpl=None):
        ts = get_time()

        time = None    #memcache not support time for delete
        result = 1
        if len(key_prefix) > 0:
            result = self.client.delete_multi(keys, time, key_prefix)
        else:
            new_keys = [self._make_key(key, key_tmpl) for key in keys]
            result = self.client.delete_multi(new_keys, time)

        self.metrics.add_call_metrics('delete_multi', get_time() - ts, result != 0)
        return result

    def replace(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()
        key, time = self._get_args(key, key_tmpl, time)
        result = self.client.replace(key, val, time, min_compress_len)
        self.metrics.add_call_metrics('replace', get_time() - ts, result != 0)
        return result

    def prepend(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()
        key, time = self._get_args(key, key_tmpl, time)
        result = self.client.prepend(key, val, time, min_compress_len)
        self.metrics.add_call_metrics('prepend', get_time() - ts, result != 0)
        return result

    def cas(self, key, val, time=0, min_compress_len=0, key_tmpl=None):
        ts = get_time()
        key, time = self._get_args(key, key_tmpl, time)
        result = self.client.cas(key, val, time, min_compress_len)
        self.metrics.add_call_metrics('cas', get_time() - ts, result != 0)
        return result

    def reset_cas(self):
        self.client.reset_cas()

    def gets(self, key, key_tmpl=None):
        ts = get_time()
        key = self._make_key(key, key_tmpl)
        result = self.client.gets(key)
        self.metrics.add_call_metrics('gets', get_time() - ts, True)
        self.metrics.add_hit_miss_metrics('gets', 1 if result != None else 0, 1 if result == None else 0)
        return result

    def incr(self, key, delta=1, key_tmpl=None):
        ts = get_time()
        key = self._make_key(key, key_tmpl)
        result = self.client.incr(key, delta)
        self.metrics.add_call_metrics('incr', get_time() - ts, True)
        return result

    def decr(self, key, delta=1, key_tmpl=None):
        ts = get_time()
        key = self._make_key(key, key_tmpl)
        result = self.client.decr(key, delta)
        self.metrics.add_call_metrics('decr', get_time() - ts, True)
        return result


# to compatible with pyutil/memcache/client.py
class PyutilMemcacheClient(object):

    def __init__(self, cluster, psm=None, servers=None, key_tmpl=None, timeout=60, enable_metrics=True, **kwargs):
        """
        """
        self.client = MemcacheClient(cluster, psm, servers, key_tmpl, timeout, enable_metrics, **kwargs)

    def set(self, key, val, timeout=None, key_tmpl=None):
        return self.client.set(key, val, timeout, key_tmpl=key_tmpl)

    def get(self, key, key_tmpl=None):
        return self.client.get(key, key_tmpl=key_tmpl)

    def add(self, key, val, timeout=None, key_tmpl=None):
        return self.client.add(key, val, timeout, key_tmpl=key_tmpl)

    def append(self, key, val, timeout=None, key_tmpl=None):
        return self.client.append(key, val, timeout, key_tmpl=key_tmpl)

    def delete(self, key, key_tmpl=None):
        return self.client.delete(key, key_tmpl=key_tmpl)

    def mset(self, mapping, timeout=None, key_tmpl=None, split_num=1024):
        return self.client.mset(mapping, timeout, key_tmpl=key_tmpl, split_num=split_num)

    def set_multi(self, mapping, timeout=None, key_tmpl=None, split_num=1024):
        return self.mset(mapping, timeout, key_tmpl, split_num)

    def get_multi(self, keys, key_tmpl=None, split_num=1024):
        return self.mget(keys, key_tmpl, split_num)

    def mget(self, keys, key_tmpl=None, split_num=1024):
        return self.client.mget(keys, key_tmpl=key_tmpl, split_num=split_num)

    def delete_multi(self, keys, timeout=0, key_tmpl=None):
        return self.client.delete_multi(keys, timeout, key_tmpl=key_tmpl)

    def _len(self, data):
        if isinstance(data, basestring):
            return len(data)
        elif isinstance(data, (list, tuple)):
            l = 0
            for v in data:
                l += self._len(v)
            return l
        elif isinstance(data, dict):
            l = 0
            for k, v in data.items():
                l += self._len(k) + self._len(v)
            return l
        elif data is None or data is True or data is False:
            return 0
        elif isinstance(data, (int, float, long)):
            return len(str(data))
        else:
            return 0

    def replace(self, key, val, timeout=0, key_tmpl=None):
        return self.client.replace(key, val, timeout, key_tmpl=key_tmpl)

    def prepend(self, key, val, timeout=0, key_tmpl=None):
        return self.client.prepend(key, val, timeout, key_tmpl=key_tmpl)

    def cas(self, key, val, timeout=0, key_tmpl=None):
        return self.client.cas(key, val, timeout, key_tmpl=key_tmpl)

    def reset_cas(self):
        return self.client.reset_cas()

    def gets(self, key, key_tmpl=None):
        return self.client.gets(key, key_tmpl=key_tmpl)

    def incr(self, key, delta=1, key_tmpl=None):
        return self.client.incr(key, delta, key_tmpl=key_tmpl)

    def decr(self, key, delta=1, key_tmpl=None):
        return self.client.decr(key, delta, key_tmpl=key_tmpl)


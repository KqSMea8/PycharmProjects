#!/usr/bin/env python

from pyutil.program import metrics2 as metrics

class CacheMetrics(object):

    def __init__(self, cluster, prefix, psm = None, service = None):
        self.cluster = cluster
        self.prefix = prefix
        self.service = service
        self.psm = psm
        if psm == None:
            self.psm = 'None'
        metrics.define_tagkv('cluster', [cluster])
        metrics.define_tagkv('psm', [self.psm])
        metrics.define_counter('throughput', prefix=prefix)
        metrics.define_counter('retry', prefix=prefix)
        metrics.define_counter('pipeline', prefix=prefix)
        metrics.define_counter('pipeline_error', prefix=prefix)
        metrics.define_counter('pipeline_retry', prefix=prefix)
        metrics.define_counter('pipeline_cmds', prefix=prefix)
        metrics.define_timer('latency', prefix=prefix)
        metrics.define_timer('pipeline_latency', prefix=prefix)
        metrics.define_counter('bytes_written', prefix=prefix)
        metrics.define_counter('bytes_read', prefix=prefix)
        metrics.define_counter('error', prefix=prefix)
        metrics.define_counter('hits', prefix=prefix)
        metrics.define_counter('misses', prefix=prefix)
        metrics.define_timer('batch_num', prefix=prefix) # need percentile
        metrics.define_counter('split_count', prefix=prefix)
        metrics.define_counter('deprecated_use', prefix=prefix)
        if service:
            self.frame = 'toutiao.service.thrift.' + self.psm
            metrics.define_counter('call.success.throughput', prefix=self.frame)
            metrics.define_counter('call.error.throughput', prefix=self.frame)
            metrics.define_timer('call.success.latency.us', prefix=self.frame)
            metrics.define_timer('call.error.latency.us', prefix=self.frame)
            metrics.define_tagkv('to', [service])
            metrics.define_tagkv('to_dc', ['hy', 'lf', 'None'])

    @staticmethod
    def add_tagkv(key, tags):
        metrics.define_tagkv(key, tags)

    def get_tags(self, cmd = None, backend = None):
        tags = {'cluster':self.cluster, 'psm':self.psm}
        if cmd:
            cmd = cmd.upper()
            metrics.define_tagkv('cmd', [cmd])
            tags['cmd'] = cmd
        if backend:
            metrics.define_tagkv('backend', [backend])
            tags['backend'] = backend
        return tags

    def get_service_tags(self, cmd, backend = None):
        cmd = cmd.upper()
        metrics.define_tagkv('method', [cmd])
        dc = 'None'
        if backend:
            if backend.startswith('10.4.'):
                dc = 'hy'
            elif backend.startswith('10.6.') or backend.startswith('10.3.'):
                dc = 'lf'
        tags = {'to':self.service, 'method':cmd, 'to_dc':dc}
        return tags

    def add_init_metrics(self, latency):
        self.add_call_metrics('init', latency, 1, 0, 0)

    def add_call_metrics(self, cmd, latency, is_ok, bytes_written=0, bytes_read=0, backend = None):
        ''' currently, not all commands pass in bytes_written and bytes_read '''

        tags = self.get_tags(cmd, backend)

        latency = latency * 1000000
        metrics.emit_counter('throughput', 1, self.prefix, tags)
        if latency >= 0:
            metrics.emit_timer('latency', latency, self.prefix, tags)
        if is_ok is not None and is_ok is False:
            metrics.emit_counter('error', 1, self.prefix, tags)
        if bytes_written > 0:
            metrics.emit_counter('bytes_written', bytes_written, self.prefix, tags)
        if bytes_read > 0:
            metrics.emit_counter('bytes_read', bytes_read, self.prefix, tags)
        if self.service:
            tags = self.get_service_tags(cmd, backend)
            if is_ok:
                metrics.emit_counter('call.success.throughput', 1, self.frame, tags)
                if latency >= 0:
                    metrics.emit_timer('call.success.latency.us', latency, self.frame, tags)
            else:
                metrics.emit_counter('call.error.throughput', 1, self.frame, tags)
                if latency >= 0:
                    metrics.emit_timer('call.error.latency.us', latency, self.frame, tags)

    def add_retry_metrics(self, cmd, backend=None):
        tags = self.get_tags(cmd, backend)
        metrics.emit_counter('retry', 1, self.prefix, tags)

    def add_hit_miss_metrics(self, cmd, hits, misses, backend = None):
        tags = self.get_tags(cmd, backend)
        if hits > 0:
            metrics.emit_counter('hits', hits, self.prefix, tags)
        if misses > 0:
            metrics.emit_counter('misses', misses, self.prefix, tags)

    def add_batch_num_metrics(self, cmd, batch_num, split_count):
        tags = self.get_tags(cmd)
        metrics.emit_timer('batch_num', batch_num, self.prefix, tags)
        if split_count > 0:
            metrics.emit_counter('split_count', split_count, self.prefix, tags)

    def add_pipeline(self, name, ok, cmdnums, latency, backend = None):
        tags = self.get_tags(name, backend)
        metrics.emit_counter('pipeline', 1, self.prefix, tags)
        if not ok:
            metrics.emit_counter('pipeline_error', 1, self.prefix, tags)
        metrics.emit_counter('pipeline_cmds', cmdnums, self.prefix, tags)
        latency = latency * 1000000
        metrics.emit_timer('pipeline_latency', latency, self.prefix, tags)
        if self.service:
            tags = self.get_service_tags(name, backend)
            if ok:
                metrics.emit_counter('call.success.throughput', 1, self.frame, tags)
                metrics.emit_timer('call.success.latency.us', latency, self.frame, tags)
            else:
                metrics.emit_counter('call.error.throughput', 1, self.frame, tags)
                metrics.emit_timer('call.error.latency.us', latency, self.frame, tags)


    def add_pipeline_retry(self, name, backend = None):
        tags = self.get_tags(name, backend)
        metrics.emit_counter('pipeline_retry', 1, self.prefix, tags)

class NullMetrics(object):
    def __init__(self, *args, **kwargs):
        pass
    def process(self, *k, **a):
        pass
    def __getattr__(self, cmd):
        return self.process

import os
import nsq
import tornado
import time
import urllib

import pyutil.program.metrics2 as metrics
from pyutil.queue import tce_perf_test
from pyutil.idc.idc import get_idc
import pyutil.ttlogging as ttlogging

# for metrics
THROUGHPUT_SUBFIX = ".throughput"
ERROR_THROUGHPUT_SUBFIX = ".error.throughput"
LATENCY_SUBFIX = ".latency"
PREFIX = "nsq.consumer"

# for multiple idc fine grit read strategy support
MULTI_IDC_READ_STRATEGY_KEY = 'read_strategy'
MULTI_IDC_READ_STRATEGY_ALL = 'all'
MULTI_IDC_READ_STRATEGY_LOCAL_IDC = 'local_idc'

class NsqTcpReader(object):

    def __init__(self, lookupd_http_addresses):
        self.io_loop = tornado.ioloop.IOLoop()
        self.lookupd_http_addresses = lookupd_http_addresses
        self.topic_readers = []

    def message_handler_wrapper(self, func, topic, channel):
        import functools
        @functools.wraps(func)
        def _wrapped_view(*args, **kwargs):
            thoughput_key = topic + THROUGHPUT_SUBFIX
            error_thoughput_key = topic + ERROR_THROUGHPUT_SUBFIX
            latency_key = topic + LATENCY_SUBFIX

            tagkv = {'channel': channel}

            msg_start = time.time()
            ret = func(*args, **kwargs)
            msg_end = time.time()

            metrics.emit_timer(latency_key, (msg_end - msg_start) * 1000, tagkv=tagkv, prefix=PREFIX)
            metrics.emit_counter(thoughput_key, 1,  tagkv=tagkv, prefix=PREFIX)
            if ret == False:
                metrics.emit_counter(error_thoughput_key, 1,  tagkv=tagkv, prefix=PREFIX)
            return ret
        return _wrapped_view

    def add_simple_topic_reader(self, topic, channel,
                                message_handler, **kwargs):

        def message_handler_simple_wrapper(msg):
            return message_handler(msg.body)

        self.add_topic_reader(topic, channel,
                              message_handler_simple_wrapper, **kwargs)

    def add_topic_reader(self, topic, channel, message_handler,
                         **kwargs):
        topic = tce_perf_test.adjust_topic_name(topic)
        default_kwargs = {
            "max_tries": 10000,
            "max_in_flight": 600,
            "heartbeat_interval": 59,
            "lookupd_connect_timeout": 5,
            "lookupd_request_timeout": 10,
        }

        # Add support for more fine grit multiple idc read strategy support
        idc = 'all'
        if MULTI_IDC_READ_STRATEGY_KEY in kwargs:
            if kwargs[MULTI_IDC_READ_STRATEGY_KEY] == MULTI_IDC_READ_STRATEGY_ALL:
                idc = 'all'
            elif kwargs[MULTI_IDC_READ_STRATEGY_KEY] == MULTI_IDC_READ_STRATEGY_LOCAL_IDC:
                try:
                    idc = get_idc().value
                except Exception as exp:
                    ttlogging.error('Using all for querying local idc error: %s' % exp)
            else:
                idc = 'all'
        default_kwargs.update(kwargs)
        kwargs = default_kwargs

        psm = ''
        if 'LOAD_SERVICE_PSM' in os.environ:
            psm = os.environ['LOAD_SERVICE_PSM']

        # Add the channel name for access auth;
        params = {'channel': channel, 'idc': idc, 'psm': psm}
        query_params = urllib.urlencode(params)

        if isinstance(self.lookupd_http_addresses, list):
            lookupd_http_addresses = [addr + "?" + query_params for addr in self.lookupd_http_addresses]
        if isinstance(self.lookupd_http_addresses, str):
            lookupd_http_addresses = self.lookupd_http_addresses + "?" + query_params

        thoughput_key = topic + THROUGHPUT_SUBFIX
        error_thoughput_key = topic + ERROR_THROUGHPUT_SUBFIX
        latency_key = topic + LATENCY_SUBFIX

        metrics.define_counter(thoughput_key, prefix=PREFIX)
        metrics.define_counter(error_thoughput_key, prefix=PREFIX)
        metrics.define_timer(latency_key, prefix=PREFIX)

        metrics.define_tagkv('channel', [channel])

        r = nsq.Reader(topic=topic, channel=channel,
                       message_handler=self.message_handler_wrapper(message_handler, topic, channel),
                       lookupd_http_addresses=lookupd_http_addresses,
                       io_loop=self.io_loop,
                       **kwargs)

        self.topic_readers.append(r)

    def start(self):
        self.io_loop.start()

    def stop(self):
        self.io_loop.stop()

if __name__ == "__main__":
    # USAGE:
    r = NsqTcpReader(["http://127.0.0.1:4161"])

    def msg_handler(msg):
        print "RECV MSG[%s]: %s (attempts: %s)" % (msg.id, msg.body, msg.attempts)
        # return True for success, or False for Fail
        return True  # will be redelivered in futrue and ++attempts
    #r.add_topic_reader(topic, channel, msg_handler)

    def handle_exit_signal(sig_num, frame):
        print "recv signal[%s] , exiting..." % sig_num
        r.stop()
    import signal
    signal.signal(signal.SIGINT, handle_exit_signal)

    topic = "test"
    channel = __file__

    def msg_handler_simple(body):
        print "RECV MSG: %s" % body
        return True
    r.add_simple_topic_reader(topic, channel, msg_handler_simple)
    r.start()

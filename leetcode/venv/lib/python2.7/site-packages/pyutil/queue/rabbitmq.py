#!/usr/bin/env python
# coding=utf8
import time
import threading, signal

logger = None

class Config(object):
    def __init__(self):
        self.host = 'localhost'
        self.port = 5672
        self.userid = 'guest'
        self.password = 'guest'
        self.virtual_host = '/'
        self.exchange = ''
        self.exchange_type = 'direct'
        self.type = 'direct'
        self.durable = True
        self.queue = ''
        self.routing_key = ''
        self.socket_timeout = 0.250
        self.conf_str = 'default_conf'

    @classmethod
    def from_string(cls, conf_str):
        """
        conf_str is like host=localhost,port=5672,exchange=demo8_x,routing_key=demo8_k,queue=demo8_q
        """
        params = dict([tuple(s.split('=')) for s in conf_str.split(',')])
        conf = Config()
        conf.host = params.get('host', conf.host)
        conf.port = params.get('port', conf.port)
        conf.userid = params.get('userid', conf.userid)
        conf.password = params.get('password', conf.password)
        conf.virtual_host = params.get('virtual_host', conf.virtual_host)
        conf.exchange = params.get('exchange', conf.exchange)
        conf.type = params.get('type', conf.type)
        conf.exchange_type = params.get('exchange_type', conf.exchange_type)
        _durable = params.get('durable', '1')
        if _durable == '0' or _durable == 'False':
            conf.durable = False
        conf.queue = params.get('queue', conf.queue)
        conf.routing_key = params.get('routing_key', conf.routing_key)
        conf.conf_str = conf_str

        return conf

    def __hash__(self):
        return hash(self.conf_str)

    def __eq__(self, other):
        return self.conf_str == other.conf_str

class ChannelProxy(object):
    def __init__(self, channel, conf, mq_manager=None):
        self.channel = channel
        self.conf = conf
        self.mq_manager = mq_manager

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.channel.close()

    def __getattr__( self, name ):
        if name == 'basic_publish':
            return self.__basic_publish

        if name == 'basic_get':
            return self.__basic_get

        return getattr( self.channel, name )

    def __basic_get(self, queue=None, no_ack=False):
        if not queue:
            queue = self.conf.queue

        return self.channel.basic_get(queue, no_ack)

    def __basic_publish(self, body, exchange='', routing_key='', properties=None, mandatory=False, immediate=False):
        if exchange == '':
            exchange = self.conf.exchange

        if routing_key == '':
            routing_key = self.conf.routing_key

        if self.conf.durable:
            import pika
            if not properties:
                properties = pika.BasicProperties(delivery_mode=2)
            else:
                properties.delivery_mode = 2

        retries = 3
        for i in range(retries):
            try:
                return self.channel.basic_publish(exchange, routing_key, body, properties, mandatory, immediate)
            except:
                time.sleep(0.002)
                if i < retries - 1 and self.mq_manager:
                    self.mq_manager.dispose()
                    try:
                        self.channel = self.mq_manager.get(self.conf).channel
                    except:
                        pass
                else:
                    raise

def retry(ExceptionToCheck, tries=3, delay=0.002):
    """Retry calling the decorated function using an exponential backoff.

    http://www.saltycrane.com/blog/2009/11/trying-out-retry-decorator-python/
    original from: http://wiki.python.org/moin/PythonDecoratorLibrary#Retry

    :param ExceptionToCheck: the exception to check. may be a tuple of
        excpetions to check
    :type ExceptionToCheck: Exception or tuple
    :param tries: number of times to try (not retry) before giving up
    :type tries: int
    :param delay: initial delay between retries in seconds
    :type delay: int
    :param logger: logger to use. If None, print
    :type logger: logging.Logger instance
    """
    def deco_retry(f):
        def f_retry(*args, **kwargs):
            mtries = tries
            try_one_last_time = True
            while mtries > 1:
                try:
                    return f(*args, **kwargs)
                    try_one_last_time = False
                    break
                except ExceptionToCheck, e:
                    msg = "%s, Retrying in %s seconds..." % (str(e), delay)
                    logger and logger.warning(msg)

                    time.sleep(delay)
                    mtries -= 1
            if try_one_last_time:
                return f(*args, **kwargs)
            return
        return f_retry  # true decorator
    return deco_retry

# not thread safe
class MQManager(threading.local):

    MAX_IDLE_TIME = 300

    def __init__(self):
        self.conns = {}
        self.conns_atime = {}
        self.channels = {}
        self.confs = {}

    def dispose(self):
        for channel in self.channels:
            try:
                channel.close()
            except:
                pass
        self.channels.clear()

        for conn in self.conns:
            try:
                conn.close()
            except:
                pass

        self.conns.clear()
        self.conns_atime.clear()

    def get(self, conf_str_or_conf):
        if isinstance(conf_str_or_conf, str):
            conf = self.confs.get(conf_str_or_conf)
            if conf is None:
                conf = Config.from_string(conf_str_or_conf)
                self.confs[conf_str_or_conf] = conf
        elif isinstance(conf_str_or_conf, Config):
            conf = conf_str_or_conf
        else:
            raise ValueError

        key = (conf.host, conf.port)

        now_ts = time.time()
        atime = self.conns_atime.get(key)
        if atime != None and now_ts - atime > self.MAX_IDLE_TIME:
            self.dispose()  # XXX
        
        self.conns_atime[key] = now_ts

        if conf in self.channels:
            return self.channels[conf]

        if key in self.conns:
            connection = self.conns[key]
        else:
            connection = self.__get_mq_conn(conf)
            self.conns[key] = connection

        ch = self.__get_mq_channel(connection, conf)
        self.channels[conf] = ch
        return ch

    @retry(Exception)
    def __get_mq_conn(self, conf):
        import pika
        return pika.BlockingConnection(pika.ConnectionParameters(host=conf.host, port=int(conf.port), socket_timeout=conf.socket_timeout))

    @retry(Exception)
    def __get_mq_channel(self, connection, conf):
        t1 = time.time()
        channel = connection.channel()
        t2 = time.time()
        if conf.exchange:
            channel.exchange_declare(exchange=conf.exchange, exchange_type=conf.exchange_type, durable=conf.durable)
        t3 = time.time()
        if conf.exchange_type == 'direct':
            channel.queue_declare(queue=conf.queue, durable=conf.durable)

        t4 = time.time()
        if conf.exchange_type == 'direct' and conf.exchange:
            channel.queue_bind(queue=conf.queue, exchange=conf.exchange, routing_key=conf.routing_key)
        t5 = time.time()
        if t5 - t1 > 1:
            logger and logger.info("log2queue Connection(): %s, conn.channel(): %s, channel.exchange_declare(): %s, channel.queue_declare(): %s, channel.queue_bind() %s", 
                    t2 - t1, t3 - t2, t4 - t3, t5 - t4)

        return ChannelProxy(channel, conf, self)

def init_mq(conf):
    import pika

    t0 = time.time()

    connection = pika.BlockingConnection(pika.ConnectionParameters(host=conf.host, port=int(conf.port), socket_timeout=conf.socket_timeout))
    t1 = time.time()
    channel = connection.channel()
    t2 = time.time()
    if conf.exchange:
        channel.exchange_declare(exchange=conf.exchange, exchange_type=conf.exchange_type, durable=conf.durable)
    t3 = time.time()
    if conf.exchange_type == 'fanout':
        channel.queue_declare(queue=conf.queue, durable=False, auto_delete=True)
    else:
        channel.queue_declare(queue=conf.queue, durable=conf.durable)
    t4 = time.time()
    if conf.exchange:
        channel.queue_bind(queue=conf.queue, exchange=conf.exchange, routing_key=conf.routing_key)
    t5 = time.time()
    if t5 - t0 > 2:
        logger and logger.info("log2queue Connection(): %s, conn.channel(): %s, channel.exchange_declare(): %s, channel.queue_declare(): %s, channel.queue_bind() %s",
                t1 - t0, t2 - t1, t3 - t2, t4 - t3, t5 - t4)

    return ChannelProxy(channel, conf)

def __test_conf():
    conf = Config.from_string('host=192.168.20.41,exchange=demo8_x,routing_key=demo8_k,queue=demo8_q')
    assert conf.host == '192.168.20.41'
    assert conf.port == 5672
    assert conf.exchange == 'demo8_x'
    assert conf.queue == 'demo8_q'

def dump_message(channel, method, properties, body):
    print("Body:'%s'" % (body))
    channel.basic_ack(delivery_tag=method.delivery_tag)

def __test_mq():
    conf = Config.from_string('host=192.168.20.41,exchange=demo10_x,routing_key=demo10_k,queue=demo10_q')
    channel = init_mq(conf)
    print channel.basic_get()

def __test_mq_manager(produce_or_consume):
    conf = Config.from_string('host=192.168.20.41,exchange=demo10_x,routing_key=demo10_k,queue=demo10_q')
    mq_manager = MQManager()
    channel1 = mq_manager.get(conf)
    channel2 = mq_manager.get(conf)

    class P(threading.Thread):
        def __init__(self):
            threading.Thread.__init__(self)

        def run(self):
            while True:
                s = time.time()
                for i in range(1000):
                    channel1.basic_publish('hello moto!')
                    channel2.basic_publish('hello moto!')
                print 'spent: %s ms' % ((time.time() - s) / 2.0)

    class C(threading.Thread):
        def __init__(self):
            threading.Thread.__init__(self)

        def run(self):
            channel2.basic_consume(dump_message)
            channel2.start_consuming()

    if 'c' == produce_or_consume:
        C().start()
    else:
        P().start()

def __test_fanout():
    conf = Config.from_string('host=192.168.20.41,exchange=x2,exchange_type=fanout,durable=0')
    mq_manager = MQManager()
    channel = mq_manager.get(conf)

    class P(threading.Thread):
        def __init__(self):
            threading.Thread.__init__(self)

        def run(self):
            while True:
                for i in range(1000):
                    print i
                    channel.basic_publish('hello moto %s!' % i)
                    time.sleep(1)

    class C(threading.Thread):
        def __init__(self):
            threading.Thread.__init__(self)
            self.mq = init_mq(conf)

        def __dump(self, channel, method, properties, body):
            print channel, body
            channel.basic_ack(delivery_tag=method.delivery_tag)

        def run(self):
            self.mq.basic_consume(self.__dump,
                  queue=conf.queue,
                  no_ack=False)
            self.mq.start_consuming()

    for i in range(2):
        C().start()

    time.sleep(5)

    P().start()

if __name__ == '__main__':
    signal.signal(signal.SIGTERM, signal.SIG_DFL)
    signal.signal(signal.SIGINT, signal.SIG_DFL)

    __test_fanout()
    #__test_mq()
    #__test_conf()

    #import sys
    #produce_or_consume = sys.argv[1]
    #__test_mq_manager(produce_or_consume)

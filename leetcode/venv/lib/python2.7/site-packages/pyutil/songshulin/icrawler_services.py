#!/usr/bin/python2.6
import os, sys, logging, threading
from thrift.transport import TSocket, TTransport
from thrift.protocol import TBinaryProtocol
from pyutil.thrift.transport import TSocketPool
from pyutil.program.icrawler_util import str_dict
from songshulin.icrawler.scheduler import Schedule
from songshulin.icrawler.downloader import Download
from songshulin.icrawler.downloader.ttypes import Req as DownloadReq
from songshulin.icrawler.extractor import Extract
from songshulin.icrawler.extractor.ttypes import Req as ExtractReq
from songshulin.icrawler.processor import Process
from songshulin.icrawler.processor.ttypes import Req as ProcessReq

k_thrift_timeout = 360 * 1000

class ThriftScheduler(threading.local):

    def __init__(self, host, port):
        transport = TSocketPool.TSocketPool(host, port)
        #transport.setTimeout(k_thrift_timeout)
        self.transport = TTransport.TBufferedTransport(transport)
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        self.client = Schedule.Client(self.protocol)
    
    def schedule_tasks(self, index_task, item_tasks=[]):
        for task in [index_task] + item_tasks:
            str_dict(task)
        self.transport.open()
        try:
            ok = self.client.schedule_tasks(index_task, item_tasks)
        finally:
            self.transport.close()
        return ok

    def dispatch_task(self):
        self.transport.open()
        try:
            task = self.client.dispatch_task()
        finally:
            self.transport.close()
        return task

class ThriftDownloader(threading.local):

    def __init__(self, host, port):
        transport = TSocketPool.TSocketPool(host, port)
        #transport.setTimeout(k_thrift_timeout)
        self.transport = TTransport.TBufferedTransport(transport)
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        self.client = Download.Client(self.protocol)

    def download(self, url='', info={}):
        req = DownloadReq(url=url, info=info)
        str_dict(req)
        self.transport.open()
        try:
            rsp = self.client.download(req)
        finally:
            self.transport.close()
        return rsp.status, rsp.body, rsp.message

class ThriftExtractor(threading.local):

    def __init__(self, host, port):
        transport = TSocketPool.TSocketPool(host, port)
        #transport.setTimeout(k_thrift_timeout)
        self.transport = TTransport.TBufferedTransport(transport)
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        self.client = Extract.Client(self.protocol)
    
    def extract(self, body='', info={}):
        req = ExtractReq(body=body, info=info)
        str_dict(req)
        self.transport.open()
        try:
            rsp = self.client.extract(req)
        finally:
            self.transport.close()
        return rsp.status, rsp.results, rsp.message

class ThriftProcessor(threading.local):

    def __init__(self, host, port):
        transport = TSocketPool.TSocketPool(host, port)
        #transport.setTimeout(k_thrift_timeout)
        self.transport = TTransport.TBufferedTransport(transport)
        self.protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
        self.client = Process.Client(self.protocol)
    
    def process(self, type='insert', item={}, info={}):
        req = ProcessReq(type=type, item=item, info=info)
        str_dict(req)
        self.transport.open()
        try:
            rsp = self.client.process(req)
        finally:
            self.transport.close()
        return rsp.status, rsp.message

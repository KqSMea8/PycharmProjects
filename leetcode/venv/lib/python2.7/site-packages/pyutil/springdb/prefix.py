# -*- coding: utf-8 -*-

import functools, time
import redis
import redis.client

import pyutil.program.metrics2 as metrics

class Prefixed(object):

    COMMANDS_KEY_SINGLE = set([
        'exists', 'expire', 'expireat', 'persist', 'move', 'ttl',

        'set', 'setnx', 'setex', 'psetex', 'getset', 'setbit', 'setrange',
        'incr', 'decr', 'incrby', 'decrby', 'incrbyfloat', 'append',
        'get', 'exists', 'bitcount', 'getbit', 'getrange', 'strlen',

        'sadd', 'srem',
        'scard', 'sismember', 'smembers',

        'hset', 'hmset', 'hdel', 'hincrby', 'hincrbyfloat',
        'hget', 'hmget', 'hexists', 'hlen', 'hgetall', 'hkeys', 'hvals',

        'zadd', 'zincrby', 'zrem', 'zremrangebyrank', 'zremrangebyscore',
        'zremrangebylex',
        'zcard', 'zcount', 'zlexcount', 'zscore', 'zrank', 'zrevrank',
        'zrange', 'zrangebyscore', 'zrevrange', 'zrevrangebyscore',

        'lpush', 'lpushx', 'rpush', 'rpushx', 'lpop', 'rpop', 'linsert', 'lset',
        'ltrim',
        'llen', 'lindex', 'lrange',

        'pfadd', 'scanrow', 'xget', 'xset'
    ])
    COMMANDS_KEY_LUA_SCRIPTS = set(['eval', 'evalsha'])
    COMMANDS_KEY_DOUBLE = set([
        'smove', 'brpoplpush',
    ])
    COMMANDS_KEY_ONE_SKIP_ONE = set([
        'mset', 'msetnx',
    ])
    COMMANDS_KEY_ALL = set([
        'del', 'rename', 'renamenx',

        'mget',

        'sdiff', 'sinter', 'sunion' 'sdiffstore', 'sinterstore', 'sunionstore',

        'pfcount', 'pfmerge',
    ])
    COMMANDS_WITH_KEY = COMMANDS_KEY_SINGLE.union(COMMANDS_KEY_DOUBLE) \
                                           .union(COMMANDS_KEY_ONE_SKIP_ONE) \
                                           .union(COMMANDS_KEY_ALL) \
                                           .union(COMMANDS_KEY_LUA_SCRIPTS)
    COMMANDS_NOT_IMPLEMENTED = set([
        'blpop', 'brpop',
        'sort',
    ])
    COMMANDS_WITHOUT_KEY = set([
        'auth', 'flushall', 'flushdb', 'save', 'select', 'shutdown', 'slaveof',
        'bgrewriteaof', 'bgsave', 'watch', 'unwatch',
    ])

    def __init__(self, *args, **kwargs):
        super(Prefixed, self).__init__(*args, **kwargs)
        self.set_response_callback('SCANROW', self.parse_scanrow_response)

    def set_prefix(self, prefix):
        self.prefix = prefix

    def set_supported_commands(self, supported_commands):
        self.supported_commands = supported_commands

    def execute_command(self, *args, **options):
        cmd = args[0].lower()

        if 'supported_commands' in self.__dict__:
            if cmd not in self.supported_commands:
                raise NotImplementedError("cmd '%s' not supported" % cmd)

        if cmd in Prefixed.COMMANDS_WITH_KEY:
            # since the Redis only append the parts of command in to args,
            # we only need to process the args
            args = self._process_key(args)
        elif cmd in Prefixed.COMMANDS_WITHOUT_KEY:
            pass
        else:
            raise NotImplementedError("cmd '%s' not registered in Prefixed"
                                      % cmd)

        #print 'execute_command %s %r' % (cmd, args)
        return super(Prefixed, self).execute_command(*args, **options)

    def parse_scanrow_response(self, response, **options):
        if len(response) & 1 != 0:
            raise ValueError('SCANROW expects even number of responses')
        kvs = []
        prefix_len = len(self.prefix)
        for i in xrange(0, len(response), 2):
            k, v = response[i], response[i + 1]
            if not k.startswith(self.prefix):
                raise ValueError('Invalid key({}) returned for prefix({})'.format(k, self.prefix))
            kvs.append((k[prefix_len:], v))
        return kvs

    def scanrow(self, row, limit=0, offset=0, target=None):
        if target is None:
            target = ""
        else:
            target = self.prefix + target
        return self.execute_command('SCANROW', row, str(limit), str(offset), target)

    def xget(self, key):
        """
        返回两个元素的tuple, value(str)和generation(long), 当元素不存在时返回nil, -1
        """
        return tuple(self.execute_command('XGET', key))

    def xset(self, key, value, generation, ex=None, px=None):
        """
        传入的generation为0表示强制插入，-1表示如果不存在才插入，
        其他表示传入的generation匹配db中对应值的generation才插入.
        返回三个元素的tuple, 是否成功(bool), value(str)和generation(long).
        当成功时返回True, nil 和刚set进去的值的generation.
        当因为generation不匹配而失败时返回False, db中的当前值和db中当前值的generation.
        当因为元素不存在而失败时返回False, nil 和 -1.
        """
        value = str(value)
        generation = str(generation)
        if ex is not None:
            result = self.execute_command('XSET', key, value, generation, 'EX', str(ex))
        elif px is not None:
            result = self.execute_command('XSET', key, value, generation, 'PX', str(px))
        else:
            result = self.execute_command('XSET', key, value, generation)
        return bool(result[0]), result[1], result[2]

    def _process_key(self, args):
        # be atttention that cmd in redis.Redis use UPPER case
        cmd = args[0].lower()
        results = []
        results.append(args[0]) # must be upper case

        # some commands is allowed to pass multiple keys. i.e. del, mget
        if cmd in Prefixed.COMMANDS_KEY_SINGLE:
            idx = 0
            for arg in args:
                if idx == 0: # skip cmd
                    pass
                elif idx == 1: # only process key
                    results.append(self.prefix + arg)
                else:
                    results.append(arg)
                idx += 1
        elif cmd in Prefixed.COMMANDS_KEY_DOUBLE: # not tested
            idx = 0
            for arg in args:
                if idx == 0: # skip cmd
                    pass
                elif idx == 1 or idx == 2:
                    results.append(self.prefix + arg)
                else:
                    results.append(arg)
                idx += 1
        elif cmd in Prefixed.COMMANDS_KEY_ONE_SKIP_ONE: # not tested
            idx = 0
            for arg in args:
                if idx == 0: # skip cmd
                    pass
                elif idx % 2 == 1:
                    results.append(self.prefix + arg)
                else:
                    results.append(arg)
                idx += 1
        elif cmd in Prefixed.COMMANDS_KEY_ALL:
            idx = 0
            for arg in args:
                if idx == 0: # skip cmd
                    pass
                else:
                    if isinstance(arg, list):
                        for a in arg:
                            results.append(self.prefix + a)
                    else:
                        results.append(self.prefix + arg)
                idx += 1
        elif cmd in Prefixed.COMMANDS_KEY_LUA_SCRIPTS:
            idx = 0
            for arg in args:
                if idx == 0:
                    pass
                elif idx == 3:
                    results.append(self.prefix + arg)
                else:
                    results.append(arg)
                idx += 1
        else:
            raise NotImplementedError("cmd '%s' not Implemented in Prefixed"
                                      % cmd)
        return tuple(results)

class PrefixedBasePipeline(Prefixed, redis.client.BasePipeline):
    def set_stats_callback(self, cb):
        self.stats_callback = cb

    def execute(self, raise_on_error=True):
        result = None
        ts = time.time()
        saved_cmds = self.command_stack
        batch_num = len(self.command_stack)
        try:
            result = super(PrefixedBasePipeline, self).execute(raise_on_error)
        except:
            latency = time.time() - ts
            if 'stats_callback' in self.__dict__:
                self.stats_callback(latency, batch_num, False, saved_cmds)
            raise
        finally:
            latency = time.time() - ts
            if 'stats_callback' in self.__dict__:
                self.stats_callback(latency, batch_num, True, saved_cmds)
        return result

class PrefixedStrictPipeline(PrefixedBasePipeline, redis.StrictRedis):
    ''' this style is following StrictPipeline in redis/client.py '''
    pass

class PrefixedPipeline(PrefixedBasePipeline, redis.Redis):
    ''' this style is following Pipeline in redis/client.py '''
    pass

class PrefixedStrictRedis(Prefixed, redis.StrictRedis):
    def pipeline(self, transaction=True, shard_hint=None):
        p = PrefixedStrictPipeline(
            self.connection_pool,
            self.response_callbacks,
            transaction,
            shard_hint)
        p.set_prefix(self.prefix)
        if 'supported_commands' in self.__dict__:
            p.set_supported_commands(self.supported_commands)
        return p

class PrefixedRedis(Prefixed, redis.Redis):
    def pipeline(self, transaction=True, shard_hint=None):
        p = PrefixedPipeline(
            self.connection_pool,
            self.response_callbacks,
            transaction,
            shard_hint)
        p.set_prefix(self.prefix)
        if 'supported_commands' in self.__dict__:
            p.set_supported_commands(self.supported_commands)
        return p

if __name__ == '__main__':
    r = PrefixedRedis('localhost', 6379)
    r.set_prefix('[a]')
    print r.delete('a', 'b')
    print r.set('a', 'a')
    print r.getset('a', 'b')

    p = r.pipeline()
    p.mget('a', 'b')
    p.expire('a', 10)
    print p.execute()


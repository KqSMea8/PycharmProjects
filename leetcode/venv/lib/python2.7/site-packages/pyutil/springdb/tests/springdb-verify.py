#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse, logging, time, sys, math, random, hashlib, signal, string
from pyutil.springdb.client import SpringDBClient

def hash_val(data, salt=''):
    return hashlib.md5(str(data)+str(salt)).hexdigest()

g_stoping = False
def sig_handler(signum, frame):
    global g_stoping
    print 'caught sig %d' % (signum)
    g_stoping = True

UPDATE_CASE_LIST = [
    'set', # TODO incr, append ?
    'zadd',
    'hset',
    'lpush',
]

CHECK_CASE_LIST = [
    'get',
    'zrangebyscore', 'zcard',
    'hgetall', 'hlen',
    'lrange', 'llen',
]

class Worker(object):
    def __init__(self, args):
        self.args = args

        SpringDBClient.set_zone(args.zone)

        self.update_dbs = []
        self.update_servers = args.update_servers.split(',')
        for server in self.update_servers:
            self.update_dbs.append(SpringDBClient([server], args.table, args.socket_timeout))
        self.check_dbs = []
        self.check_servers = args.check_servers.split(',')
        for server in self.check_servers:
            self.check_dbs.append(SpringDBClient([server], args.table, args.socket_timeout))

        self.key_prefix = {
            'v': 'v|',
            'z': 'z|',
            'h': 'h|',
            'l': 'l|',
        }
        
        self.score_base = pow(10, self.args.score_digits - 1)

        self.error_count = 0

    def run(self, case_name, *args, **kwargs):
        case = getattr(self, case_name)
        return case(*args, **kwargs)

    def do_gen_key(self, seq, length, prefix=''):
        if self.args.random_key:
            base = hash_val(seq, self.args.random_key_salt)
            result = '%s{%s}' % (prefix, base)
            while len(result) < length:
                result += base
            if len(result) > length:
                result = result[:length]
            return result
        else:
            seq = '{%s}' % seq
            zero_len = length - len(prefix) - len(seq)
            return prefix + ('0' * zero_len) + seq

    def gen_key(self, data_type, seq):
        return self.do_gen_key(seq, self.args.key_len, self.key_prefix[data_type])

    def gen_sub_key(self, seq):
        return self.do_gen_key(seq, self.args.sub_key_len)

    def do_gen_value(self):
        num = self.args.value_len
        return ''.join(random.choice(string.ascii_uppercase) for _ in range(num))

    def gen_value(self):
        return self.do_gen_value()

    def gen_score(self):
        return random.randint(0, self.args.score_range) + self.score_base

    def max_score(self):
        return self.score_base + self.args.score_range

    def gen_zrange_score_range(self):
        # score_range * 8 / 10 : avoid to hit the end of range
        score_min = random.randint(0, self.args.score_range * 8 / 10) + self.score_base
        score_max = score_min + self.args.access_score_range
        return (score_min, score_max)

    #def gen_zrange_offset(self):
        #if self.args.value_num - self.args.access_limit <= 0:
            #return 0
        #else:
            #return random.randint(0, self.args.value_num - self.args.access_limit)

    def update(self, case_name, check_fun, check_args, update_fun, update_args):
        if self.check('pre_check ' + case_name, check_fun, check_args) == False:
            logging.error('check failed before %s. args %r' % (case_name, check_args))

        for sidx in xrange(len(self.update_dbs)):
            db = self.update_dbs[sidx]
            server = self.update_servers[sidx]

            retry = 0
            while True:
                if update_fun(db, *update_args) == True:
                    logging.debug('%s ok. server %s args %r' % (
                                  case_name, server, update_args))
                    break
                retry += 1
                if retry > self.args.retry_limit:
                    logging.error('%s failed. server %s args %r' % (
                                  case_name, server, update_args))
                    break
                time.sleep(self.args.retry_sleep)

        if self.check('post_check ' + case_name, check_fun, check_args) == False:
            logging.error('check failed after %s. args %r' % (case_name, check_args))

    def check(self, case_name, check_fun, check_args, error_log=True):
        results = []
        for sidx in xrange(len(self.check_dbs)):
            db = self.check_dbs[sidx]
            server = self.check_servers[sidx]

            results.append(check_fun(db, *check_args))

        all_equal = True
        first = results[0]
        for next in results[1:]:
            if first != next:
                all_equal = False
                break
        if all_equal:
            logging.debug('%s all equal. %r %r' % (case_name, check_args, results[0]))
            return True
        else:
            if error_log:
                logging.error('%s not equal. %r %r' % (case_name, check_args, results))
            else:
                logging.debug('%s not equal. %r %r' % (case_name, check_args, results))
            return False

    def do_set(self, db, key, value):
        try:
            ret = db.set(key, value)
            return True
        except Exception, ex:
            logging.exception(ex)
            return False

    def set(self):
        seq = random.randint(0, self.args.key_space)
        key = self.gen_key('v', seq)
        value = self.gen_value()

        self.update('set', self.do_get, (key,), self.do_set, (key, value))

    def do_get(self, db, key):
        try:
            return db.get(key)
        except Exception, ex:
            logging.exception(ex)
            return False

    def get(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('v', seq)

        result = self.check('get', self.do_get, (key,), error_log)
        return result, key

    
    def do_zadd(self, db, key, value, score):
        try:
            ret = db.zadd(key, value, score)
            return True
        except Exception, ex:
            logging.exception(ex)
            return False

    def zadd(self):
        seq = random.randint(0, self.args.key_space)
        key = self.gen_key('z', seq)
        value = self.gen_value()
        score = self.gen_score()

        self.update('zadd', self.do_zrangebyscore, (key,), self.do_zadd, (key, value, score))

    def do_zrangebyscore(self, db, key):
        try:
            return db.zrangebyscore(key, 0, self.max_score(), withscores=True)
        except Exception, ex:
            logging.exception(ex)
            return False

    def zrangebyscore(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('z', seq)

        result = self.check('zrangebyscore', self.do_zrangebyscore, (key,), error_log)
        return result, key

    def do_zcard(self, db, key):
        try:
            return db.zcard(key)
        except Exception, ex:
            logging.exception(ex)
            return False

    def zcard(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('z', seq)

        result = self.check('zcard', self.do_zcard, (key,), error_log)
        return result, key


    def do_hset(self, db, key, sub_key, value):
        try:
            ret = db.hset(key, sub_key, value)
            return True
        except Exception, ex:
            logging.exception(ex)
            return False

    def hset(self):
        seq = random.randint(0, self.args.key_space)
        key = self.gen_key('h', seq)
        sub_seq = random.randint(0, self.args.value_num)
        sub_key = self.gen_sub_key(sub_seq)
        value = self.gen_value()

        self.update('hset', self.do_hgetall, (key,), self.do_hset, (key, sub_key, value))

    def do_hgetall(self, db, key):
        try:
            return db.hgetall(key)
        except Exception, ex:
            logging.exception(ex)
            return False

    def hgetall(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('h', seq)

        result = self.check('hgetall', self.do_hgetall, (key,), error_log)
        return result, key

    def do_hlen(self, db, key):
        try:
            return db.hlen(key)
        except Exception, ex:
            logging.exception(ex)
            return False

    def hlen(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('h', seq)

        result = self.check('hlen', self.do_hlen, (key,), error_log)
        return result, key


    def do_lpush(self, db, key, value):
        try:
            ret = db.lpush(key, value)
            return True
        except Exception, ex:
            logging.exception(ex)
            return False

    def lpush(self):
        seq = random.randint(0, self.args.key_space)
        key = self.gen_key('l', seq)
        value = self.gen_value()

        self.update('lpush', self.do_lrange, (key,), self.do_lpush, (key, value))

    def do_lrange(self, db, key):
        try:
            return db.lrange(key, 0, -1)
        except Exception, ex:
            logging.exception(ex)
            return False

    def lrange(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('l', seq)

        result = self.check('lrange', self.do_lrange, (key,), error_log)
        return result, key

    def do_llen(self, db, key):
        try:
            return db.llen(key)
        except Exception, ex:
            logging.exception(ex)
            return False

    def llen(self, key=None, error_log=True):
        if key is None:
            seq = random.randint(0, self.args.key_space)
            key = self.gen_key('l', seq)

        result = self.check('llen', self.do_llen, (key,), error_log)
        return result, key


class Updater(object):
    def __init__(self, args):
        self.args = args
        self.worker = Worker(args)

    def run(self):
        global g_stoping

        idx = 0
        while self.args.loop == 0 or idx < self.args.loop:
            case_name = UPDATE_CASE_LIST[random.randint(0, len(UPDATE_CASE_LIST) - 1)]
            self.worker.run(case_name)

            idx += 1
            if g_stoping:
                break

class Checker(object):
    def __init__(self, args):
        self.args = args
        self.worker = Worker(args)

        self.last_check_suspect_time = time.time()
        self.suspect = []

    def check_random_case(self):
        case_name = CHECK_CASE_LIST[random.randint(0, len(CHECK_CASE_LIST) - 1)]
        result, key = self.worker.run(case_name, error_log=False)
        if result == False:
            self.suspect.append((key, case_name))

    def check_suspect(self):
        still_suspect = []

        for key, case_name in self.suspect:
            result, _ = self.worker.run(case_name, key, error_log=True)
            if result == False:
                logging.error('still suspect, key %s case %s', key, case_name)
                still_suspect.append((key, case_name))
            else:
                logging.info('not suspect any more, key %s case %s', key, case_name)

        self.suspect = still_suspect

    def run_random(self):
        global g_stoping

        idx = 0
        while self.args.loop == 0 or idx < self.args.loop:
            if time.time() - self.last_check_suspect_time > 10:
                self.check_suspect()
                self.last_check_suspect_time = time.time()

            self.check_random_case()

            idx += 1
            if g_stoping:
                break

        # check suspect infinite
        while self.suspect:
            logging.debug('sleep a while before check suspect')
            time.sleep(3)
            self.check_suspect()

    def run_with_source(self):
        global g_stoping

        suspect = []

        key_source = open(self.args.key_source_file)
        while not g_stoping:
            line = key_source.readline()
            if not line:
                break

            line = line.strip()
            parts = line.split(' ')
            if len(parts) != 2:
                logging.error('invalid line: %s' % line)
                continue
            key, case_name = parts

            result, _ = self.worker.run(case_name, key, error_log=True)
            if result == False:
                logging.info('suspect in first scan, key %s case %s', key, case_name)
                suspect.append((key, case_name))

        self.suspect = suspect

        while not g_stoping:
            if time.time() - self.last_check_suspect_time > 10:
                self.check_suspect()
                self.last_check_suspect_time = time.time()
            else:
                time.sleep(1)

            if not self.suspect:
                logging.info('suspect is empty')
                break

        logging.info('check finished')

    def run(self):
        if self.args.key_source_file:
            self.run_with_source()
        else:
            self.run_random()

def parse_args():
    parser = argparse.ArgumentParser(description='springdb data verification tool')

    parser.add_argument('--verbose', action='store_true', default=False,
                        help='print debug info')

    group = parser.add_argument_group('springdb client init')
    group.add_argument('--update-servers', type=str, default=None, required=False,
                       help='springdb servers to update. ' \
                       'i.e. 127.0.0.1:11211,127.0.0.1:11311')
    group.add_argument('--check-servers', type=str, default=None, required=False,
                       help='springdb servers to check. ' \
                       'i.e. 127.0.0.1:11211,127.0.0.1:11311')
    group.add_argument('--table', type=str, default='sandbox',
                       help='springdb table name')
    group.add_argument('--socket-timeout', type=float, default=5.0,
                       help='socket timeout')
    group.add_argument('--zone', type=str, default='auto',
                       help='springdb conf zone name. i.e. auto, online, offline, test')

    group = parser.add_argument_group('data settings')
    group.add_argument('--random-key', action='store_true', default=False,
                        help='use random key')
    group.add_argument('--key-len', type=int, default=24,
                       help='(all) length for key')
    group.add_argument('--value-len', type=int, default=64,
                       help='(all) length for value')
    group.add_argument('--sub-key-len', type=int, default=16,
                       help='(hash) length for sub key')
    group.add_argument('--score-digits', type=int, default=10, choices=xrange(5, 19),
                       help='(zset) digits number for score, effects the length')
    group.add_argument('--score-range', type=int, default=10240,
                       help='(zset) score range for score')
    group.add_argument('--value-num', type=int, default=64,
                       help='(hash/lish/zset) value number')
    group.add_argument('--random-key-salt', type=str, default='',
                       help='(all) salt to generate random key')
    group.add_argument('--key-space', type=int, default=10240,
                       help='(all) how many different keys')
    group.add_argument('--key-source-file', type=str, default='',
                       help='key source file for check')

    group = parser.add_argument_group('running settings')
    group.add_argument('--mode', type=str, default='update', choices=['update', 'check'],
                       help='update or check')
    group.add_argument('--loop', type=int, default=1000,
                       help='loop number of all cases, 0 means infinite')
    group.add_argument('--retry-limit', type=int, default=10000,
                       help='retry limit')
    group.add_argument('--retry-sleep', type=float, default=1,
                       help='sleep time before retry')
    group.add_argument('--error-limit', type=int, default=100,
                       help='exit if hit error limit, 0 for no limit')

    group = parser.add_argument_group('case settings')
    group.add_argument('-c', '--case', default='',
                       help='test case name, empty to run all tests')
    group.add_argument('--access-score-range', type=int, default=10240,
                       help='(zset) score range for zrange')
    group.add_argument('--access-limit', type=int, default=100,
                       help='(zset) limit for zrange')
    group.add_argument('--batch-num', type=int, default=16,
                       help='(kv/hash) batch for mget/hmget/hmset etc')

    args = parser.parse_args()

    if not args.update_servers and not args.check_servers:
        print 'you should specify update-servers of check-servers'
        sys.exit(-1)

    if not args.check_servers:
        args.check_servers = args.update_servers
    if not args.update_servers:
        args.update_servers = args.check_servers

    FORMAT = '%(asctime)s %(process)d %(levelname)s %(message)s'
    logging.basicConfig(format=FORMAT)
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    else:
        logging.getLogger().setLevel(logging.INFO)

    return (parser, args)

def main():
    parser, args = parse_args()

    signal.signal(signal.SIGALRM, sig_handler)
    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    if args.mode == 'update':
        updater = Updater(args)
        updater.run()
    if args.mode == 'check':
        checker = Checker(args)
        checker.run()

if __name__ == '__main__':
    main()

#!/usr/bin/env python
# -*- coding: utf-8 -*-
import unittest
import time, string, random, logging, sys, os, subprocess
from pyutil.springdb import SpringDBClient
from pyutil.springdb.prefix import PrefixedRedis
import pyutil.twemproxy as twemproxy
import redis

MANUAL_MASTERS = ['127.0.0.1:5390']
MANUAL_SLAVES = ['127.0.0.1:5390']
AUTO_BACKEND_ERROR = ['127.0.0.1:5396']
AUTO_BACKEND_TIMEOUT = ['127.0.0.1:5397']
AUTO_MASTERS = ['127.0.0.1:5398']
AUTO_SLAVES = ['127.0.0.1:5399']

AUTO = True # setup environment automaticly
BACKEND_ERROR_SERVERS = AUTO_BACKEND_ERROR
BACKEND_TIMEOUT_SERVERS = AUTO_BACKEND_TIMEOUT
MASTER_SERVERS = AUTO_MASTERS
SLAVE_SERVERS = AUTO_SLAVES

TABLE = 'unittest'

class TestBasic(unittest.TestCase):
    def setUp(self):
        self.db = SpringDBClient(MASTER_SERVERS, TABLE)

    def test_kv(self):
        k = rand_str()
        v = rand_str()
        v2 = rand_str()

        self.db.delete(k) # clean up

        self.assertEqual(self.db.exists(k), 0)

        self.assertEqual(self.db.set(k, v), 1)
        self.assertEqual(self.db.get(k), v)
        self.assertEqual(self.db.exists(k), 1)

        self.assertEqual(self.db.setnx(k, v), 0)

        self.assertEqual(self.db.getset(k, v2), v)
        self.assertEqual(self.db.get(k), v2)

        self.assertEqual(self.db.delete(k), 1)
        self.assertEqual(self.db.get(k), None)

        self.assertEqual(self.db.set(k, 1), 1)
        self.assertEqual(self.db.incr(k), 2)
        self.assertEqual(self.db.decr(k), 1)
        #self.assertEqual(self.db.incrby(k, 10), 11)
        #self.assertEqual(self.db.decrby(k, 2), 9)

        # call using argument name
        self.assertEqual(self.db.delete(k), 1) # no argument name
        self.assertEqual(self.db.get(name=k), None)

        self.assertEqual(self.db.set(name=k, value=1), 1)
        self.assertEqual(self.db.incr(name=k), 2)
        self.assertEqual(self.db.decr(name=k), 1)

    def test_kv_bin(self):
        k = rand_str()
        v = rand_bin(128)
        v2 = rand_bin(64)

        self.db.delete(k) # clean up

        self.assertEqual(self.db.exists(k), 0)

        self.assertEqual(self.db.set(k, v), 1)
        self.assertEqual(self.db.get(k), v)
        self.assertEqual(self.db.exists(k), 1)

        self.assertEqual(self.db.setnx(k, v), 0)

        self.assertEqual(self.db.getset(k, v2), v)
        self.assertEqual(self.db.get(k), v2)

        self.assertEqual(self.db.delete(k), 1)
        self.assertEqual(self.db.get(k), None)

    def test_kv_multi(self):
        key_num = 32
        kv_pair = gen_kv_pair(key_num)

        #self.assertEqual(self.db.mset(kv_pair), 1)
        for k, v in kv_pair.items():
            self.assertEqual(self.db.set(k, v), 1)

        self.assertEqual(self.db.mget(kv_pair.keys()), kv_pair.values())

        self.assertEqual(self.db.delete(*tuple(kv_pair.keys())), key_num)
        self.assertEqual(self.db.mget(kv_pair.keys()), [None]*len(kv_pair.keys()))

        # call using argument name
        self.assertEqual(self.db.mget(keys=kv_pair.keys()), [None]*len(kv_pair.keys()))

    def test_append(self):
        k = rand_str()
        v = rand_bin(128)
        v2 = rand_bin(64)
        final = v + v2;

        self.db.delete(k) # clean up

        self.assertEqual(self.db.exists(k), 0)

        self.assertEqual(self.db.append(k, v), len(v))
        self.assertEqual(self.db.get(k), v)

        self.assertEqual(self.db.append(k, v2), len(final))
        self.assertEqual(self.db.get(k), final)

    def test_zset(self):
        k = rand_str()
        #member_pair = gen_member_pair()

        self.db.delete(k) # clean up
        
        self.assertEqual(self.db.zadd(k, 'm1', 1), 1)
        self.assertEqual(self.db.zadd(k, 'm2', 3, 'm3', 5, 'm4', 7), 3)
        self.assertEqual(self.db.zadd(k, 'm2', 2, 'm3', 3, 'm4', 4), 0)
        self.assertEqual(self.db.zadd(k, 'm5', 10, 'm6', 11, 'm7', 12), 3)
        self.assertEqual(self.db.zadd(k, 'm8', 1, 'm9', 2), 2)

        # result: m1, m8, m2, m9, m3, m4, m5, m6, m7

        self.assertEqual(self.db.zcard(k), 9)
        self.assertEqual(self.db.zcount(k, -100, 100), 9)
        self.assertEqual(self.db.zcount(k, 4, 10), 2)
        self.assertEqual(self.db.zscore(k, 'm2'), 2)
        self.assertEqual(self.db.zrank(k, 'm3'), 4)
        self.assertEqual(self.db.zrevrank(k, 'm2'), 6)
        self.assertEqual(self.db.zrange(k, 0, 0), ['m1'])
        self.assertEqual(self.db.zrange(k, 0, -1), ['m1', 'm8', 'm2', 'm9', 'm3', 'm4', 'm5', 'm6', 'm7'])
        self.assertEqual(self.db.zrangebyscore(k, 3, 5), ['m3', 'm4'])
        self.assertEqual(self.db.zrangebyscore(k, 3, 5, 0, 1), ['m3'])
        self.assertEqual(self.db.zrangebyscore(k, 3, 5, withscores=True), [('m3', 3), ('m4', 4)])
        self.assertEqual(self.db.zrevrange(k, 0, 2), ['m7', 'm6', 'm5'])
        self.assertEqual(self.db.zrevrangebyscore(k, 100, 200), [])

        self.assertEqual(self.db.delete(k), 9)
        self.assertEqual(self.db.zrange(k, 0, -1), [])
        self.assertEqual(self.db.delete(k), 0)

    def test_hash(self):
        k = rand_str()
        member_pair = gen_member_pair()

        self.assertEqual(self.db.hmset(k, member_pair), True)

    def test_table_alias(self):
        #SpringDBClient.set_zone('online')
        SpringDBClient.set_zone('/home/lizhe/dev/bytedance/ss_conf/ss')
        db1 = SpringDBClient('springdb_profile2_readonly', 'sandbox')

    def test_zone(self):
        #SpringDBClient.set_zone('test')
        SpringDBClient.set_zone('/home/lizhe/dev/bytedance/ss_conf/ss_test')
        db1 = SpringDBClient('springdb_web_dongtai', 'sandbox')

        SpringDBClient.set_zone('online')
        db2 = SpringDBClient('springdb_web_dongtai', 'sandbox')

        self.assertNotEqual(db1.servers, db2.servers)

class TestExt(unittest.TestCase):
    def setUp(self):
        self.db = SpringDBClient(MASTER_SERVERS, TABLE)
        self.slave = SpringDBClient(SLAVE_SERVERS, TABLE)

    def test_kv(self):
        k = rand_str()
        v = rand_str()

        self.assertEqual(self.db.set(k, v), 1)
        self.assertEqual(self.db.get(k), v)
        time.sleep(1)
        self.assertEqual(self.slave.get(k), v)

    def test_kv_expire(self):
        k = rand_str()
        v = rand_str()

        self.assertEqual(self.db.setex(k, v, 1), 1)
        self.assertEqual(self.db.get(k), v)
        time.sleep(0.8)
        self.assertEqual(self.slave.get(k), v)

        time.sleep(1.1)
        self.assertEqual(self.db.get(k), None)
        time.sleep(0.8)
        self.assertEqual(self.slave.get(k), None)

        self.assertEqual(self.db.set(k, v), 1)
        self.assertEqual(self.db.get(k), v)
        self.assertEqual(self.db.expire(k, 2), 1)
        time.sleep(2.1)
        self.assertEqual(self.db.get(k), None)

    def test_zset_expire(self):
        k = rand_str()

        self.db.delete(k) # clean up
        
        self.assertEqual(self.db.zadd(k, 'm1', 1), 1)
        self.assertEqual(self.db.zadd(k, 'm2', 3, 'm3', 5, 'm4', 7), 3)
        self.assertEqual(self.db.expire(k, 1), 1)

        time.sleep(1.1)
        self.assertEqual(self.db.zrange(k, 0, -1), [])
        time.sleep(0.8)
        self.assertEqual(self.slave.zrange(k, 0, -1), [])

class TestPrefix(unittest.TestCase):
    def setUp(self):
        self.db1 = SpringDBClient(MASTER_SERVERS, TABLE)

        pool = twemproxy.RandomRedisConnectionPool(MASTER_SERVERS)
        self.db2 = redis.Redis(connection_pool=pool)
        self.prefix = '[%s]' % TABLE

        self.db3 = PrefixedRedis(connection_pool=pool)
        self.db3.set_prefix(self.prefix)

    def test_kv(self):
        k = rand_str()
        v = rand_str(64)

        # cleanup
        self.db2.delete(k)
        self.db2.delete(self.prefix + k)
        self.db3.delete(k)

        self.assertEqual(self.db1.set(k, v), True)

        self.assertEqual(self.db2.get(self.prefix + k), v)
        self.assertEqual(self.db2.exists(self.prefix + k), True)

        self.assertEqual(self.db3.get(k), v)
        self.assertEqual(self.db3.exists(k), True)

    def test_kv_multi(self):
        key_num = 16
        kv_pair = gen_kv_pair(key_num)

        # cleanup
        self.db1.delete(kv_pair.keys())
        self.db2.delete([self.prefix + k for k in kv_pair.keys()])
        self.db3.delete(kv_pair.keys())

        for k, v in kv_pair.items():
            self.assertEqual(self.db2.set(self.prefix + k, v), True)

        self.assertEqual(self.db1.mget(kv_pair.keys()), kv_pair.values())
        self.assertEqual(self.db3.mget(kv_pair.keys()), kv_pair.values())

        self.assertEqual(self.db1.delete(*tuple(kv_pair.keys())), key_num)

    def test_list(self):
        k = rand_str()

        # cleanup
        self.db1.delete(k)
        self.db2.delete(self.prefix + k)
        self.db3.delete(k)

        self.assertEqual(self.db1.llen(k), 0)
        self.assertEqual(self.db2.llen(k), 0)
        self.assertEqual(self.db3.llen(k), 0)

        self.assertEqual(self.db1.lpush(k, 'a'), True)

        self.assertEqual(self.db1.llen(k), 1)
        self.assertEqual(self.db2.llen(self.prefix + k), 1)
        self.assertEqual(self.db3.llen(k), 1)

class TestFailure(unittest.TestCase):

    #TODO add read timeout and connect fail

    def test_connect_timeout(self):
        def do_test(timeout):
            # pyredis retry one more time if failed.
            # refer:
            #   redis/client.py: StrictRedis.execute_command
            #   redis/connection.py: Connection.__init__
            expected_timeout = timeout * 2

            ts = time.time()
            with self.assertRaises(Exception): db.set('a', 'a')
            cost = time.time() - ts
            self.assertGreater(cost, expected_timeout)
            self.assertLess(cost, expected_timeout * 1.2)

        # should use default timeout
        db = SpringDBClient(['192.168.100.100:5555'], TABLE)
        do_test(0.1) # our default connect timeout

        timeouts = [0.01, 0.1, 0.8]
        for timeout in timeouts:
            db = SpringDBClient(['192.168.100.100:5555'], TABLE,
                                socket_connect_timeout=timeout)
            do_test(timeout)

    def test_read_timeout(self):
        def do_test(timeout):
            expected_timeout = timeout

            ts = time.time()
            with self.assertRaises(Exception): db.set('a', 'a')
            cost = time.time() - ts
            self.assertGreater(cost, expected_timeout)
            self.assertLess(cost, expected_timeout * 1.2)

        # should use default timeout
        db = SpringDBClient(BACKEND_TIMEOUT_SERVERS, TABLE)
        do_test(0.25) # our default timeout

        timeouts = [0.01, 0.1, 0.8]
        for timeout in timeouts:
            db = SpringDBClient(BACKEND_TIMEOUT_SERVERS, TABLE,
                                socket_timeout=timeout)
            do_test(timeout)

    def test_read_error(self):
        def do_test():
            ts = time.time()
            with self.assertRaises(Exception): db.set('a', 'a')
            cost = time.time() - ts
            self.assertLess(cost, 0.01)

        db = SpringDBClient(BACKEND_ERROR_SERVERS, TABLE)
        do_test()

        timeouts = [0.01, 0.1, 0.8]
        for timeout in timeouts:
            db = SpringDBClient(BACKEND_ERROR_SERVERS, TABLE,
                                socket_timeout=timeout)
            do_test()

class TestPipeline(unittest.TestCase):
    def setUp(self):
        self.db = SpringDBClient(MASTER_SERVERS, TABLE)

    def test_basic(self):
        k = rand_str()
        v = rand_str()
        v2 = rand_str()

        self.assertEqual(self.db.set(k, v), True)

        p = self.db.pipeline()
        p.get(k)
        p.expire(k, 100)
        p.getset(k, v2);
        self.assertEqual(p.execute(), [v, True, v])

    def test_setex(self):
        k = rand_str()
        v = rand_str()
        p = self.db.pipeline()
        p.setex(k, v, 1)
        p.get(k)
        self.assertEqual(p.execute(), [True, v])

        time.sleep(1.1)
        self.assertEqual(self.db.get(k), None)

    def test_metrics(self):
        k = rand_str()

        p = self.db.pipeline()
        p.set(k, 1)
        p.incrby(k, 1)
        self.assertEqual(p.execute(), [True, 2])

    def test_failure(self):
        k = rand_str()
        v = rand_str()
        v2 = rand_str()

        self.assertEqual(self.db.set(k, v), True)

        #TODO test failure in the milldle of pipeline
        # springdb will not return error for wrong type, so we skip this test here
        #p = self.db.pipeline()
        #p.get(k)
        #p.llen(k) # error
        #p.getset(k, v2);
        #with self.assertRaises(redis.RedisError):
            #p.execute()

    def test_misuse(self):
        k = rand_str()
        v = rand_str()

        p = self.db.pipeline()
        p.setex(k, v, 1)
        p.get(k)
        self.assertEqual(p.execute(), [True, v])

        p.get(k)
        self.assertEqual(p.execute(), [v])

#TODO add make value binary and add \0

def rand_str(n=10, prefix=''):
    if prefix != '':
        prefix = str(prefix) + '_'
    return str(prefix) + ''.join(random.choice(string.ascii_uppercase) for _ in xrange(n))

def rand_bin(n=10):
    result = ''
    zero_idx = random.randint(0, n - 1)
    for i in xrange(n):
        if i == zero_idx:
            result += chr(0)
        else:
            result += chr(random.randint(0, 255))
    return result
    #result = ''.join(chr(random.randint(0, 255)) for _ in xrange(n))

seq_i = 0
def gen_seq():
    global seq_i
    seq_i += 1
    return seq_i

def gen_kv_pair(num=16, rand=True):
    if rand:
        return {rand_str(16, i) : rand_str(64, i) for i in xrange(0, num)}
    else:
        return {str(i) : str(i) for i in xrange(0, num)}

def gen_member_pair(num=16, rand=True):
    if rand:
        return {rand_str(16, i) : random.randint(-1024, 1024) for i in xrange(0, num)}
    else:
        return {str(i) : i for i in xrange(0, num)}

def run_cmd(cmd):
    scripts_dir = os.path.dirname(__file__) + '/test_env'
    #print cmd
    p = subprocess.Popen(cmd, shell=True, cwd=scripts_dir, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    #print p.stdout.readlines()
    #print p.stderr.readlines()
    p.wait()

def check_env():
    k = rand_str()
    v = rand_str()
    try:
        db = SpringDBClient(MASTER_SERVERS, TABLE)
        result = db.setex(k, v, 10)
        if not result:
            logging.error('check master %s failed' % MASTER_SERVERS)
            return False
    except Exception, ex:
        logging.exception('check master %s failed' % MASTER_SERVERS)
        return False

    try:
        db = SpringDBClient(SLAVE_SERVERS, TABLE)
        result = db.get(k)
    except Exception, ex:
        logging.exception('check slave %s failed' % SLAVE_SERVERS)
        return False

    return True

if __name__ == '__main__':
    logging.basicConfig(format='%(levelname)s %(message)s')
    logging.getLogger().setLevel(logging.DEBUG)

    # manual: set up springdb and twemproxy manually
    # auto: test script will start springdb and twemproxy automaticly

    if 'manual' in sys.argv:
        AUTO = False
        sys.argv.remove('manual')

    if AUTO:
        logging.info('setup environment ...')
        run_cmd('./springdb-ctrl restart')
        run_cmd('./twemproxy-ctrl restart')
        logging.info('sleep a while before check environment ...')
        time.sleep(0.3)
        logging.info('check environment ...')
        if not check_env():
            logging.error('check environment failed')
            sys.exit(-1)
    unittest.main(exit=False)
    if AUTO:
        logging.info('clean environment ...')
        run_cmd('./twemproxy-ctrl stop')
        run_cmd('./springdb-ctrl stop')


#!/usr/bin/env python
#coding=utf8
from __future__ import print_function
import logging, os, signal, argparse, threading, multiprocessing, time, sys
from thrift.transport import TTransport, TSocket, THttpClient
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer

from pyutil.program.conf import Conf
from pyutil.program.log import init_logging
from pyutil.ss.article.data_conf import ThriftConf

from pyutil.thrift.server.TProcessThreadPoolServer2 import TProcessThreadPoolServer2

DEFAULT_BACKLOG = 128

def multiprocess_exit_signal_handler(sig=None, frame=None):
    signal_names = dict((k, v) for v, k in signal.__dict__.iteritems() if v.startswith('SIG'))
    pid = os.getpid()
    children = multiprocessing.active_children()
    print('[pid=%s] catch signal %s, start to exit, %s children' % (pid, signal_names.get(sig, sig), len(children)), file=sys.stderr)
    while True:
        num_active = len(children)
        if not num_active: break
        for p in children:
            p.terminate()
        time.sleep(.5)
        children = multiprocessing.active_children()
        print('[pid=%s] %s active processes exit, %s children is still alive' % (pid, num_active, len(children)), file=sys.stderr)
    os._exit(0)

def set_exit_signal_handler(for_multiprocess=False, signals=[signal.SIGINT, signal.SIGTERM, signal.SIGHUP]):
    sig_handler = multiprocess_exit_signal_handler if for_multiprocess else signal.SIG_DFL
    for sig in signals:
        signal.signal(sig, sig_handler)

def get_thrift_server(ThriftServiceClass, handler, port,
        thread_num, worker_num=1, max_pending_tasks=0,
        callback=None, post_fork_reload=None, reload_interval=1, backlog=DEFAULT_BACKLOG, **kwargs):
    processor = ThriftServiceClass.Processor(handler)
    transport = TSocket.TServerSocket(port=port, backlog=backlog)
    tfactory = TTransport.TBufferedTransportFactory()
    pfactory = TBinaryProtocol.TBinaryProtocolFactory()
    if worker_num > 1:
        if post_fork_reload and isinstance(post_fork_reload, basestring):
            post_fork_reload = getattr(handler, post_fork_reload)
        server = TProcessThreadPoolServer2(processor, transport, tfactory, pfactory,
                pendingTaskCountMax=max_pending_tasks,
                postForkReload=post_fork_reload,
                reloadInterval=reload_interval,
                **kwargs
                )
        server.setNumWorkers(worker_num)
        server.setPostForkCallback(set_exit_signal_handler if callback is None else callback)
    else:
        server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)
    server.setNumThreads(thread_num)
    return server

def init_thrift_server_main(prog, thrift_name, ThriftServiceClass, HandlerClass,
        conf_file, conf_logging=None, get_handler=None,
        post_init_argparse=None, post_fork_callback=None,
        post_fork_reload=None, reload_interval=1,
        accept_on_idle=True, emit_metrics=True,
        **kwargs
        ):
    '''
    初始化并返回thrift server

    prog - 程序名字, 保持和log_category一致, 如article_extract
    thrift_name - thrift服务的在ThriftConf中的名字, 如aextract. 会ThriftConf会通过此名字找到server的端口
    ThriftServiceClass - thrift服务的class, 如ss.article.article_extract.ArticleExtract
    HandlerClass - handler的class, conf为唯一参数
    get_handler - 获取handler的回调函数, conf为唯一参数. 存在时, 忽略HandlerClass
    conf_file - config file的path
    conf_logging - 打印配置信息的回调函数, conf为唯一参数
    post_init_argparse - 初始化argument parser的回调函数, parser为唯一参数
    post_fork_reload - 周期性调用(reload_interval控制间隔)
    :param bool accept_on_idle: only accept client for worker with idle threads.
    :param bool emit_metrics: emit metrics for pending/running tasks

    配置文件中支持的一些控制server特性的属性

        server_worker_num - server起的worker数(默认为1). 实际进程数为server_worker_num + 1
        server_thread_num - server每个进程起的线程数
        server_max_pending_tasks - server的每个worker接受的最大pending tasks数, 超过此数server会拒绝服务
        server_backlog - the maximum number of queued connections

    另启动server时可加--port参数指定不同的端口

    return - conf, server, extra (dict with keys: args, handler)
    '''

    conf_logging = conf_logging or (lambda x: None)
    get_handler = get_handler or (lambda conf: HandlerClass(conf))
    threading.current_thread().name = 'main'
    parser = argparse.ArgumentParser(description='%s server' % prog)
    parser.add_argument('-c', '--config',
            default=os.path.relpath(conf_file),
            help='config file path, default %(default)s')
    parser.add_argument('--log-file', help='log file, default conf.log_file')
    parser.add_argument('--port', help='server port, default %s' % ThriftConf._get_knames(thrift_name)[1])
    parser.add_argument('--dry-run', action='store_true', help='dry run mode, do no touch db')

    if post_init_argparse:
        post_init_argparse(parser)
    args = parser.parse_args()

    conf = Conf(args.config)
    conf.log_file = args.log_file or conf.log_file
    conf.dry_run = args.dry_run
    print('logging to %s' % conf.log_file)
    init_logging(conf)
    conf_logging(conf)

    # 比较trick, 但TProcessThreadPoolServer2中是用的metrics2
    # 但外部程序初始化的可能是metrics
    from pyutil.program import metrics, metrics2
    if metrics.namespace_prefix:
        metrics2.namespace_prefix = metrics.namespace_prefix

    port = args.port or ThriftConf.thrift_port(conf, thrift_name)
    thread_num = int(conf.server_thread_num)
    worker_num = int(conf.server_worker_num or 1)
    backlog = int(conf.server_backlog or DEFAULT_BACKLOG)
    max_pending_tasks = int(getattr(conf, 'server_max_pending_tasks', 0) or 0)
    handler = get_handler(conf)
    server = get_thrift_server(ThriftServiceClass, handler,
            port=port, thread_num=thread_num, worker_num=worker_num,
            max_pending_tasks=max_pending_tasks,
            callback=post_fork_callback,
            post_fork_reload=post_fork_reload,
            reload_interval=reload_interval,
            accept_on_idle=accept_on_idle,
            emit_metrics=emit_metrics,
            backlog=backlog,
            **kwargs
            )
    set_exit_signal_handler(for_multiprocess=worker_num > 1)

    logging.info('%sserver start on %s with %s processes * %s threads, max_pending_tasks=%s, backlog=%s ...',
            '[dry] ' if args.dry_run else '',
            port, worker_num, thread_num, max_pending_tasks or 'unlimited',
            backlog,
            )
    return conf, server, dict(args=args, handler=handler)

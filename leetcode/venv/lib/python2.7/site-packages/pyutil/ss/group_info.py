from pyutil.cache.cache_class import CacheClass
from datetime import datetime, timedelta
import time
from pyutil.program.db import DAL
from pyutil.cache.cache_manager import get_local_cache
from pyutil.cache.locmem import LocMemCache
from pyutil.city import get_city_name


class GroupInfoCache:
    def __init__(self, conf, is_online=False):
        from pyutil.memcache import MemcacheClient
        self.cache = MemcacheClient(conf.get_values('memcache_group_info'), key_tmpl='article_info_v%s_%s', timeout=900)
        self.version = '3'
        self.groupdb_dal = DAL(host=conf.ss_groupdb_read_host,
                             port=conf.ss_groupdb_read_port,
                             user=conf.ss_groupdb_read_user,
                             passwd=conf.ss_groupdb_read_password,
                             name=conf.ss_groupdb_name)

    def get(self, group_id):
        result = self.get_multi_as_dict([group_id])
        return result.get(group_id)

    def get_multi_as_dict(self, group_ids):
        params = [(self.version, gid) for gid in group_ids]
        values = self.cache.mget(params)
        result = {}
        for (version, gid), value in values.items():
            try:
                parts = value.split(',')
                rate = int(parts[0]) 
                create_time = int(parts[1])
                city = parts[2]
                internal_rate = float(parts[3])
                mixed_rate = float(parts[4])
                actions_score = float(parts[5])
                internal_action_ratio = float(parts[6])
                tag = parts[7]
                category_actions_score = float(parts[8])
                category_action_ratio = float(parts[9]) 

                result[gid] = {'mixed_rate':mixed_rate,
                               'tag':tag,
                               'city':city,
                               'create_time':create_time,
                               'rate':rate,
                               'internal_rate':internal_rate,
                               'actions_score':actions_score,
                               'internal_action_ratio':internal_action_ratio,
                               'category_actions_score':category_actions_score,
                               'category_action_ratio':category_action_ratio}
            except:
                result[gid] = {}

        try:
            fail_gids = [gid for gid in group_ids if gid not in result] 
            if fail_gids:
                result_ = self._get_multi_as_dict(fail_gids)
                result.update(result_)
        except:
            pass

        return result


    def _get_multi_as_dict(self, group_ids):
        self.groupdb_dal.execute('select g.id, g.create_time, t.tag, c.city_id, s.rate, s.internal_rate, s.internal_action_ratio from ss_article_group as g \
                inner join ss_group_city_ref as c on c.group_id=g.id inner join ss_tag as t on t.group_id=g.id \
                inner join ss_group_stats as s on s.id=g.id where g.id in (%s)' % ','.join([str(gid) for gid in group_ids]))
        rows = self.groupdb_dal.cursor.fetchall()
        result = {}
        kv = {}
        for r in rows:
            gid = r['id']
            city = None 
            if r['city_id']>0:
                city = get_city_name(r['city_id'])
                if city:
                    city = city.encode('utf8')

            tag = None
            if r['tag']:
                tag = r['tag'].encode('utf8')

            create_time = int(time.mktime(r['create_time'].timetuple()))

            info = [('rate', r['rate'] or 0),
                ('create_time', create_time),
                ('city', city or ''),
                ('internal_rate', r['internal_rate'] or 0),
                ('mixed_rate', 0),
                ('actions_score',  0),
                ('internal_action_ratio', r['internal_action_ratio'] or 0),
                ('tag', tag or ''),
                ('category_actions_score', 0),
                ('category_action_ratio', 0)]
            v = ','.join([str(i[1]) for i in info])
            kv[(self.version, gid)] = v
            result[gid] = dict(info)
        
        self.cache.mset(kv, timeout=300)
        return result

class GroupTopicCache(CacheClass):

    def __init__(self, conf, min_topic_value=0, timeout=86400, max_entries=100000):
        self.cache = LocMemCache('group_topics', use_lock=False, use_copy=False, 
                params={'timeout':timeout, 'max_entries':max_entries})

        self.recommend_dal = DAL(host=conf.ss_recommend_write_host, 
                          port=conf.ss_recommend_write_port, 
                          user=conf.ss_recommend_write_user, 
                          passwd=conf.ss_recommend_write_password, 
                          name=conf.ss_recommend_name)
        
        self.min_topic_value = min_topic_value 

    def _get_multi_as_dict(self, group_ids):
        group_topic_dist_dict = {}
        sql = 'select group_id, topic_distribution from article_topic_distribution where group_id in (%s)' \
                % ','.join([str(gid) for gid in group_ids])
        self.recommend_dal.execute(sql)
        rows = self.recommend_dal.cursor.fetchall()

        topic_dist_dict = dict([(r['group_id'], r['topic_distribution']) for r in rows])
        for group_id in group_ids:
            group_topic_dist = []
            topic_dist = topic_dist_dict.get(group_id) 
            if topic_dist:
                dists_ = topic_dist.split()
                article_topic_dist = []
                for tid in range(1, len(dists_)+1):
                    weight = float(dists_[tid-1])
                    if weight > self.min_topic_value:
                        group_topic_dist.append((tid, weight))
                #group_topic_dist.sort(key=lambda g:g[1], reverse=True)
            group_topic_dist_dict[group_id] = group_topic_dist
            
        return group_topic_dist_dict
 


if __name__ == '__main__':
    from pyutil.program.conf import Conf
    conf = Conf('/opt/tiger/ss_conf/ss/common.conf')
    cache = GroupInfoCache(conf)
    info = cache.get(2785782638)
    print info
    

#! /bin/env python

'''
A compact impression history designed for dedup.

1. impressions are sharded in fixed-length time windows;
2. ids are sorted and encoded in list deltas, and then packed with msgpack;
3. encoded data is saved in memcache, and springdb in the future;
4. only impression gids are saved, with no more unnecessary fields;
'''

from datetime import datetime, timedelta
import time
import sys
import memcache
import msgpack

class ImpressionHistoryDeduper(object):
    def __init__(self, servers, mc_key_prefix, sharding_interval, expire_time):
        '''
        servers: list of memcached server addrs. e.g. ['127.0.0.1:11911']
        mc_key_prefix: identify apps, e.g. article, essay
        sharding_interval: time window in seconds. e.g. 86400*7 (7 days)
        expire_time: expire time in seconds. e.g. 86400*30 (30 days)
        '''
        self.servers = servers
        self.mc_key_prefix = mc_key_prefix
        self.client = memcache.Client(servers, socket_timeout=0.5)
        self.sharding_interval = sharding_interval
        self.expire_time = expire_time

    def _get_sharding_suffix(self, ts=None):
        if ts:
            dt = datetime.fromtimestamp(ts)
        else:
            dt = datetime.now()
        return int((dt - datetime(1970, 1, 1)).total_seconds() / self.sharding_interval)

    def _make_cache_key(self, ut, uid, channel_id, ts=None):
        key = 'impr_dedup:{prefix}:{ut}:{uid}'.format(prefix=self.mc_key_prefix, ut=ut, uid=uid)
        if channel_id:
            key = '{key}:{chnid}'.format(key=key, chnid=channel_id)
        sharding_suffix = self._get_sharding_suffix(ts)
        key = '{key}:{suffix}'.format(key=key, suffix=sharding_suffix)
        return key

    def _make_cache_keys(self, ut, uid, channel_id, ts_start, ts_end):
        keys = set()
        # interate over each day within the interval
        while ts_start < ts_end:
            keys.add(self._make_cache_key(ut, uid, channel_id, ts_start))
            ts_start += 86400
        return list(keys)

    def _encode_list_delta(self, l):
        result = []
        if len(l) == 0:
            return result
        result.append(l[0])
        for i in xrange(1, len(l)):
            result.append(l[i] - l[i-1])
        return result

    def _decode_list_delta(self, l):
        result = []
        if len(l) == 0:
            return result
        base_id = l[0]
        result.append(base_id)
        for i in l[1:]:
            result.append(result[-1] + i)
        return result

    def _get_impression_list_from_memcache(self, ut, uid, channel_id, keys):
        results = self.client.get_multi(keys)
        impressions = []
        for k,v in results.iteritems():
            ids = msgpack.loads(v)
            ids = self._decode_list_delta(ids)
            impressions.extend(ids)
        return impressions

    def get_impression_list(self, ut, uid, channel_id):
        keys = self._make_cache_keys(ut, uid, channel_id, time.time() - self.expire_time, time.time())
        impressions = self._get_impression_list_from_memcache(ut, uid, channel_id, keys)
        return impressions

    def add(self, ut, uid, channel_id, id_list, ts=None):
        key = self._make_cache_key(ut, uid, channel_id, ts)
        impressions = self._get_impression_list_from_memcache(ut, uid, channel_id, [key,])
        impressions.extend(id_list)
        impressions = sorted(list(set(impressions)))
        impressions_delta = self._encode_list_delta(impressions)
        impressions_delta_encoded = msgpack.dumps(impressions_delta)
        ret = self.client.set(key, impressions_delta_encoded, int(time.time()) + self.expire_time)
        return ret

    def dedup(self, ut, uid, channel_id, id_list, ts_start=None, ts_end=None):
        if not ts_end and not ts_start:
            ts_end = int(time.time())
            ts_start = ts_end - self.expire_time
        keys = self._make_cache_keys(ut, uid, channel_id, time.time() - self.expire_time, time.time())
        impressions = self._get_impression_list_from_memcache(ut, uid, channel_id, keys)
        impressions_set = set(impressions)
        deduped_id_list = []
        for elem in id_list:
            if elem not in impressions_set:
                deduped_id_list.append(elem)
        return deduped_id_list

    def dedup_and_add(self, ut, uid, channel_id, id_list, ts=None):
        deduped_id_list = self.dedup(ut, uid, channel_id, id_list)
        self.add(ut, uid, channel_id, deduped_id_list, ts)

if __name__ == '__main__':
    servers = ['127.0.0.1:11911']
    impr_dedup = ImpressionHistoryDeduper(servers, mc_key_prefix='essay_impr_dedup', sharding_interval=86400*7, expire_time=86400*30)
    impr_dedup.client.flush_all()
    channel_id = 0
    for line in sys.stdin:
        uniq_ids = set()
        ut_uid, req_list = line.strip().split()
        ut_uid = ut_uid.strip('"')
        ut, uid = map(lambda x: int(x), ut_uid.split(':'))
        req_list = eval(req_list.strip('"'))
        cost = 0.0
        for gt, rs in req_list:
            st = time.time()
            deduped_list = impr_dedup.dedup_and_add(ut, uid, channel_id, rs, gt)
            cost += time.time() - st
            uniq_ids.update(rs)
        len1 = len(uniq_ids)
        len2 = len(impr_dedup.get_impression_list(ut, uid, channel_id))
        print ut, uid, len1, len2, cost/len(req_list)
        assert(len1 == len2)


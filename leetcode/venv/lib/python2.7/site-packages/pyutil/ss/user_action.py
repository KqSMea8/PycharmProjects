#!/usr/bin/env python
# coding=utf8
import pdb, json, signal, sys, time, hashlib, math, time
from datetime import datetime, timedelta
from struct import pack, unpack, unpack_from, calcsize
from pyutil.memcache.jenkins import oneatatime
from ss.article.sorter.ttypes import UidType
from pyutil.program.conf import Conf
from ss_lib.ua.utils import OnlineUserActionHandler

class UserActionUtil:
    def __init__(self, conf, prod='article'):
        self.conf = conf
        if prod == 'video':
            springdb_cluster = 'springdb_video_action_read'
            cluster_name = 'memcache_video_user_action_online2'
            self.key_head = 'uav'
        else:
            springdb_cluster = 'abase_action'
            cluster_name = 'memcache_action2'
            self.key_head = 'ua'
        self.cache = OnlineUserActionHandler(
                mc_timeout=0.1,
                springdb_timeout=0.05,
                springdb_cluster=springdb_cluster,
                cluster_name=cluster_name)

    def get_user_actions(self, start_time, end_time, uid_type, uid):
        if uid_type == UidType.OPEN_UDID and isinstance(uid, str):
            return []

        key_tpl2 = "%s:%s:%s:%%s:64" % (self.key_head, uid, uid_type)
        st = int(start_time/86400)
        et = int(end_time/86400)+1
        keys = []
        for t in range(st, et):
            key2 = key_tpl2 % t
            key2_ = key2
            keys.append(key2_)

        kvs = self.cache.mget(keys, retry_num=1)
        partten = '=hqq'
        size = calcsize(partten)
        actions = []
        for key in keys:
            value = kvs.get(key)

            if not value or len(value) < size:
                continue

            offset = 0
            while offset < len(value):
                action_type, group_id, action_time = unpack_from(partten, value, offset)
                if group_id:
                    actions.append((action_type, group_id, action_time))
                offset += size
        return actions


    def get_mulit_user_actions(self, start_time, end_time, users):
        key_tpl2 = "%s:%s:%s:%s:64"
        st = int(start_time/86400)
        et = int(end_time/86400) + 1
        keys = []
        key_user_map = {}
        for t in range(st, et):
            for uid_type, uid in users:
                if uid_type == UidType.OPEN_UDID and isinstance(uid, str):
                    continue

                key2 = key_tpl2 % (self.key_head, uid, uid_type, t)
                key2_ = key2
                keys.append(key2_)
                key_user_map[key2_] = (uid_type, uid)

        kvs = self.cache.mget(keys, retry_num=1)
        partten = '=hqq'
        size = calcsize(partten)
        user_actions = {}
        for key in keys:
            value = kvs.get(key)
            if not value or len(value) < size:
                continue
            uid_type, uid = key_user_map.get(key)
            actions = user_actions.get((uid_type, uid))
            if actions == None:
                actions = []
                user_actions[(uid_type, uid)] = actions

            offset = 0
            while offset < len(value):
                action_type, group_id, action_time = unpack_from(partten, value, offset)
                if group_id:
                    actions.append((action_type, group_id, action_time))
                offset += size
        return user_actions


#coding: utf-8

import logging
from datetime import (
    datetime as pydt,
    date as pydate,
)

import ujson
import requests
import socket
from requests.packages.urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter
from pyutil.idc.idc import get_idc
from pyutil.program.conf import Conf

logger = logging.getLogger('tableau_datastore_service')

REGION_SERVER_MAP = {
    'cn': 'dalaran.byted.org',
    'maliva': 'dalaran-aliva.byted.org',
}
DEFAULT_SERVER = 'dalaran.byted.org'
JSON_STR_NORMAL_MAX_LENGTH = 1 * 1024 * 1024
JSON_STR_SMALL_MAX_LENGTH = 64 * 1024
CN_IDC_LIST = ('hl', 'hy', 'lf', )
DUMMY_PREDICATE = lambda x: x
# 缺省HTTP超时. 单位: 秒
DEFAULT_TIMEOUT = 5 * 60
DATETIME_URL_FORMAT = '%Y-%m-%d %H:%M:%S'

RETRY_SESSION = requests.Session()
RETRIES = Retry(total=5,
                backoff_factor=1,
                method_whitelist=False,
                status_forcelist=[408, 502, 503, 504])
RETRY_SESSION.mount('http://', HTTPAdapter(max_retries=RETRIES))


class APIException(Exception):
    def __init__(self, *args, **kwargs):
        super(APIException, self).__init__(*args)
        self.status_code = kwargs.get('status_code', None)


class SingleRecordTooLongException(APIException):
    def __init__(self, record_idx, cur_size, max_size):
        super(SingleRecordTooLongException, self).__init__(
            'data[%d]单条记录的长度[%d] > 上限[%d]!' % (record_idx, cur_size, max_size)
        )


def encode_datetime(records):
    for record in records:
        for key, value in record.items():
            if isinstance(value, pydt):
                record[key] = value.strftime('%Y-%m-%d %H:%M:%S')
            elif isinstance(value, pydate):
                record[key] = value.strftime('%Y-%m-%d')


def is_cn_idc():
    return get_idc().value in CN_IDC_LIST


class DatastoreService(object):
    # JSON字符串的最大长度. 该值在跨区域/同区域写的时候取值不同
    json_str_max_length = JSON_STR_NORMAL_MAX_LENGTH
    # 是否放宽单次申请ticket_id数量的限制. 该值在跨区域/同区域写的时候取值不同
    is_xl_ticket_count = False

    def __init__(self, department, datastore_name=None, server=None, region='cn', *args, **kwargs):
        if (is_cn_idc() and region != 'cn') or (not is_cn_idc() and region == 'cn'):
            # 国内写国外, 国外写国内, 要用小包
            self.json_str_max_length = JSON_STR_SMALL_MAX_LENGTH
            self.is_xl_ticket_count = True

        self.department = department
        self.datastore_name = datastore_name
        self.region = region
        if not server:
            self.server = REGION_SERVER_MAP.get(self.region, DEFAULT_SERVER)
        else:
            self.server = server

    def split_list_by_length(self, data, idx_from, idx_to, predicate=None):
        if idx_from >= idx_to:
            return []
        predicate = predicate or DUMMY_PREDICATE

        cur_splited_list = predicate(data[idx_from:idx_to])
        cur_str = ujson.dumps(cur_splited_list, ensure_ascii=False)
        if len(cur_str) > self.json_str_max_length:
            idx_mid = (idx_from + idx_to) / 2
            if idx_mid == idx_from:
                raise SingleRecordTooLongException(idx_mid, len(cur_str), self.json_str_max_length)
            head_splited_list = self.split_list_by_length(data, idx_from, idx_mid, predicate)
            tail_splited_list = self.split_list_by_length(data, idx_mid, idx_to, predicate)
            return head_splited_list + tail_splited_list

        return [cur_splited_list]

    def get_departments(self, timeout=DEFAULT_TIMEOUT):
        api = "/department".format()
        departments = self.call_service(
            requests.get,
            api,
            timeout=timeout
        )
        return departments.get('departments', [])

    def get_datastores(self, timeout=DEFAULT_TIMEOUT):
        api = "/datastore/{}".format(self.department)
        # 这个接口
        # 在指定fields的时候, 返回[{"field1": "xx", "field2": "oo"}]
        # 未指定fields的时候, 返回{"datastores": [{"field1": "xx", "field2": "oo", "field3": "xo"}]}
        datastores = self.call_service(
            requests.get,
            api,
            params={'fields': 'datastore'},
            timeout=timeout
        )
        if isinstance(datastores, dict):
            datastores = datastores.get('datastores', [])

        return [d['datastore'] for d in datastores]

    def get_datastore_metainfo(self, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        api = "/datastore/{}/{}".format(self.department, self.datastore_name)
        return self.call_service(requests.get, api, timeout=timeout)

    def update_dimensions(self, dimensions, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(dimensions, list)
        encode_datetime(dimensions)
        api_path = "/dimensions/{}/{}".format(self.department, self.datastore_name)

        json_obj_list = self.split_list_by_length(
            dimensions, 0, len(dimensions), lambda dims: {'dimensions': dims, 'ticket_id': '0'}
        )
        if not json_obj_list:
            return
        self._post_json_with_retries(api_path, json_obj_list, None, timeout=timeout)

    def add_records(self, datetime, records, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        encode_datetime(records)
        header = {'content-type': 'application/json'}
        api_path = "/records/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)

        json_obj_list = self.split_list_by_length(
            records, 0, len(records), lambda records: {'records': records, 'ticket_id': '0'}
        )
        if not json_obj_list:
            return
        self._post_json_with_retries(api_path, json_obj_list, datetime_str, timeout=timeout)

    def _post_json_with_retries(self, api_path, json_obj_list, datetime_str, timeout=DEFAULT_TIMEOUT):
        header = {'content-type': 'application/json'}
        ticket_list = self.call_service(
            RETRY_SESSION.post,
            "/tickets/{}/{}".format(self.department, self.datastore_name),
            json=dict(cnt=len(json_obj_list), datetime=datetime_str, is_xl=self.is_xl_ticket_count),
            headers=header,
            timeout=timeout
        )
        if ticket_list and ticket_list.get('tickets', []):
            ticket_list = ticket_list.get('tickets', [])
        else:
            raise APIException(
                'Fail to get tickets for ({}, {}, {}): {}'.format(self.department, self.datastore_name, self.region, ticket_list)
            )

        for json_obj, ticket_id in zip(json_obj_list, ticket_list):
            json_obj['ticket_id'] = ticket_id
            self.call_service(RETRY_SESSION.post, api_path, json=json_obj, headers=header, timeout=timeout)

    def clear_records(self, datetime, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        api = "/records/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)
        self.call_service(requests.delete, api, timeout=timeout)

    def get_records(self, datetime, start=0, limit=1000, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        api = "/records/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)
        params = {'start': start, 'limit': limit}
        return self.call_service(requests.get, api, params=params, timeout=timeout)['records']

    def get_partition(self, datetime, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        api = "/datastore/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)
        return self.call_service(requests.get, api, timeout=timeout)

    def reopen_records(self, datetime, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        api = "/datastore/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)
        self.call_service(requests.put, api, data={'status': 'open'}, timeout=timeout)

    def complete_records(self, datetime, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        datetime_str = datetime.strftime(DATETIME_URL_FORMAT)
        api = "/datastore/{}/{}/{}".format(self.department, self.datastore_name, datetime_str)
        self.call_service(requests.put, api, data={'status': 'completed'}, timeout=timeout)

    def exists(self, datetime, timeout=DEFAULT_TIMEOUT):
        assert self.datastore_name
        assert isinstance(datetime, (pydt, pydate))
        try:
            rs = self.get_partition(datetime, timeout=timeout)
            return rs.get('records_cnt', 0) > 0
        except APIException as e:
            if e.status_code == 404:
                return False
            raise

    def call_service(self, func, path, *args, **kwargs):
        url_prefix = "http://{}/api/v1".format(self.server)
        url = "{}{}".format(url_prefix, path)
        resp, rs, err = None, None, None

        try:
            logger.debug('url[{}]'.format(url))
            resp = func(url, *args, **kwargs)
            rs = resp.json()
        except Exception as e:
            rs = None
            err = e

        if resp and resp.status_code in (requests.codes.CREATED, requests.codes.ok):
            return rs
        else:
            msg, status_code = '', None
            if rs:
                msg, status_code = rs.get('message', ''), resp.status_code
                if rs.get('noharm', False):
                    return rs
            if not msg:
                msg = resp.text if resp else resp
                status_code = resp.status_code if resp else resp
            raise APIException(
                'fail to call {}: status {}, msg: {}, err: {}'.format(url, status_code, msg, err),
                status_code=status_code
            )


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)

    # 部门
    department = 'test'
    # 事实表, 维度表
    fact_datastore, dim_datastore = 'dalaran_fact_test', 'dalaran_dim_test'
    # 强制使用的Server, DB地区
    force_server, region = None, 'cn'

    def _test_get_departments():
        # 获取所有部门名称及其region
        store = DatastoreService(
            None,
            server=force_server, region=None
        )
        logger.debug(store.get_departments())

    def _test_get_datastores():
        # 获取某个部门下的所有datastore名称
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        logger.debug(store.get_datastores())


    def _test_update_dimensions():
        # 覆写维度表记录
        store = DatastoreService(
            department, dim_datastore,
            server=force_server, region=region
        )
        dims = [{"value": "val1"}] * 1000
        logger.debug(store.update_dimensions(dims))


    def _test_add_records():
        # 覆写事实表记录
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        date = pydate(2017,10,12)
        records = [{"value": "val1"}]
        store.clear_records(date)
        logger.debug(store.add_records(date, records))
        store.complete_records(date) # 标识分区已经添加完成，触发后续处理

        # 重新打开分区, 用于继续写入
        store.reopen_records(date)
        records = [{"value": "val2"}]
        logger.debug(store.add_records(date, records))
        store.complete_records(date)


    def _test_get_datastore_metainfo():
        # 获取datasotre的元信息
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        logger.debug(store.get_datastore_metainfo())


    def _test_clear_records():
        # 清除一个分区的记录
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        date = pydate(2017,10,12)
        logger.debug(store.clear_records(date))


    def _test_get_records():
        # 获取事实表记录
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        dt = pydate(2017,10,12)
        logger.debug(store.get_records(dt, 0, 100))


    def _test_get_partition():
        # 获取事实表的分区信息
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        dt = pydate(2017,10,12)
        logger.debug(store.get_partition(dt))


    def _test_exists():
        # 判断事实表的某个分区是否存在
        store = DatastoreService(
            department, fact_datastore,
            server=force_server, region=region
        )
        date = pydate(2017,10,12)
        logger.debug(store.exists(date))

    _test_exists()

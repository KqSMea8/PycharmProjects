#!/usr/bin/env python
#coding=utf8
from collections import Counter
from random import sample

def text_width(ustr):
    u'''
    >>> text_width(u'中国ab,')
    7
    '''

    import unicodedata

    return sum([2 if unicodedata.east_asian_width(c) == 'W' else 1 for c in ustr])

def cn_text_width(ustr):
    u'''
    为text_width的一半, 1.5当1处理
    >>> cn_text_width(u'中国ab,')
    3
    '''
    if not isinstance(ustr, unicode):
        ustr = ustr.decode('utf-8')
    return text_width(ustr) / 2

def is_en(i):
    o=ord(i)
    return 0x41 <= o <= 0x5a or 0x61 <= o <= 0x7a or 0x30 <= o <= 0x39

def is_ja(i):
    o = ord(i)
    return 0x0800 <= o < 0x4e00

def is_cn(i):
    o = ord(i)
    return 0x4e00 <= o < 0x9fa6

def is_cn_char(i):
    o = ord(i)
    return 0x4e00 <= o < 0x9fa6

def is_fullwidth(c):
    u'''see http://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms
    >>> is_fullwidth(u'０')
    True
    >>> is_fullwidth(u'Ａ')
    True
    >>> is_fullwidth(u'A')
    False
    '''
    return 0xff01 <= ord(c) <= 0xff5e

def is_alphabet(c):
    o = ord(c)
    return 0x41 <= o <= 0x5a or 0x61 <= o <= 0x7a

def is_number(c):
    o = ord(c)
    return 0x30 <= o <= 0x39

def is_cn_or_en(c):
    o = ord(c)
    return 0x4e00 <= o < 0x9fa6 or 0x41 <= o <= 0x5a or 0x61 <= o <= 0x7a or 0x30 <= o <= 0x39# or o in (0x2d, 0x5f)

def is_other(uchar):
    '''判断是否非汉字，数字和英文字符'''
    if not (is_cn_char(uchar) or is_number(uchar) or is_alphabet(uchar)):
        return True
    else:
        return False

def B2Q(uchar):
    '''半角转全角'''
    inside_code = ord(uchar)
    if inside_code < 0x0020 or inside_code > 0x7e: #不是半角字符就返回原来的字符
        return uchar
    if inside_code == 0x0020: #除了空格其他的全角半角的公式为:半角=全角-0xfee0
        inside_code = 0x3000
    else:
        inside_code += 0xfee0
    return unichr(inside_code)

def Q2B(uchar):
    '''全角转半角'''
    inside_code = ord(uchar)
    if inside_code == 0x3000:
        inside_code = 0x0020
    else:
        inside_code -= 0xfee0
    if inside_code < 0x0020 or inside_code > 0x7e: #转完之后不是半角字符返回原来的字符
        return uchar
    return unichr(inside_code)

def strQ2B(ustring):
    '''把字符串全角转半角'''
    return ''.join([Q2B(c) for c in ustring])

def uniform(ustring):
    '''格式化字符串，完成全角转半角，大写转小写的工作'''
    return strQ2B(ustring).lower()

def str_to_list(ustring):
    '''将ustring按照中文，字母，数字分开'''
    ret_list = []
    utmp = []
    for uchar in ustring:
        if is_other(uchar):
            if len(utmp) == 0:
                continue
            else:
                ret_list.append(''.join(utmp))
                utmp = []
        else:
            utmp.append(uchar)
    if len(utmp) != 0:
        ret_list.append(''.join(utmp))
    return ret_list

def smart_decode(body, with_detail=False):
    encoding_candidates = ('utf-8', 'gbk', 'big5')
    best_encoding, best_result, best_result_bad_num = '', '', 99999
    for c in encoding_candidates:
        u = body.decode(c, 'replace')
        if c == 'utf-8': # 当编码为utf-8时, body本身可能含有�字符, 计算bad_num要减去body在decode前已经有的�字符.
            bad_num = u.count(u'\uFFFD') - body.count(u'\uFFFD'.encode(c))
        else:
            bad_num = u.count(u'\uFFFD')
        if bad_num < best_result_bad_num:
            best_encoding, best_result, best_result_bad_num = c, u, bad_num
        if bad_num == 0:
            break
    if best_result_bad_num >= 100 or best_result_bad_num * 100 / len(best_result) > 40:
        best_result = u''
    else:
        best_result = best_result.replace(u'\uFFFD', '')

    if with_detail:
        return best_result, best_encoding, best_result_bad_num
    else:
        return best_result

def unicode_to_bmp(text):
    u'''
    Non-BMP unicode char转换成utf8时是4个或以上字节，mysql utf8最多只支持3字节, 因此此种情况转为xml entity以确保存储正确
    >>> print unicode_to_bmp(u'中')
    中
    >>> print unicode_to_bmp(u'中\U0001f631')
    中&#128561;
    '''
    chars = []
    with_non_bmp = False
    for u in text:
        bmp_u = u
        if len(u.encode('utf8')) > 3:
            with_non_bmp = True
            bmp_u = u'&#%s;' % ord(u)
        chars.append(bmp_u)
    return u''.join(chars) if with_non_bmp else text

def remove_non_bmp(text):
    u'''
    >>> print remove_non_bmp(u'中')
    中
    >>> print remove_non_bmp(u'中\U0001f631')
    中
    '''
    chars = []
    with_non_bmp = False
    for u in text:
        if len(u.encode('utf8')) <= 3:
            chars.append(u)
        else:
            with_non_bmp = True
    return u''.join(chars) if with_non_bmp else text

def to_unicode(s):
    return s.decode('utf-8') if isinstance(s, str) else s

def to_str(s, encoding='utf-8'):
    if isinstance(s, int) or isinstance(s, long) or isinstance(s, float):
        return str(s)
    if s is None:
        return ''
    if not isinstance(s, basestring):
        return str(s)
    return s.encode(encoding) if isinstance(s, unicode) else s

def fmt_counter(id2name, topic=None, sample_count=0, reverse=True, sort_index=1, prefix=''):
    name2ids = {}
    for k, v in id2name.items():
        if v not in name2ids:
            name2ids[v] = list()
        name2ids[v].append(k)
    c = Counter(id2name.values())
    total = sum(c.values())
    res_lines = []
    if topic:
        res_lines.append('[====== %s (%s) =====]' % (to_str(topic), total))

    for name, number in sorted(c.items(), key=lambda x: x[sort_index], reverse=reverse):
        ls = [name, number, '%.2f%%' % (number * 100.0 / total)]
        if sample_count > 0:
            sample_ids = ','.join(map(to_str, sample(name2ids[name], min(sample_count, len(name2ids[name])))))
            ls.append(prefix + sample_ids)
        res_lines.append('\t'.join(map(to_str, ls)))
    return '\n'.join(res_lines)

class MultiPatternMatcher(object):

    def __init__(self, patterns=[]):
        self.root = {}
        for pattern in patterns:
            if isinstance(pattern, (tuple, list)):
                self.add_pattern(*pattern)
            else:
                self.add_pattern(pattern)

    def add_pattern(self, pattern, data=None):
        cur_node = self.root
        for char in pattern:
            cur_node = cur_node.setdefault(char, {})
        cur_node['$'] = True
        cur_node['data'] = data

    def _match(self, text):
        text_len = len(text)
        for start in range(0, text_len):
            cur_node, cur_pattern, cur_data = self.root, '', None
            for end in range(start, text_len):
                char = text[end]
                if char in cur_node:
                    cur_node = cur_node[char]
                else:
                    break
                if cur_node.get('$', False) == True:
                    cur_pattern = text[start: end+1]
                    cur_data = cur_node['data']
            if cur_pattern:
                return cur_pattern, cur_data
        return None, None

    def match(self, text):
        pattern, data = self._match(text)
        return pattern, data


def camel_to_snake(name):
    """
    >>> camel_to_snake('CamelCase')
    'camel_case'
    >>> camel_to_snake('CamelCamelCase')
    'camel_camel_case'
    >>> camel_to_snake('Camel2Camel2Case')
    'camel2_camel2_case'
    >>> camel_to_snake('getHTTPResponseCode')
    'get_http_response_code'
    >>> camel_to_snake('get2HTTPResponseCode')
    'get2_http_response_code'
    >>> camel_to_snake('HTTPResponseCode')
    'http_response_code'
    >>> camel_to_snake('HTTPResponseCodeXYZ')
    'http_response_code_xyz'
    """
    import re
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def main():
    import unicodedata
    for c in (u'中', u'樂', u';', u'；', u'…', u'-', u'_'):
        print 'is_cn', c, is_cn_char(c), unicodedata.category(c), '0x%0x' % ord(c)
        print 'is_cn_or_en', c, is_cn_or_en(c), unicodedata.category(c), '0x%0x' % ord(c)
    a = '果中人民'[:12].decode('utf8').encode('big5')
    print smart_decode(a)
    #for c in string.punctuation:
    #    print c, ord(c)
    #print string.letters

    #test Q2B and B2Q
    for i in range(0x0020, 0x007F):
            print Q2B(B2Q(unichr(i))), B2Q(unichr(i))

    #test uniform
    s = u'中国 人名ａ高频Ａ'
    s = uniform(s)
    ret = str_to_list(s)
    print '|'.join(ret)

if __name__ == '__main__':
    main()

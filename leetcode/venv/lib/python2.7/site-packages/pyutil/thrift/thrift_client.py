#coding=utf8

import logging, time, socket, threading, random
from functools import wraps

from thrift.protocol import TBinaryProtocol
from thrift.transport import TTransport
from thrift.Thrift import TException

from pyutil.thrift.transport import SocketPool
from pyutil.thrift.thrift_unicode import thrift_unicode_client, thrift_methods
from pyutil.consul import bridge
from pyutil.program import metrics
from pyutil.program.conf2 import Conf, string2list
from pyutil.program.fmtutil import pformat, fmt_exception
from pyutil.program.lru import lru_cache
from pyutil.program.tracing import get_current_span, get_current_trace_id, start_child_span

__all__ = ['ThriftClient', 'ThriftRetryClient']

class ThriftClient(threading.local):

    def __init__(self, service_module, host, port, timeout=3, conn_timeout=0.5, max_retries=1, nonblocking_server=False):
        self.max_retries = max_retries
        name_sign = 'client:%s:%s:%s:%s:%s' % (service_module.__name__, host, port, timeout, conn_timeout)
        client = self.__dict__.get(name_sign)
        if not client:
            self.randomizer = random.Random()
            self.socketpool = SocketPool.TSocketPool(host, port, timeout, conn_timeout, self.randomizer)
            if nonblocking_server:
                transport = TTransport.TFramedTransport(self.socketpool)
            else:
                transport = TTransport.TBufferedTransport(self.socketpool)
            protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)
            client = service_module.Client(protocol)
            client.transport = transport
            setattr(self, name_sign, client)
        self.client = client

    def __getattr__(self, attr):
        retry_times = 0
        func = getattr(self.client, attr)
        def wrap(*args, **kw):
            retry_times = 0
            while retry_times < self.max_retries:
                retry_times += 1
                try:
                    self.client.transport.open()
                    return func(*args, **kw)
                except:
                    if retry_times >= self.max_retries:
                        raise
                finally:
                    self.client.transport.close()
        return wrap

    def get_peer_addr(self):
        return '%s:%s' % (self.socketpool.host, self.socketpool.port)

class ThriftRetryClient(object):
    '''
    自动重试的thrift client. 如果调用时抛TException(如所有server连不上)或socket.error(超时或服务端重启), 会自动重试, 其他异常则直接抛出. 重试次数耗尽时也会抛出原异常.

    >>> from ss.article.article_extract import ArticleExtract
    >>> from ss.article.article_extract.ttypes import ExtractReq
    >>> tclient = ThriftRetryClient(ArticleExtract.Client, use_unicode=True, max_retries=1, servers=[('127.0.0.1', 9090)])
    >>> req = ExtractReq(url=u'http://tech.sina.com.cn/digi/dc/2013-06-03/09212747800.shtml')
    >>> rsp = tclient.extract(req)
    '''

    def __init__(self, ClientClass, servers=None, use_unicode=False, use_uint64=False,
            timeout=600, conn_timeout=.5, delay=5, backoff=2, max_retries=5,
            log_freq=1, start_log_times=1, total_timeout=None, nonblocking_server=False, accelerated=False,
            service_name=None, consul_name=None, caller_name=None
            ):
        '''
        :param list servers:
        use_unicode - 接收unicode的req, 返回unicode的rsp
        use_uint64 - 接收uint64的req, 返回uint64的rsp
        timeout - seconds. 单次读写超时, None表示不超时
        conn_timeout - seconds. 连接超时, None表示使用timeout
        total_timeout - seconds, 整体超时则不再重试, None表示不超时
        max_retries - 最大重试次数, None: 无限次, >=0: 指定次数
        delay - retry的间隔 (in seconds)
        backoff - 重试时间随次数增加, 每次重试的delay乘以此值
        log_freq - deprecated, 每retry指定次数, 输出一条日志
        start_log_times - deprecated, 重试指定次数后, 才开始输出日志(日志重试次数此时开始计数)
        accelerated - 使用C模块加速序列化和反序列化
        service_name - 服务名字, 为空则自动推导
        consul_name - consul服务名字, 当传入时每次调用服务会重新获取server配置
        '''

        if not servers and not consul_name:
            raise ValueError('servers and consul_name are both missing')
        if use_unicode or use_uint64:
            ClientClass = thrift_unicode_client(ClientClass, use_unicode=use_unicode, use_uint64=use_uint64)

        self.ClientClass = ClientClass
        self.timeout = timeout
        self.conn_timeout = conn_timeout
        self.total_timeout = total_timeout
        self.servers = servers
        self.service_name = service_name or ClientClass.__module__.split('.')[-1] # ss.article.article_extract.ArticleExtract -> ArticleExtract
        self.consul_name = consul_name
        self.caller_name = caller_name or 'unknown'

        # 重试配置
        self.delay = delay
        self.backoff = backoff
        self.max_retries = max_retries
        self.log_freq = log_freq
        self.start_log_times = start_log_times
        self.nonblocking_server = nonblocking_server
        self.accelerated = accelerated
        self.method_names = thrift_methods(ClientClass)
        for mname in self.method_names:
            setattr(self, mname, self._wrap_method_for_retry(mname))

        self.latency_metrics = '%s.latency' % self.service_name
        self.throughput_metrics = '%s.throughput' % self.service_name
        self.exception_metrics = '%s.throughput.exception' % self.service_name
        self.metrics_prefix = 'thrift.client'
        self._init_client_metrics()

    def _init_client_metrics(self,):
        metrics.define_timer(self.latency_metrics, 'ms', prefix=self.metrics_prefix)
        metrics.define_counter(self.throughput_metrics, prefix=self.metrics_prefix)
        metrics.define_counter(self.exception_metrics, prefix=self.metrics_prefix)
        metrics.define_tagkv('method', self.method_names)
        metrics.define_tagkv('caller', [self.caller_name])

    @lru_cache(maxsize=100, timeout=5)
    def _get_consul_servers(self, consul_name):
        return bridge.translate_one(consul_name)

    def _create_client(self):
        if self.consul_name:
            if isinstance(self.consul_name, list):
                servers = []
                for consul_name in self.consul_name:
                    servers += self._get_consul_servers(consul_name)
            else:
                servers = self._get_consul_servers(self.consul_name)
            self.servers = servers
        socket = SocketPool.TSocketPool(self.servers, timeout=self.timeout, conn_timeout=self.conn_timeout)
        if self.nonblocking_server:
            transport = TTransport.TFramedTransport(socket)
        else:
            transport = TTransport.TBufferedTransport(socket)
        if self.accelerated:
            protocol = TBinaryProtocol.TBinaryProtocolAccelerated(transport)
        else:
            protocol = TBinaryProtocol.TBinaryProtocol(transport)
        client = self.ClientClass(protocol)
        client.transport = transport
        client.socketpool = socket
        self.socket = socket
        return client

    def get_host_and_port(self):
        return self.socket.host, self.socket.port

    def _wrap_method_for_retry(self, method_name):
        def wrapper(*args, **kws):
            req_desc = u'%s(%s)' % (
                    method_name,
                    u', '.join(
                        [pformat(x, max_v_limit=100) for x in args] +
                        [u'%s=%s' % (k, pformat(v, max_v_limit=100)) for k, v in kws.items()]
                        )
                    )
            client = self._create_client()
            method = getattr(client, method_name)
            retried_times = -1
            delay = self.delay
            start_ts = time.time()
            def check_retry_time(e):
                if self.max_retries is not None and retried_times >= self.max_retries:
                    logging.warning(u'[%s] stop retrying after %s times, e=%s, trace=%s, req=%s' % (
                        self.service_name, retried_times, fmt_exception(e),
                        get_current_trace_id(), req_desc))
                    raise
                age_seconds = int(time.time() - start_ts)
                if self.total_timeout is not None and age_seconds >= self.total_timeout:
                    logging.warning(u'[%s] stop retrying due to timeout(%s seconds), e=%s, trace=%s, req=%s',
                            self.service_name, age_seconds, fmt_exception(e),
                            get_current_trace_id(), req_desc)
                    raise

            def get_logmsg(retried_times, e, delay, start_time):
                return u'[%s] %s %s:%s (dur=%ss), retry(%s/%s) after %s seconds, trace=%s, req=%s' % (
                        self.service_name, fmt_exception(e),
                        client.socketpool.host, client.socketpool.port,
                        int(time.time() - start_time),
                        retried_times + 1, self.max_retries or 'unlimited', delay,
                        get_current_trace_id(), req_desc)

            span = get_current_span()
            while True:
                start_time = time.time()
                try:
                    retried_times += 1
                    with start_child_span(span,
                            'service.%s.%s' % (self.service_name, method_name),
                            tags=dict(component='thrift_client', retry=str(retried_times)),
                            ):
                        client.transport.open()
                        rsp = method(*args, **kws)
                        metrics.emit_counter(
                            self.throughput_metrics, 1, prefix=self.metrics_prefix,
                            tagkv=dict(method=method_name, caller=self.caller_name))
                        metrics.emit_timer(
                            self.latency_metrics, (time.time() - start_time) * 1000, prefix=self.metrics_prefix,
                            tagkv=dict(method=method_name, caller=self.caller_name))
                        return rsp
                except (TException, socket.error) as e:
                    check_retry_time(e)
                    logmsg = get_logmsg(retried_times, e, delay, start_time)
                    if retried_times == 0:
                        # 避免重启导致的大量warn
                        logging.info(logmsg)
                    else:
                        logging.warn(logmsg,
                                # 首次输出异常栈, 方便调试时追查问题
                                exc_info=retried_times == 1
                                )
                    with start_child_span(span, 'sleep',
                            tags=dict(component='thrift_client', retry=str(retried_times), delay=str(delay)),
                            ):
                        time.sleep(delay)
                    delay *= self.backoff
                    metrics.emit_counter(self.exception_metrics, 1, prefix=self.metrics_prefix,
                                         tagkv=dict(method=method_name, caller=self.caller_name))
                finally:
                    client.transport.close()

        return wrapper

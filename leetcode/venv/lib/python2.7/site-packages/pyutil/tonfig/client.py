# make sure grpc can be found
import os, sys
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__))+"/lib")
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))

import random, threading, json, logging

import grpc
import etcdrpc as etcdrpc
import exceptions as exceptions
import utils as utils
import rwlock

ETCDv3_GRPC_PROXY_NAME = 'toutiao.etcd.grpc_proxy'

# NOTE: Please create one instance of AppConfig and reuse it accross the process life cycle.
class AppConfig(object):

    CHECK_VERSION_INTERVAL = 60*10
    WATCH_RETRY_IN_SECONDS_MIN = 10
    WATCH_RETRY_IN_SECONDS_MAX = 10*60

    def __init__(self, *args, **kwargs):
        self.ns = kwargs.get("namespace")
        self.psm = kwargs.get("psm")
        self.cluster = kwargs.get("cluster")
        self.env = kwargs.get("env")
        if self.ns:
            self.conf_event_path = "/tonfig/event/ns/" + self.ns
        elif self.psm and self.cluster and self.env:
            self.conf_event_path = "/tonfig/event/psm/" + self.psm + "/" + self.cluster + "/" + self.env
        else:
            raise ValueError("ns or (psm, cluster, env) is required.")

        try:
            from pyutil.consul.bridge import translate_one
            endpoints = translate_one(ETCDv3_GRPC_PROXY_NAME)
        except:
            endpoints = []

        if len(endpoints) == 0:
            logging.debug("translate %s return empty, use fallback hosts", ETCDv3_GRPC_PROXY_NAME)
            endpoints = [
                ("10.3.26.153", "3379"),
                ("10.4.34.40", "3379")
            ]

        # TODO(wangfenjin): need to update endpoint if it's not useable
        endpoint = random.choice(endpoints)
        logging.debug("use etcd endpoint %s", endpoint)
        self.etcd_client = client(endpoint[0], endpoint[1])

        # get conf event
        self.event = self._get_conf_event()

        # get kvs
        data_path= self.event["etcd_path"]
        self.kvs = self._get_from_remote(data_path)

        self.rwlock = rwlock.ReadWriteLock()

        # http://stackoverflow.com/questions/18098475/detect-interpreter-shut-down-in-daemon-thread/18099067
        # As the daemon thread will segfault if main thread exit, use `once` to control we if want to watch
        once = kwargs.get("once")
        if once is True:
            return
        self._watch()
        self._check_version()

    def get_all(self):
        self.rwlock.acquire_read()
        kvs = self.kvs
        self.rwlock.release_read()
        return kvs

    def get(self, key):
        self.rwlock.acquire_read()
        v = self.kvs.get(key)
        self.rwlock.release_read()
        if v is not None:
            return v
        raise ValueError("key not exists")

    def get_with_default(self, key, defaultValue):
        self.rwlock.acquire_read()
        v = self.kvs.get(key)
        self.rwlock.release_read()
        return v if v else defaultValue

    def _get_conf_event(self):
        event = self.etcd_client.get(self.conf_event_path)
        return json.loads(event)

    def _get_from_remote(self, data_path):
        if not data_path.endswith('/'):
            data_path += '/'
        kvs = {}
        for (k, v) in self.etcd_client.get_prefix(data_path):
            kvs[k[len(data_path):]] = v
        return kvs

    def _check_version(self):
        def check_version():
            ticker = threading.Event()
            while not ticker.wait(AppConfig.CHECK_VERSION_INTERVAL):
                try:
                    event = self._get_conf_event()
                    self._check_then_update(event)
                except Exception as e:
                    logging.error("check version error %s", e)

        timer = threading.Thread(name="check_version_timer", target=check_version)
        timer.setDaemon(True)
        timer.start()

    def _check_then_update(self, conf_event):
        self.rwlock.acquire_read()
        if conf_event["publish_version"] <= self.event["publish_version"]:
            self.rwlock.release_read()
            return
        self.rwlock.release_read()

        kvs = self._get_from_remote(self.event["etcd_path"])
        # update kvs
        self.rwlock.acquire_write()
        self.event = conf_event
        self.kvs = kvs
        self.rwlock.release_write()
        logging.debug("udpate event %s\nkvs %s", self.event, self.kvs)

    def _watch(self):
        def watch_key():
            watch_retry = AppConfig.WATCH_RETRY_IN_SECONDS_MIN
            while True:
                try:
                    for (event, cancel) in self.etcd_client.watch(self.conf_event_path):
                        event_len = len(event.events)
                        for i in range(0, event_len):
                            ev = event.events[i]
                            logging.debug("get event %s", ev)
                            # TODO(wangfenjin): filter delete events in request
                            if ev.type != 0:
                                # only handle put event
                                continue
                            conf_event = json.loads(ev.kv.value)
                            self._check_then_update(conf_event)
                            watch_retry = AppConfig.WATCH_RETRY_IN_SECONDS_MIN
                except Exception as e:
                    logging.warn("watch exception, cancel this thread, %s", e)
                finally:
                    cancel()

                # backoff retry watch
                time.sleep(watch_retry)
                watch_retry *= 2
                if watch_retry > AppConfig.WATCH_RETRY_IN_SECONDS_MAX:
                    watch_retry = AppConfig.WATCH_RETRY_IN_SECONDS_MAX

        ts = threading.Thread(name="watch", target=watch_key)
        ts.setDaemon(True)
        ts.start()

class Etcd3Client(object):
    # better set by clients
    RANGE_TIMEOUT = 0.5   # second

    def __init__(self, host='localhost', port=2379):
        self.channel = grpc.insecure_channel('{host}:{port}'.format(
            host=host, port=port)
        )
        self.kvstub = etcdrpc.KVStub(self.channel)
        self.watchstub = etcdrpc.WatchStub(self.channel)

    def _build_watch_request(self, cv, key):
        cv.acquire()
        create_watch = etcdrpc.WatchCreateRequest()
        create_watch.key = utils.to_bytes(key)
        create_watch.progress_notify = True
        watch_requests = etcdrpc.WatchRequest(create_request=create_watch)
        yield watch_requests
        cv.wait()
        cv.release()

    def watch(self, key):
        """
        Watch a key

        :param key: the key want to watch

        :returns: streams of (event, cancel) tuples.
                  loop `event` to get the events of key change, use `cancel` to cancel the watch request
        """
        cv = threading.Condition()
        def cancel_watch():
            cv.acquire()
            cv.notify()
            cv.release()
        watcher = self.watchstub.Watch(self._build_watch_request(cv, key))
        for event in watcher:
            yield (event, cancel_watch)

    def _build_get_range_request(self, key,
                                 range_end=None,
                                 limit=None,
                                 revision=None,
                                 sort_order=None,
                                 sort_target='key',
                                 serializable=None,
                                 keys_only=None,
                                 count_only=None,
                                 min_mod_revision=None,
                                 max_mod_revision=None,
                                 min_create_revision=None,
                                 max_create_revision=None):
        range_request = etcdrpc.RangeRequest()
        range_request.key = utils.to_bytes(key)
        if range_end is not None:
            range_request.range_end = utils.to_bytes(range_end)

        if sort_order is None:
            range_request.sort_order = etcdrpc.RangeRequest.NONE
        elif sort_order == 'ascend':
            range_request.sort_order = etcdrpc.RangeRequest.ASCEND
        elif sort_order == 'descend':
            range_request.sort_order = etcdrpc.RangeRequest.DESCEND
        else:
            raise ValueError('unknown sort order: "{}"'.format(sort_order))

        if sort_target is None or sort_target == 'key':
            range_request.sort_target = etcdrpc.RangeRequest.KEY
        elif sort_target == 'version':
            range_request.sort_target = etcdrpc.RangeRequest.VERSION
        elif sort_target == 'create':
            range_request.sort_target = etcdrpc.RangeRequest.CREATE
        elif sort_target == 'mod':
            range_request.sort_target = etcdrpc.RangeRequest.MOD
        elif sort_target == 'value':
            range_request.sort_target = etcdrpc.RangeRequest.VALUE
        else:
            raise ValueError('sort_target must be one of "key", '
                             '"version", "create", "mod" or "value"')

        return range_request

    def get(self, key):
        """
        Get the value of a key from etcd.

        :param key: key in etcd to get
        :returns: value of key
        :rtype: bytes
        """
        range_request = self._build_get_range_request(key)
        range_response = self.kvstub.Range(range_request, Etcd3Client.RANGE_TIMEOUT)

        if range_response.count < 1:
            raise exceptions.KeyNotFoundError(
                'the key "{}" was not found'.format(key))
        else:
            # smells funny - there must be a cleaner way to get the value?
            return range_response.kvs.pop().value

    def get_prefix(self, key_prefix, sort_order=None, sort_target='key'):
        """
        Get a range of keys with a prefix.

        :param key_prefix: first key in range

        :returns: sequence of (key, value) tuples
        """
        range_request = self._build_get_range_request(
            key=key_prefix,
            range_end=utils.increment_last_byte(utils.to_bytes(key_prefix)),
            sort_order=sort_order,
        )

        range_response = self.kvstub.Range(range_request, Etcd3Client.RANGE_TIMEOUT)

        if range_response.count < 1:
            raise exceptions.KeyNotFoundError('no keys found')
        else:
            for kv in range_response.kvs:
                yield (kv.key, kv.value)

def client(host='localhost', port=3379):
    """Return an instance of an Etcd3Client."""
    return Etcd3Client(host=host, port=port)

# test
if __name__ == "__main__":
    import time

    def _test_etcd_client():
        etcd_client = client('10.3.26.153')

        def watch_key(etcd_client, key):
            i = 0
            for (event, cancel) in etcd_client.watch(key):
                print event
                i += 1
                if i >= 3:
                    cancel()
                    break

        ts1 = threading.Thread(name="1", target=watch_key, args=(etcd_client, '/beta/watch', ))
        ts2 = threading.Thread(name="2", target=watch_key, args=(etcd_client, '/beta/watch2', ))

        ts1.start()
        ts2.start()

        ts1.join()
        ts2.join()

    def test_for_watch():
        etcd_client = client("10.3.26.153")
        for i in range(0, 3):
            j = 0
            for (event, cancel) in etcd_client.watch("/beta/watch"):
                print i, j
                j += 1
                if j >= 3:
                    cancel()
                    break

    # start testing
    logging.basicConfig(level=logging.DEBUG)
    try:
        app = AppConfig(namespace='toutiao.im.gateway/default')
        print app.get_all()
        time.sleep(100)
    except (KeyboardInterrupt, SystemExit):
        sys.exit()

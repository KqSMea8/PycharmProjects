"""
Logging package for toutiao Python environment.
This package is based on the blue print of Python logging module
Basic designation document goes here: 
    https://docs.google.com/document/d/1oZ2Y8jycnzVNdMyAVayDQSF8VNGaCEEN5vkv4PesBzI/edit?usp=sharing

Author: xuruiqi

To use, simply 'import ttlogging' and log away!
"""

from contextlib import contextmanager
import cStringIO
import logging
import os
import sys
import time
import weakref

__author__ = "xuruiqi<reetsee.com>"
__date__   = "20160125"

__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',
           'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',
           'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',
           'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',
           'captureWarnings', 'critical', 'debug', 'disable', 'error',
           'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',
           'info', 'log', 'makeLogRecord', 'setLoggerClass', 'warn', 'warning',
           'trace', 'TRACE', 'setRequestId', 'getRequestId', 'timer',
           'pushNotice', 'flushTrace', 'startTimer', 'endTimer', 'getPsm', 
           'setPsm', 'addCounter', 'clearTrace']

#*********************************************************
#* codes below are for compatibility with logging module *
#*********************************************************
from logging import CRITICAL, DEBUG, ERROR, \
        FATAL, Filter, INFO, Handler, StreamHandler, \
        LogRecord, LoggerAdapter, NOTSET, NullHandler, \
        WARN, WARNING, addLevelName, FileHandler, \
        captureWarnings, getLevelName, \
        makeLogRecord
""" , Logger, critical, debug, error, exception, fatal,"""
""" info, log, warn, warning, getLogger, basicConfig,"""
""" getLoggerClass, setLoggerClass, disable,"""
""" Formatter, BufferingFormatter,"""

TRACE = logging.WARNING + 1
logging.addLevelName(TRACE, "TRACE") #!important

#try:
#    import codecs
#except ImportError:
#    codecs = None

try:
    import thread
    import threading
except ImportError:
    thread = None

try:
    unicode
    _unicode = True
except NameError:
    _unicode = False

BASIC_FORMAT = "%(levelname)s %(asctime)s %(pathname)s:%(lineno)d %(ip)s %(psm)s %(rid)s %(cluster)s process=%(process)d thread=%(thread)d %(pushinfo)sdata=%(message)s"

# _srcfile_dict is used when walking the stack to check when we've got the first
#   caller stack frame.
if hasattr(sys, "frozen"):
    _srcfile = "ttlogging%s__init__%s" % (os.sep, __file__[-4:])
elif __file__[-4:].lower() in [".pyc", "pyo"]:
    _srcfile = __file__[:-4] + ".py"
else:
    _srcfile = __file__
_srcfile = os.path.normcase(_srcfile)
_srcfile_dict = {
    _srcfile: 1, 
    logging._srcfile: 1,
}
def addExcludeFrame(filename):
    _srcfile_dict[filename] = 1
def delExcludeFrame(filename):
    _srcfile_dict.pop(filename, None)

def currentframe():
    """Return the frame object for the caller's stack frame."""
    try:
        raise Exception
    except:
        return sys.exc_info()[2].tb_frame.f_back
if hasattr(sys, "_getframe"): currentframe = lambda: sys._getframe(3)

class Local(object):
    def __init__(self):
        pass
if thread:
    _threadLocal = threading.local()
else:
    _threadLocal = Local()

def _setLocal(k, v):
    if thread:
        setattr(_threadLocal, k, v)
        return True
    else:
        return False

def _getLocal(k, default=None):
    if thread:
        return getattr(_threadLocal, k, default)
    else:
        return default

def _setLoggerLocal(k, v, logger_name="root"):
    global _threadLocal
    global thread

    if not thread:
        return False

    try:
        logger_data = getattr(_threadLocal, logger_name, None)
        if logger_data is None:
            setattr(_threadLocal, logger_name, {})
            logger_data = getattr(_threadLocal, logger_name, {})
        logger_data[k] = v
        return True
    except:
        return False

def _getLoggerLocal(k, default=None, logger_name="root"):
    global _threadLocal
    global thread
    try:
        if thread:
            return getattr(_threadLocal, logger_name, {}).get(k, default)
        else:
            return default
    except:
        return default

def _getLocalInstance():
    return weakref.ref(_threadLocal)

currentMilliTime = lambda: int(round(time.time() * 1000))

def setLoggerRequestId(param, logger_name="root"):
    try:
        if isinstance(param, int) or isinstance(param, basestring):
            _setLoggerLocal("rid", str(param), logger_name)
        else:
            _setLoggerLocal(
                    "rid",
                    str(param.META.get("HTTP_X_SS_RID", "0")),
                    logger_name)
    except:
        pass

def getLoggerRequestId(logger_name="root"):
    try:
        return str(_getLoggerLocal("rid", "0", logger_name))
    except:
        return "0"

def getRequestId():
    return getLoggerRequestId(logger_name="root")

def setRequestId(param):
    setLoggerRequestId(param=param, logger_name="root")

def setCluster(param):
    _setCluster(param, "root")

def _setCluster(param, logger_name="root"):
    try:
        _setLoggerLocal("cluster", str(param), logger_name)
    except:
        pass

def getCluster(logger_name="root"):
    try:
        return str(_getLoggerLocal("cluster", "-", logger_name))
    except:
        return "-"

_localIp = None
def getIp():
    global _localIp
    if _localIp is None:
        try:
            import socket
            hostName = socket.gethostname()
            _localIp = socket.gethostbyname(hostName)
        except:
            _localIp = "127.0.0.1"
    return _localIp

_psm = None
def getPsm():
    global _psm
    if _psm is None:
        try:
            # The following line will cause timezone error
            #from django.conf import settings
            #if hasattr(settings, "PRODUCT"):
            #    _psm = "%s.%s.%s" % (
            #            getattr(settings, "PRODUCT", "toutiao"),
            #            getattr(settings, "SUBSYS", "unknown"),
            #            getattr(settings, "MODULE", "unknown"))
            #else:
            #    _psm = "toutiao.unknown.unknown"
            _psm = "toutiao.unknown.unknown"
        except:
            _psm = "toutiao.unknown.unknown"
    return _psm

def setPsm(product, subsys, module):
    global _psm
    old_psm = _psm
    try:
        _psm = "%s.%s.%s" % (str(product), str(subsys), str(module))
    except:
        _psm = old_psm

if thread:
    _lock = threading.RLock()
else:
    _lock = None

def _acquireLock():
    """
    Acquire the module-level lock for serializing access to shared data.

    This should be released with _releaseLock().
    """
    if _lock and logging._lock:
        # Acquire logging._lock because this module
        #   is somehow dependent on logging
        _lock.acquire()
        logging._lock.acquire()

def _releaseLock():
    """
    Release the module-level lock acquired by calling _acquireLock().
    """
    if _lock and logging._lock:
        _lock.release()
        logging._lock.release()

class Formatter(logging.Formatter):
    def __init__(self, fmt=None, datefmt=None):
        if fmt is None:
            fmt = BASIC_FORMAT
        datefmt = datefmt
        logging.Formatter.__init__(self, fmt, datefmt)

    def format(self, record):
        try:
            record.rid = getattr(record, "rid", None) or getRequestId()
            record.psm = getattr(record, "psm", None) or getPsm()
            record.ip  = getattr(record, "ip", None) or getIp()
            record.cluster  = getattr(record, "cluster", None) or getCluster()
        except:
            record.rid = "0"
            record.psm = "toutiao.unknown.unknown"
            record.ip  = "127.0.0.1"
            record.cluster  = "-"
        if getattr(record, "pushinfo", None) is None:
            record.pushinfo = ""

        return logging.Formatter.format(self, record)

_defaultFormatter = Formatter()

class BufferingFormatter(object):
    def __init__(self, linefmt=None):
        if linefmt is None:
            linefmt = _defaultFormatter
        logging.BufferingFormatter.__init__(self, linefmt)

class Logger(logging.Logger):
    """
    A logger class for toutiao

    Authors: xuruiqi
    """
    def __init__(self, name, level=NOTSET):
        logging.Logger.__init__(self, name, level)

    def setLoggerData(self, k, v):
        return _setLoggerLocal(k, v, logger_name=self.name)

    def getLoggerData(self, k, default=None):
        return _getLoggerLocal(k, default, logger_name=self.name)

    def setRequestId(self, param):
        setLoggerRequestId(param, self.name)

    def getRequestId(self):
        return getLoggerRequestId(self.name)

    def setCluster(self, param):
        _setCluster(param, self.name)

    def __del__(self):
        try:
            self.flushTrace(
                    msg=(self.name + "flush_in_ttlogging.Logger.__del__"))
        except:
            pass

    def handle(self, record):
        try:
            setattr(record, "rid", self.getRequestId())
            setattr(record, "psm", getPsm())
            setattr(record, "ip", getIp())
        except:
            pass
        logging.Logger.handle(self, record)

    def flushTrace(self, msg="Flushtrace", flushall=True, appendtomsg=False):
        """Flush current timer, counter, trace data to output

        Authors: xuruiqi
        """
        if not thread or not self.isEnabledFor(TRACE):
            return

        kv_list = []
        # Handle timers
        trace_timers = self.getLoggerData("trace_timers", None)
        if flushall and trace_timers is not None:
            for k, v in trace_timers.iteritems():
                kv_list.append("Timer_%s=endTimer_Not_Called" % k)

        # Handle counters
        trace_counters = self.getLoggerData("trace_counters", None)
        if flushall and trace_counters is not None:
            for k, v in trace_counters.iteritems():
                kv_list.append("Counter_%s=%s" % (k, v))

        # Handle notices
        trace_notices = self.getLoggerData("trace_notices", None)
        if trace_notices is not None:
            for v in trace_notices:
                kv_list.append(v)

        # Clear trace data
        self.clearTrace()
            
        if len(kv_list) > 0:
            kv_list.append("")

        for i in xrange(0, len(kv_list)):
            if type(kv_list[i]) is unicode:
                kv_list[i] = kv_list[i].encode('utf8')
        s = " ".join(kv_list)
        if appendtomsg:
            self._log(level=TRACE, msg=msg + " " + s, args=None)
        else:
            self._log(level=TRACE, msg=msg, args=None, 
                    extra={"pushinfo":s})
            
    def clearTrace(self):
        self.setLoggerData("trace_timers", {})
        self.setLoggerData("trace_counters", {})
        self.setLoggerData("trace_notices", []) #! list not dict

    def _checkOverflow(self):
        if not thread:
            return False
        else:
            return len(self.getLoggerData("trace_notices", [])) > 500

    def pushNotice(self, k, v):
        global thread

        if not thread:
            # thread not supported, print a trace message directly
            self.trace("%s=%s" % (k, v))
        else:
            if self._checkOverflow():
                self.flushTrace(flushall=False)

            # Get the trace_notices references
            trace_notices = self.getLoggerData("trace_notices", None)
            if trace_notices is None:
                self.setLoggerData("trace_notices", [])
                trace_notices = self.getLoggerData("trace_notices", None)

            trace_notices.append("%s=%s" % (k, v))

    def findCaller(self):
        """
        Rewrite this function to correct the caller name 

        Authors: xuruiqi
        """
        f = currentframe()
        if f is not None:
            f = f.f_back
        rv = "(unknown file)", 0, "(unknown function)"
        while hasattr(f, "f_code"):
            co = f.f_code
            filename = os.path.normcase(co.co_filename)
            if _srcfile_dict.get(filename, None):
                f = f.f_back
                continue
            rv = (co.co_filename, f.f_lineno, co.co_name)
            break
        return rv

    def trace(self, msg, *args, **kwargs):
        if self.isEnabledFor(TRACE):
            self._log(TRACE, msg, args, **kwargs)

    def startTimer(self, name):
        if not thread:
            return None
        else:
            trace_timers = self.getLoggerData("trace_timers", None)
            if trace_timers is None:
                self.setLoggerData("trace_timers", {})
                trace_timers = self.getLoggerData("trace_timers", None)

            trace_timers[name] = currentMilliTime()
            return trace_timers.get(name)

    def endTimer(self, name):
        """
        Authors: xuruiqi

        Returns: milliseconds in int
        """
        if not thread:
            return None
        else:
            trace_timers = self.getLoggerData("trace_timers", None)
            if trace_timers is None or \
                    trace_timers.get(name, None) is None:
                return None

            gap = "%d" % (currentMilliTime() - trace_timers.pop(name, 0))

            self.pushNotice("Timer_%s" % name, gap)

            return gap

    @contextmanager
    def timer(self, name):
        """a with statement timer, usage: 
            with ttlogging.Timer("test"):
                # do something
            
        Authors: xuruiqi
        """
        st = currentMilliTime()

        try:
            yield st
        except Exception as e:
            raise e
        finally:
            gap = "%d" % (currentMilliTime() - st)
            self.pushNotice("Timer_%s" % name, gap)

    def addCounter(self, name, delta = 1):
        if not thread:
            return None
        else:
            trace_counters = self.getLoggerData("trace_counters", None)
            if trace_counters is None:
                self.setLoggerData("trace_counters", {})
                trace_counters = self.getLoggerData("trace_counters", None)

            if trace_counters.get(name, None) is None:
                trace_counters[name] = 0

            trace_counters[name] = \
                    trace_counters.get(name, 0) + delta
            return trace_counters.get(name, 0)

Logger.__name__ = "ttlogging.Logger"

class RootLogger(Logger):
    def __init__(self, level):
        Logger.__init__(self, "root", level)

def getLoggerClass():
    return logging.getLoggerClass()

def setLoggerClass(klass):
    if klass != Logger:
        if not issubclass(klass, Logger):
            raise TypeError("logger not derived from " \
                    "ttlogging.Logger:" + klass.__name__)

    logging.setLoggerClass(klass)

#setLoggerClass(Logger)
root = RootLogger(INFO)
Logger.root = root
Logger.manager = logging.Manager(Logger.root)
Logger.manager.setLoggerClass(Logger) #!important

def critical(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.critical(msg, *args, **kwargs)

fatal = critical

def error(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.error(msg, *args, **kwargs)

def exception(msg, *args, **kwargs):
    kwargs["exc_info"] = 1
    error(msg, *args, **kwargs)

def trace(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.trace(msg, *args, **kwargs)

def warning(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.warning(msg, *args, **kwargs)

warn = warning

def info(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.info(msg, *args, **kwargs)

def debug(msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.debug(msg, *args, **kwargs)

def log(level, msg, *args, **kwargs):
    if len(root.handlers) == 0:
        basicConfig()
    root.log(level, msg, *args, **kwargs)

def pushNotice(k, v):
    if len(root.handlers) == 0:
        basicConfig()
    root.pushNotice(k, v)

def flushTrace(msg="Flushtrace", flushall=True):
    if len(root.handlers) == 0:
        basicConfig()
    root.flushTrace(msg=msg, flushall=flushall)

def clearTrace():
    if len(root.handlers) == 0:
        basicConfig()
    root.clearTrace()

def startTimer(name):
    if len(root.handlers) == 0:
        basicConfig()
    return root.startTimer(name)

def endTimer(name):
    if len(root.handlers) == 0:
        basicConfig()
    return root.endTimer(name)

def addCounter(name, delta = 1):
    if len(root.handlers) == 0:
        basicConfig()
    return root.addCounter(name, delta)

@contextmanager
def timer(name):
    if len(root.handlers) == 0:
        basicConfig()
    with root.timer(name) as st_milli_timestamp:
        yield st_milli_timestamp

def getLogger(name=None):
    if name:
        return Logger.manager.getLogger(name)
    else:
        return root

def disable(level):
    root.manager.disable = level

def basicConfig(**kwargs):
    """Do basic configuration for the ttloging system
    """
    _acquireLock()
    try:
        if len(root.handlers) == 0:
            filename = kwargs.get("filename")
            if filename:
                mode = kwargs.get("filemode", "a")
                hdlr = FileHandler(filename, mode)
            else:
                stream = kwargs.get("stream")
                hdlr = StreamHandler(stream)
            fs = kwargs.get("format", BASIC_FORMAT)
            dfs = kwargs.get("datefmt", None)
            fmt = Formatter(fs, dfs)
            hdlr.setFormatter(fmt)
            root.addHandler(hdlr)
            level = kwargs.get("level")
            if level is not None:
                root.setLevel(level)
    finally:
        _releaseLock()

# coding: utf8
"""
Useful handlers for toutiao environment

Authors: xuruiqi
"""

import codecs
import logging.handlers
import os
import time

from filelock import FileLock

class TimedRotatingFileHandler(logging.handlers.TimedRotatingFileHandler):
    """
    This handler uses file locks to ensure its correctness under
    multi processes/multi thread environment.

    NOTE: DO NOT USE THIS HANDLER OR ANY LOGGER WITH THIS HANDLER
        IN A SIGNAL HANDLING FUNCTION, IT MAY CAUSE A DEADLOCK.
        FOR MORE, PLEASE REFER TO: 
            https://wiki.bytedance.com/pages/viewpage.action?pageId=51356544

    Authors: pyutil.program.multi_process_logger author, xuruiqi

    """

    def __init__(self, filename, when="h", interval=1,
            backupCount=0, encoding=None, delay=False, utc=False):

        logging.handlers.TimedRotatingFileHandler.__init__(
                self, filename, when, interval, backupCount,
                encoding, delay, utc)
        
        d, f = os.path.split(filename)
        self.lock_file_name = os.path.join(d, "." + f)

    def computeRollover(self, currentTime):
        """
        Work out the rollover time based on the specified time.
        """
        if self.when == "MIDNIGHT" or self.when.startswith("W"):
            result = logging \
                    .handlers \
                    .TimedRotatingFileHandler \
                    .computeRollover(self, currentTime)
        else:
            result = currentTime + self.interval - \
                    currentTime % self.interval

        return result

    def updateRolloverAt(self, currentTime = -1):
        """手动更新rolloverAt，这个handler在多个进程同时往一个文件打时
        如果不同进程的打印频率相差太大，可能会造成日志切分有问题，详见：
            https://wiki.bytedance.com/pages/viewpage.action?pageId=62440892

        Authors xuruiqi
        """

        if currentTime <= 0:
            currentTime = int(time.time())

        # dst即Daylight saving time
        # 1即目前为夏令时
        # 0即目前非夏令时
        # -1为未知
        dstNow = time.localtime(currentTime)[-1]

        # 更新下一次rollover的时间
        # 正常而言是当前时间 + interval - 当前时间 % interval
        # 下面的while语句在非极端情况下都不会执行
        newRolloverAt = self.computeRollover(currentTime)
        while newRolloverAt <= currentTime:
            newRolloverAt = newRolloverAt + self.interval

        # 针对0点切分以及以周为单位进行切分的日志要进行处理
        # 可能当前非夏令时，而在切分时正好变为夏令时
        # 可能当前为夏令时，而在切分时正好变非夏令时
        if (self.when == "MIDNIGHT" or self.when.startswith("W")) \
                and not self.utc:
            dstAtRollover = time.localtime(newRolloverAt)[-1]
            if dstNow != dstAtRollover: # 切分前后的夏令时状态不同
                if not dstNow:
                    # 当前非夏令时，切分时处于夏令时
                    # 因此在切分时时钟已经往前拨了1个小时
                    # 要减去1个小时
                    # 例如：当前是0点，下一次切分是24点
                    #   而在2点时发生了夏令时切换，时间变为3点
                    #   则实际切分时已经是第二天的凌晨1点
                    #   此时切分会导致24点~第二天凌晨1点的日志
                    #       被切分到当天，与约定不一致
                    #   因此应当提前一个小时进行切分
                    addend = -3600
                else:
                    # 与上面的道理一样
                    addend = 3600
                newRolloverAt += addend
        self.rolloverAt = newRolloverAt

    def doRollover(self):
        """
        Consider the following two situations:

        1.The target renaming file exists, that means some other
            program has already finished rollover, so this process
            should:
            a) reopen
            b) update the next rollover time

        2.The target renaming file does not exist, this process
            has acquired the file lock, then:
            a) rename the log file
            b) clear old log files
            c) reopen
            d) update the next rollover time
        """

        if self.stream:
            self.stream.close()
            self.stream = None

        currentTime = int(time.time())
        dstNow = time.localtime(currentTime)[-1]
        t = self.rolloverAt - self.interval

        if self.utc:
            timeTuple = time.gmtime(t)
        else:
            timeTuple = time.localtime(t)
            dstThen = timeTuple[-1]
            if dstNow != dstThen:
                if dstNow:
                    addend = 3600
                else:
                    addend = -3600
                timeTuple = time.localtime(t + addend)

        dfn = self.baseFilename + "." + \
                time.strftime(self.suffix, timeTuple)

        with FileLock(self.lock_file_name):
            if not os.path.exists(dfn):
                # this process is the first to acquire the
                # file lock, start real rollover

                if os.path.exists(self.baseFilename):
                    os.rename(self.baseFilename, dfn)

                if self.backupCount > 0:
                    # remove old file
                    for ofn in self.getFilesToDelete():
                        os.remove(ofn)

        # Ignore the effect of self.delay, directly reopen 
        #   a new log file, which is suitable for our online
        #   environment
        self.stream = self._open()

        # Update the next rollover time
        newRolloverAt = self.computeRollover(currentTime)
        while newRolloverAt <= currentTime:
            newRolloverAt = newRolloverAt + self.interval

        # Because of the while loop above, adjust rollover time 
        # according to dst,
        if (self.when == "MIDNIGHT" or self.when.startswith("W")) and \
                not self.utc:
            dstAtRollover = time.localtime(newRolloverAt)[-1]
            if dstNow != dstAtRollover:
                if not dstNow:
                    addend = -3600
                else:
                    addend = 3600
                newRolloverAt += addend
        self.rolloverAt = newRolloverAt

class FixedSuffixFileHandler(logging.handlers.TimedRotatingFileHandler):
    """
    This handler log to file with a time suffix, determined by 
        the current datetime.
    Less cumbersome problems.
    Virtualized environments must use this handler to avoid
        problems that may be caused by TimedRotatingFileHandler.

    Authors xuruiqi
    """
    def __init__(self, filename, when="h", interval=1,
            backupCount=0, encoding=None, delay=False, utc=False):

        # backupCount加1是因为父类执行删除时是删除带后缀的
        # 则目前带后缀的文件固定比以往多一个，因此要加1
        logging.handlers.TimedRotatingFileHandler.__init__(
            self, filename, when, interval,
            0 if backupCount == 0 else backupCount + 1,
            encoding, delay, utc
        )

        d, f = os.path.split(filename)
        self.lock_file_name = os.path.join(d, "." + f)

        # 基类打开的文件不正确，要关闭然后重新调用我们写的函数进行打开
        if self.stream:
            self.stream.close()
            self.stream = None
        self.stream = self._realopen()


    def computeRollover(self, currentTime):
        if self.when == "MIDNIGHT" or self.when.startswith("W"):
            result = logging \
                    .handlers \
                    .TimedRotatingFileHandler \
                    .computeRollover(self, currentTime)
        else:
            result = currentTime + self.interval - \
                    currentTime % self.interval

        return result

    def updateRolloverAt(self, currentTime = -1):
        if currentTime <= 0:
            currentTime = int(time.time())

        # dst即Daylight saving time
        # 1即目前为夏令时
        # 0即目前非夏令时
        # -1为未知
        dstNow = time.localtime(currentTime)[-1]

        # 更新下一次rollover的时间
        # 正常而言是当前时间 + interval - 当前时间 % interval
        # 下面的while语句在非极端情况下都不会执行
        newRolloverAt = self.computeRollover(currentTime)
        while newRolloverAt <= currentTime:
            newRolloverAt = newRolloverAt + self.interval

        # 针对0点切分以及以周为单位进行切分的日志要进行处理
        # 可能当前非夏令时，而在切分时正好变为夏令时
        # 可能当前为夏令时，而在切分时正好变非夏令时
        if (self.when == "MIDNIGHT" or self.when.startswith("W")) \
                and not self.utc:
            dstAtRollover = time.localtime(newRolloverAt)[-1]
            if dstNow != dstAtRollover: # 切分前后的夏令时状态不同
                if not dstNow:
                    # 当前非夏令时，切分时处于夏令时
                    # 因此在切分时时钟已经往前拨了1个小时
                    # 要减去1个小时
                    # 例如：当前是0点，下一次切分是24点
                    #   而在2点时发生了夏令时切换，时间变为3点
                    #   则实际切分时已经是第二天的凌晨1点
                    #   此时切分会导致24点~第二天凌晨1点的日志
                    #       被切分到当天，与约定不一致
                    #   因此应当提前一个小时进行切分
                    addend = -3600
                else:
                    # 与上面的道理一样
                    addend = 3600
                newRolloverAt += addend
        self.rolloverAt = newRolloverAt

    def _realopen(self, currentTime = -1):
        # 计算当前的时间后缀
        if currentTime < 0:
            currentTime = int(time.time())
        if self.utc:
            timeTuple = time.gmtime(currentTime)
        else:
            timeTuple = time.localtime(currentTime)

        dfn = self.baseFilename + "." + \
                time.strftime(self.suffix, timeTuple)
        
        if self.encoding is None:
            stream = open(dfn, self.mode)
        else:
            stream = codecs.open(dfn, self.mode, self.encoding)

        # 创建软链
        with FileLock(self.lock_file_name):
            source_name = os.path.join(".", os.path.split(dfn)[1])
            if os.path.exists(self.baseFilename) \
                    and os.path.islink(self.baseFilename) \
                    and os.readlink(self.baseFilename) == source_name:
                # 正确的软链已经被创建
                pass
            else:
                try:
                    os.remove(self.baseFilename)
                except:
                    pass
                os.symlink(source_name, self.baseFilename)

        return stream

    def doRollover(self):
        """直接以"a"模式打开新文件并写入即可

        Authors xuruiqi
        """
        if self.stream:
            self.stream.close()
            self.stream = None

        currentTime = int(time.time())
        self.stream = self._realopen(currentTime)

        if self.backupCount > 0:
            for ofn in self.getFilesToDelete():
                os.remove(ofn)

        self.updateRolloverAt(currentTime)

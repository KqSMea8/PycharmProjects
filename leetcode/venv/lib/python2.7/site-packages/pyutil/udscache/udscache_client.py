import time, logging, gc
import msgpack
from pyutil.program import  metrics
import memcache

class UDSCacheClient(object):
    s_metric_prefix = 'inf.udscacheclient'

    @staticmethod
    def pack(obj):
        return msgpack.dumps(obj)
    
    @staticmethod
    def unpack(buf):
        gc.disable() 
        res = msgpack.loads(buf, use_list=True)
        gc.enable()
        return res

    @staticmethod
    def init_metrics(category_name):
        metrics.init({"metrics_namespace_prefix":UDSCacheClient.s_metric_prefix})
        metrics.define_tagkv('category',[category_name])
        metrics.define_tagkv('cmd',['get','set', 'mget', 'mset'])
        metrics.define_counter("throughput")
        metrics.define_timer("latency")
        metrics.define_counter("hits")
        metrics.define_counter("misses")
        metrics.define_counter("fail")
        metrics.define_counter("bytes_written")
        metrics.define_counter("bytes_read")
        metrics.define_timer('batch_num')
 

    def __init__(self, abs_path, category="default", timeout=900, logging=1, debug=0, decode=True):
        self.__uds_sock_path = "unix:%s"%(abs_path)
        self.__timeout = timeout
        self.__category = category
        self.decode = decode

        UDSCacheClient.init_metrics(category)
        self.client = memcache.Client([self.__uds_sock_path], debug=debug, logging=logging)
     
    def __record_metrics(self, tags, latency, succ, hits, misses):
        metrics.emit_counter("throughput", 1, tagkv=tags)
        metrics.emit_timer("latency", latency*1000000, tagkv=tags)
        if succ is not None and succ is False:
            metrics.emit_counter('fail', 1, tagkv=tags)
        if hits is not None:
            metrics.emit_counter("hits", hits, tagkv=tags)
        if misses is not None:
            metrics.emit_counter("misses", misses, tagkv=tags)

  
    def record_batch_metrics(self, cmd, latency, succ, batch_num, hits=None, misses=None):
        tags = {"category":self.__category, "cmd":cmd}
        metrics.emit_timer('batch_num', batch_num, tagkv=tags) 
        self.__record_metrics(tags, latency, succ, hits, misses)
     
    def record_single_metrics(self, cmd, latency, succ, bytes_read=0, bytes_written=0, hits=None, misses=None):
        tags = {"category":self.__category, "cmd":cmd}
        if bytes_read > 0:
            metrics.emit_counter("bytes_read", bytes_read, tagkv=tags)
        if bytes_written > 0:
            metrics.emit_counter("bytes_written", bytes_written, tagkv=tags)
        self.__record_metrics(tags, latency, succ, hits, misses)

    def mget(self, keys):
        ts = time.time()
        try:
            res_map = self.client.get_multi(keys)
            if self.decode:
                res = {key : self.unpack(val) for key, val in res_map.iteritems()}
            else:
                res = res_map 
        except:
            logging.exception("udscacheclient mget exception")
            res = {}
        finally:
            self.record_batch_metrics("mget", time.time() - ts, None, 
                                len(keys), len(res), len(keys) - len(res))
            return res

    def get(self, key, default_value=None):
        res, ts = None, time.time()
        try:
            res = self.client.get(key)
            if res:
                if self.decode:
                    res = self.unpack(res)
                return res 
            return default_value
        except:
            logging.exception("udscacheclient get exception")
            res = None
            return default_value
        finally:
            self.record_single_metrics("get", time.time() - ts, None, 
                                len(str(res)) if res is not None else 0,
                                0, 
                                1 if res is not None else 0, 
                                1 if res is None else 0 )


    def mset(self, mapping, timeout=None):
        try:
            ts = time.time()
            if self.decode:
                bin_mapping = {key:self.pack(val) for key, val in mapping.iteritems()}
            else:
                bin_mapping = mapping 
            notset_keys = self.client.set_multi(bin_mapping, timeout if timeout else self.__timeout)
            return notset_keys
        except:
            logging.exception("udscacheclient mset exception")
            return mapping.keys()
        finally:
            self.record_batch_metrics("mset", time.time() - ts, len(notset_keys) == 0, 
                                len(mapping))

    def set(self, key, val, timeout=None):
        res, buf, ts = 0, "", time.time()
        try:
            if self.decode:
                buf = self.pack(val)
            else:
                buf = val
            res = self.client.set(key, buf, timeout if timeout else self.__timeout)
            return res
        except:
            logging.exception("udscacheclient set exception")
            return 0
        finally:
            self.record_single_metrics("set", time.time() - ts, res != 0, 0, len(buf), None)


    def put(self, key, val, timeout=None):
        return self.set(key, val, timeout)


def main():
    mc = UDSCacheClient("/home/jinjingting/repos/mc.socket", timeout=200)
    for i in range(10):
        #d={'abc':1.2, '34f':0.131, 'i':i}
        #print mc.set("abc", d)
        #time.sleep(0.2)
        #print mc.get("abc")
        mapping = {'k1':123, 'k2':456}
        print mc.mset(mapping)
        print mc.mget(mapping.keys())
        print mc.mget(['aaa', 'k1'])

if __name__ == "__main__":
    main()

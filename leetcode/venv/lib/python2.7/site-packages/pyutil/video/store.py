#!/usr/bin/env python
# coding=utf8
import logging
import signal
import os
import argparse
import thread
import shutil
import copy
from cStringIO import StringIO

from pyutil.video.converter import Converter
from pyutil.thrift.thrift_util import ThriftClient
from pyutil.image.store import ImageStoreHelper
from pyutil.alarm.alarm_handler import AlarmHandler
from songshulin.imagestore.ttypes import Blob, PutReq, GetReq, GetStatus, PutStatus
from songshulin.imagestore import ImageStore
from PIL import Image


logger = logging.getLogger(__file__)
logger.setLevel(logging.INFO)
logger.addHandler(AlarmHandler(subject='[STORE_ERROR] pyutil/video/store', recipient_list=['zhenghuabin@bytedance.com', 'houmingqiang@bytedance.com']))

_FF_BIN = '/opt/tiger/ss_bin'
_FFMPEG = os.path.join(_FF_BIN, 'ffmpeg')
_FFPROBE = os.path.join(_FF_BIN, 'ffprobe')

_DEST_FORMAT = 'mp4'
_DEST_ACODEC = 'aac'
_DEST_VCODEC = 'h264'
_MIN_VBITRATE = 128

_WATER_MARK_PATH = '/opt/tiger/pyutil/pyutil/video/watermark/'

DEFAULT_CONV_OPTS = {
    'origin': {
        'format': 'mp4',
        'audio': {
            'codec': 'aac',
            'samplerate': 44100,
            'bitrate': 64
            },
        'video': {
            'codec': 'h264',
            'fps': 20,
            'profile': 'baseline',
            'preset': 'veryfast'
            }
        },

    'p360': {
        'format': 'mp4',
        'audio': {
            'codec': 'aac',
            'samplerate': 44100,
            'bitrate': 64
            },
        'video': {
            'codec': 'h264',
            'fps': 20,
            'profile': 'baseline',
            'preset': 'veryfast',
            'watermark': str(_WATER_MARK_PATH) + '720.png',
            'wm_width': 200,
            'wm_height': 40,
            'filtergraph': 'overlay=10:10'
            },
        'map': 0,
        'map_metadata': -1
        },
    'p480': {
        'format': 'mp4',
        'audio': {
            'codec': 'aac',
            'samplerate': 44100,
            'bitrate': 64
            },
        'video': {
            'codec': 'h264',
            'fps': 20,
            'profile': 'baseline',
            'preset': 'veryfast',
            'watermark': str(_WATER_MARK_PATH) + '720.png',
            'wm_width': 200,
            'wm_height': 40,
            'filtergraph': 'overlay=11:11'
            },
        'map': 0,
        'map_metadata': -1
        },
    'p720': {
        'format': 'mp4',
        'audio': {
            'codec': 'aac',
            'samplerate': 44100,
            'bitrate': 64
            },
        'video': {
            'codec': 'h264',
            'fps': 20,
            'profile': 'baseline',
            'preset': 'veryfast',
            'watermark': str(_WATER_MARK_PATH) + '720.png',
            'wm_width': 200,
            'wm_height': 40,
            'filtergraph': 'overlay=15:15'
            },
        'map': 0,
        'map_metadata': -1
        }
}

DEFAULT_DEST_VIDEO_SIZE = 5 * 1024 * 1024

def get_image_rotate(rotate):
    if rotate == 90:
        return Image.ROTATE_270
    if rotate == 180:
        return Image.ROTATE_180
    if rotate == 270:
        return Image.ROTATE_90
    logger.error("unexpected rotate: %d", rotate)
    return Image.ROTATE_90


class VideoResolution(object):
    ORIGIN = 1
    P720 = 2
    P480 = 4
    P360 = 8
    _TO_NAMES = {
        ORIGIN: "origin",
        P720: "p720",
        P480: "p480",
        P360: "p360",
    }
    _TO_VALUES = {
        "origin": ORIGIN,
        "p720": P720,
        "p480": P480,
        "p360": P360,
    }

    @classmethod
    def name(cls, resolution):
        return cls._TO_NAMES[resolution]

    @classmethod
    def value(cls, name):
        return cls._TO_VALUES[name]


class VideoWH(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height


def get_tmpfile_name(tmp_dir, resolution):
    return os.path.join(tmp_dir, VideoResolution.name(resolution))


class TmpDirCreator(object):
    def __init__(self):
        self.d = None

    def __enter__(self):
        tid = thread.get_ident()
        self.d = os.path.join('/tmp/video_%s' % tid)
        try:
            os.mkdir(self.d)
        except Exception as e:
            logger.error("mkdir %s failed, err=%s", self.d, e)
        else:
            logger.info("mkdir: %s", self.d)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.d:
            shutil.rmtree(self.d, ignore_errors=True)
            logger.info("rmtree: %s", self.d)


class VideoStoreHelper(object):
    DEST_VIDEO_SIZE = 5 * 1024 * 1024
    def __init__(self, video_servers, image_servers=None, dest_video_size=None):
        self.dest_video_size = dest_video_size or DEFAULT_DEST_VIDEO_SIZE
        if image_servers is None:
            image_servers = video_servers
        self._image_servers = image_servers
        self._video_store = ThriftClient(video_servers, ImageStore.Client, 50000)
        self._accessor = VideoAccessor(self._video_store, self.dest_video_size)

    def __enter__(self):
        try:
            self._video_store.open()
        except Exception as e:
            logger.exception(e)
        return self

    def __exit__(self, type, value, traceback):
        try:
            self._video_store.close()
        except Exception as e:
            logger.exception(e)


    def put(self, body, url=None):
        """
        save video binary data to store
        :param body: video data
        :return: (uri, meta) on success, or (None, {}) if failed
        Exception: raise on error input
        """
        if body is None:
            raise Exception('VideoStoreHelper: put body is None, url=%s' % url)
        with TmpDirCreator() as tmp_dir:
            (uri, meta) = self._accessor.put(body, tmp_dir.d)
            if uri:
                self.store_cover(tmp_dir.d, meta)
                logger.info('put video uri=%s, meta=%s, url=%s', uri, meta, url)
            else:
                logger.error('put video failed, url=%s', url)
            return (uri, meta)

    def get(self, uri, resolution):
        """
        get the video binary data from store
        :param uri:
        :param resolution: video resolution type
        :return: binary data of the video file, or None if file does not exist
        """
        try:
            rsp = self._video_store.get(GetReq(uri, resolution))
        except Exception as e:
            logger.exception("get %s,uri=%s,resolution=%s", e, uri, VideoResolution.name(resolution))
            return None
        if rsp.status != GetStatus.OK:
            logger.warning("get status=%s,uri=%s,resolution=%s", GetStatus._VALUES_TO_NAMES[rsp.status],
                         uri, VideoResolution.name(resolution))
            return None
        return rsp.blobs[0].data


    def exists(self, uri, verify_data=False):
        """
        test if a uri exists
        :param uri:
        :param verify_data:
        :return: True if the uri exists
        """
        try:
            status = self._video_store.exists(uri, verify_data)
        except Exception as e:
            logger.exception("exist %s", e)
            return False
        if status == GetStatus.OK:
            return True
        elif status in (GetStatus.FAIL_NOT_EXIST, GetStatus.FAIL_DELETED):
            return False
        else:
            logger.error("exist status=%s", GetStatus._VALUES_TO_NAMES[status])
            return False

    def remove(self, uri):
        """
        remove video files of all resolutions associated with the given uri
        :param uri:
        :return: True if the uri is removed, False does not necessarily indicate remove failed,
            it may be network errors
        """
        try:
            deleted = self._video_store.mark_deleted(uri)
        except Exception as e:
            logger.exception("remove uri=%s, err=%s", uri, e)
            return False
        return deleted

    def store_cover(self, tmp_dir, meta):
        duration = meta[VideoResolution.name(VideoResolution.ORIGIN)]['duration']
        origin_file = get_tmpfile_name(tmp_dir, VideoResolution.ORIGIN)
        cover_image = os.path.join(tmp_dir, "cover.jpg")
        cmd = "{ffmpeg} -y -loglevel error -ss {start_time} -i {infile} -f image2 -vframes 1 {outfile}".format(
            ffmpeg=_FFMPEG, infile=origin_file, outfile=cover_image, start_time=0)
        ret = os.system(cmd)
        if ret != 0:
            logger.error("gen cover image failed, cmd=%s", cmd)
            return False

        # save to image store
        with open(cover_image, 'rb') as fp:
            data = fp.read()
            rotate = meta[VideoResolution.name(VideoResolution.ORIGIN)]['rotate']
            if rotate != 0:
                image = Image.open(StringIO(data))
                image = image.transpose(get_image_rotate(rotate))
                out_fp = StringIO()
                image.save(out_fp, format='jpeg')
                data = out_fp.getvalue()

        with ImageStoreHelper(self._image_servers) as helper:
            uri = helper.put(data)
        if uri:
            meta['cover_uri'] = uri
            return True
        else:
            logger.error("store cover image failed")
            return False


class VideoAccessor(object):
    P = (VideoResolution.P720, VideoResolution.P480, VideoResolution.P360)
    PN = ("P720", "P480", "P360")
    WH = (VideoWH(1280, 720), VideoWH(720, 480), VideoWH(640, 360))

    def __init__(self, store_helper, dest_video_size):
        self._store_helper = store_helper
        self.dest_video_size = dest_video_size

    def find_first_scale_resolution(self, origin_meta):
        for i, wh in enumerate(self.WH):
            if origin_meta['width'] > wh.width or origin_meta['height'] > wh.height:
                return i
        else:
            return i + 1

    def get_meta(self, path):
        info = Converter(ffmpeg_path=_FFMPEG, ffprobe_path=_FFPROBE).probe(path)
        meta = {}
        meta['format'] = info.format.format
        if info.audio:
            meta['acodec'] = info.audio.codec
        else:
            meta['acodec'] = None
        meta['vcodec'] = info.video.codec
        meta['duration'] = int(info.format.duration)
        meta['width'] = int(info.video.video_width)
        meta['height'] = int(info.video.video_height)
        meta['rotate'] = int(info.video.metadata.get('rotate', '0'))
        if meta['rotate'] == 270 or meta['rotate'] == 90:
            (meta['height'], meta['width']) = (meta['width'], meta['height'])
        logger.info(meta)
        return meta

    def convert(self, infile, inmeta, tmp_dir, resolution, video_bitrate):
        """
        :param infile:
        :param inmeta:
        :param tmp_dir:
        :param resolution:
        :return:
        """
        outfile = get_tmpfile_name(tmp_dir, resolution)
        opts = copy.deepcopy(DEFAULT_CONV_OPTS[VideoResolution.name(resolution)])

        if video_bitrate:
            opts['video']['bitrate'] = video_bitrate
        if 'rotate' in inmeta:
            opts['video']['rotate'] = inmeta['rotate']
        logger.info('convert resolution=%s, opts=%s', VideoResolution.name(resolution), opts)
        conv = Converter(ffmpeg_path=_FFMPEG, ffprobe_path=_FFPROBE).convert(infile=infile, outfile=outfile,
                                                                             options=opts, timeout=None)
        for _ in conv:
            pass
        meta = copy.copy(inmeta)
        meta['format'] = _DEST_FORMAT
        meta['acodec'] = inmeta['acodec'] and _DEST_ACODEC or None
        meta['vcodec'] = _DEST_VCODEC
        return outfile, meta

    def scale(self, infile, inmeta, tmp_dir, resolution, wh, video_bitrate):
        """
        :param infile:
        :param inmeta:
        :param tmp_dir:
        :param resolution: 目标视频分辨率
        :param wh: 目标宽高
        :return:
        """
        outfile = get_tmpfile_name(tmp_dir, resolution)
        width = inmeta['width']
        height = inmeta['height']
        if inmeta['rotate'] == 270 or inmeta['rotate'] == 90:
            (width, height) = (height, width)
        if width > wh.width:
            height = int(height * wh.width / width) or 1
            width = wh.width
        if height > wh.height:
            width = int(width * wh.height / height) or 1
            height = wh.height
        # width and height are required to be event
        width = (width + 1) & (~1)
        height = (height + 1) & (~1)
        if inmeta['rotate'] == 270 or inmeta['rotate'] == 90:
            (width, height) = (height, width)

        opts = copy.deepcopy(DEFAULT_CONV_OPTS[VideoResolution.name(resolution)])
        opts['video']['width'] = width
        opts['video']['height'] = height
        opts['video']['rotate'] = inmeta['rotate']
        if video_bitrate:
            opts['video']['bitrate'] = video_bitrate
        logger.info('scale resolution=%s, opts=%s', VideoResolution.name(resolution), opts)
        conv = Converter(ffmpeg_path=_FFMPEG, ffprobe_path=_FFPROBE).convert(infile=infile, outfile=outfile,
                                                                             options=opts, timeout=None)
        for _ in conv:
            pass

        meta = copy.copy(inmeta)
        meta['format'] = _DEST_FORMAT
        meta['acodec'] = inmeta['acodec'] and _DEST_ACODEC or None
        meta['vcodec'] = _DEST_VCODEC
        meta['width'] = width
        meta['height'] = height
        return outfile, meta

    def compress_origin(self, infile, filesize, duration):
        """
        根据目标文件大小和视频时长计算bit rate，并设定相应参数进行压缩
        :param infile:
        :param filesize:
        :return:
        """
        total_bit_rate = self.dest_video_size * 8 / 1024 / duration
        video_bitrate = total_bit_rate - DEFAULT_CONV_OPTS['origin']['audio']['bitrate']
        if video_bitrate < _MIN_VBITRATE:
            raise Exception(
                'Can not compress origin file to limited size, filesize=%.1fMB, limited=%.1fMB, duration=%d' % (
                    float(filesize) / 1024 / 1024, float(self.dest_video_size) / 1024 / 1024, duration))

        # rename origin video file
        infile_copy = infile + '.copy'
        ret = os.system('mv %s %s' % (infile, infile_copy))
        if ret != 0:
            raise Exception("rename origin file failed rc=%d", ret)
        opts = copy.deepcopy(DEFAULT_CONV_OPTS['origin'])
        opts['video']['bitrate'] = video_bitrate
        conv = Converter(ffmpeg_path=_FFMPEG, ffprobe_path=_FFPROBE).convert(infile=infile_copy, outfile=infile,
                                                                             options=opts, timeout=None)
        for _ in conv:
            pass
        meta = self.get_meta(infile)
        return meta, video_bitrate

    def save_origin(self, data, tmp_dir):
        """
        :param data:
        :param tmp_dir:
        :return:
        """
        outfile = get_tmpfile_name(tmp_dir, VideoResolution.ORIGIN)
        with open(outfile, 'wb') as fp:
            fp.write(data)
            fp.flush()
        meta = self.get_meta(outfile)
        return outfile, meta

    def fixup_wh(self, metas):
        for _, v in VideoResolution._TO_NAMES.iteritems():
            meta = metas.get(v)
            if not meta:
                continue
            meta['width'], meta['height'] = meta['height'], meta['width']

    def put(self, body, tmp_dir):
        metas = {}
        failed_result = (None, {})
        video_bitrate = None
        try:
            file, meta = self.save_origin(body, tmp_dir)
        except Exception as e:
            logger.exception(e)
            return failed_result

        if len(body) > self.dest_video_size:
            meta, video_bitrate = self.compress_origin(file, len(body), meta['duration'])
        metas[VideoResolution.name(VideoResolution.ORIGIN)] = meta

        # 生成其它尺寸
        idx = self.find_first_scale_resolution(meta)
        generated_files_idx = []
        if idx > 0:
            conv_resolution_idx = idx - 1
            try:
                resolution = self.P[conv_resolution_idx]
                outfile, outmeta = self.convert(file, meta, tmp_dir, resolution, video_bitrate)
                generated_files_idx.append(conv_resolution_idx)
                metas[VideoResolution.name(resolution)] = outmeta
            except Exception as e:
                logger.exception(e)
                return failed_result

        for i in range(idx, len(self.P)):
            try:
                resolution = self.P[i]
                outfile, outmeta = self.scale(file, meta, tmp_dir, resolution, self.WH[i], video_bitrate)
                generated_files_idx.append(i)
                metas[VideoResolution.name(resolution)] = outmeta
            except Exception as e:
                logger.exception(e)
                return failed_result

        # convert ok, put blobs to store
        videos = []
        with open(get_tmpfile_name(tmp_dir, VideoResolution.ORIGIN), 'rb') as fp:
            data = fp.read()
            videos.append(Blob(data=data))
        for i in range(len(self.P)):
            if i not in generated_files_idx:
                videos.append(Blob())
            else:
                resolution = self.P[i]
                with open(get_tmpfile_name(tmp_dir, resolution), 'rb') as fp:
                    data = fp.read()
                    videos.append(Blob(data=data))

        req = PutReq(videos)
        try:
            rsp = self._store_helper.put(req)
        except Exception as e:
            logger.exception("store_helper put: %s", e)
            return failed_result
        if rsp.status != PutStatus.OK:
            logger.error("store_helper put status: %d", rsp.status)
            return failed_result

        rotate = metas[VideoResolution.name(VideoResolution.ORIGIN)]['rotate']

        return rsp.uri, metas


def main():
    signal.signal(signal.SIGTERM, signal.SIG_DFL)
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    parser = argparse.ArgumentParser()
    parser.add_argument('--store-servers', default='127.0.0.1:19898', dest='store_servers',
                        help='store backend servers')
    parser.add_argument('--infile', dest='infile', required=True, help='input video file')
    args = parser.parse_args()
    logging.info('videostore start ...')
    servers = []
    for hp in args.store_servers.split(','):
        (h, p) = hp.split(':')
        servers.append((h, int(p)))

    with VideoStoreHelper(servers, servers) as h:
        with open(args.infile, 'rb') as fp:
            body = fp.read()
        (uri, meta) = h.put(body)
        if uri:
            logger.info("store success uri: %s" % uri)
            logger.info(meta)
        else:
            logger.fatal("store failed")

        exists = h.exists(uri)
        if exists:
            logger.info("%s exists as expected" % uri)
        else:
            logger.fatal("%s does not exist" % uri)
        data = h.get(uri, VideoResolution.P720)
        if data:
            logger.info("%s get ok" % uri)
            with open('/tmp/video_get_p720', 'wb') as fp:
                fp.write(data)
        else:
            logger.info("%s p720 get failed" % uri)

        data = h.get(uri, VideoResolution.P360)
        if data:
            logger.info("%s get ok" % uri)
            with open('/tmp/video_get_p360', 'wb') as fp:
                fp.write(data)
        else:
            logger.fatal("%s get error" % uri)
        h.remove(uri)
        exists = h.exists(uri, True)
        if exists == True:
            logger.fatal("existed after remove %s" % uri)


if __name__ == '__main__':
    main()

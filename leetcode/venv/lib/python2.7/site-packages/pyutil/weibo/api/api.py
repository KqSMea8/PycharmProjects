#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pyutil.weibo.api.sina import APIClient as SinaAPIClient
from pyutil.weibo.api.sina import APIError as SinaAPIError
from pyutil.weibo.api.tencent import APIClient as TencentAPIClient
from pyutil.weibo.api.tencent import APIError as TencentAPIError
from pyutil.weibo.api.tencent2 import APIClient as TencentAPIClient2
from pyutil.weibo.api.tencent2 import APIError as TencentAPIError2
from pyutil.net import common_opener
from pyutil.net.proxy import get_proxy
import pdb, logging, time, random, json
from datetime import datetime, timedelta
from pyutil.program.db import DAL


class APIError(StandardError):
    '''
    raise APIError contain account info 
    '''
    def __init__(self, platform, error_code, error, request=None, account_id=None, user_connect_id=None, access_token=None, openid=None):
        StandardError.__init__(self, error)
        self.platform = platform
        self.error_code = error_code
        self.error = error
        self.request = request

        self.user_connect_id = user_connect_id
        self.account_id = account_id
        self.access_token = access_token
        self.openid = openid

    def __str__(self):
        if self.platform == 1:
            platform = 'Sina'
        elif self.platform == 2:
            platform = 'Tencent'

        if self.user_connect_id:
            info = ', user_connect_id: %s' % self.user_connect_id
        elif self.account_id:
            info = ', account_id: %s' % self.account_id
        elif self.access_token:
            info = ', access_token: %s' % self.access_token
            if self.openid:
                info += ' openid: %s' % self.openid
        else:
            info = ''
        return '%sAPIError: %s: %s, request: %s%s' % (
                platform, self.error_code, self.error, self.request, info)



class API():
    def __init__(self, conf, platform, app_key, app_secret, user_connect_buffer_size):
        self.conf = conf
        self.app_key = app_key
        self.app_secret = app_secret
        self.platform=platform
        self.user_connect_buffer_size = user_connect_buffer_size 
        self.user_connect_buffer = []
        self.opener = common_opener.get_opener(http_proxy=get_proxy,
                                               https_proxy=get_proxy,
                                               timeout=10,
                                               use_common_headers=False)

        self.webdb_dal = DAL(host=conf.ss_accountdb_offline_host,
                             port=conf.ss_accountdb_offline_port,
                             user=conf.ss_accountdb_offline_user,
                             passwd=conf.ss_accountdb_offline_password,
                             name=conf.ss_accountdb_name)


    def remove_user_connect(self, user_connect_id):
        #self.webdb_dal.execute('update core_user_connect set status=-2 where id=%s' % user_connect_id)
        pass


    def get_access_token_from_user_connect(self, user_connect_id=None):
        if user_connect_id:
            self.webdb_dal.execute('select id, access_token, access_token_secret, expired_time, openid, extra \
                    from core_user_connect where id=%s' % user_connect_id)   
            row = self.webdb_dal.cursor.fetchone()
            row['expires'] = time.mktime(row['expired_time'].timetuple()) 
            clientip = ''
            if row.get('extra'):
                extra_ = json.loads(row['extra'])
                clientip = extra_.get('ip', '')
            row['clientip'] = clientip
            return row 

        # with lock?
        if not self.user_connect_buffer:
            st = time.time()
            self.webdb_dal.execute("""select id, access_token, access_token_secret, expired_time, openid, extra 
                    from core_user_connect where platform_app_id="%s" and status=0 and expired_time > "%s" 
                    order by id desc limit %s """ % (
                    self.platform, datetime.now().strftime('%Y-%m-%d %H:%M'), self.user_connect_buffer_size))

            rows = self.webdb_dal.cursor.fetchall()
            for row in rows:
                row['expires'] = time.mktime(row['expired_time'].timetuple()) 
                clientip = ''
                if row.get('extra'):
                    extra_ = json.loads(row['extra'])
                    clientip = extra_.get('ip', '')
                row['clientip'] = clientip
                self.user_connect_buffer.append(row)
            random.shuffle(self.user_connect_buffer)
            logging.info('get_user_connects: count %s cost %.4f' % (len(self.user_connect_buffer), time.time()-st))
        row = self.user_connect_buffer.pop()
        return row 

    def __getattr__(self, attr):
        def wrap(account_id=None, user_connect_id=None, access_token=None, access_token_secret=None, openid=None, 
                app_key=None, app_secret=None, expires=None, proxy=True, clientip=None, **kw):
            try:

                if not access_token:
                    uc = None
                    if user_connect_id:
                        uc = self.get_access_token_from_user_connect(user_connect_id)
                    elif account_id:
                        pass  # TODO 
                    else:
                        uc = self.get_access_token_from_user_connect()
                    
                    if not uc:
                        raise APIError(self.platform, -1, 'No avaiable user connect')

                    user_connect_id = uc['id'] 
                    access_token = uc['access_token']
                    access_token_secret = uc['access_token_secret']
                    expires = uc['expires']
                    openid = uc['openid'] 
                    clientip = uc['clientip']
                    app_key = app_key or self.app_key
                    app_secret = app_secret or self.app_secret


                if not expires: 
                    expires = time.time() + 86400

                opener = proxy and self.opener or None
                if self.platform == 1:
                    client = SinaAPIClient(app_key, app_secret, opener=opener)
                    client.set_access_token(access_token, expires)
                elif self.platform == 2:
                    if openid:
                        client = TencentAPIClient2(app_key, app_secret, opener=opener)
                        client.set_access_token(access_token, openid, expires)
                    else:
                        client = TencentAPIClient(app_key, app_secret, opener=opener)
                        client.set_access_token(access_token, access_token_secret)

                api = getattr(client, attr)

                # 尽量使用客户端提供的ip
                if self.platform == 2 and clientip:
                    kw['clientip'] = clientip

                # 对于腾通讯OAuth2.0的 '41: check sign error' 重试一次
                if self.platform == 2 and openid:
                    retry = 0
                    while True:
                        try:
                            result = api(**kw)
                            return result
                        except TencentAPIError2, e:
                            if str(e.error_code) == '41' and e.error == 'check sign error':
                                if retry < 2:
                                    retry += 1
                                    logging.warning('retry_tencent_check_sign_error: user_connect_id %s retry %s', user_connect_id, retry)
                                    continue
                            raise

                result = api(**kw)
                return result

            except SinaAPIError, e:
                if e.error=='expired_token' or e.error=='invalid_access_token':
                    if user_connect_id:
                        self.remove_user_connect(user_connect_id)
                    elif account_id:
                        pass #TODO
                raise APIError(self.platform, e.error_code, e.error, e.request,
                        account_id, user_connect_id, access_token)
            except TencentAPIError, e:
                raise APIError(self.platform, e.error_code, e.error, e.request, 
                        account_id, user_connect_id, access_token)
            except TencentAPIError2, e:
                # TODO: 移除对应的UserConnect
                raise APIError(self.platform, e.error_code, e.error, e.request, 
                        account_id, user_connect_id, access_token, openid=openid)
        return wrap



DEFAULT_SINA_USER_CONNECT_APP_KEY = '2504490989' 
DEFAULT_SINA_USER_CONNECT_APP_SECRET = '8ba197824d80d38928470e1ffa4c5618'
DEFAULT_TENCENT_USER_CONNECT_APP_KEY = '801083581' 
DEFAULT_TENCENT_USER_CONNECT_APP_SECRET = 'b679a466f704844a7659c4ec8d758f63'

class SinaAPI(API):
    def __init__(self, conf, user_connect_buffer_size=5000):
        API.__init__(self, conf, 1, 
                DEFAULT_SINA_USER_CONNECT_APP_KEY, 
                DEFAULT_SINA_USER_CONNECT_APP_SECRET,
                user_connect_buffer_size)


class TencentAPI(API):
    def __init__(self, conf, user_connect_buffer_size=2000):
        API.__init__(self, conf, 2,
                DEFAULT_TENCENT_USER_CONNECT_APP_KEY, 
                DEFAULT_TENCENT_USER_CONNECT_APP_SECRET,
                user_connect_buffer_size)


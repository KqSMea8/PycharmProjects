#!/usr/bin/env python
#coding=utf8
import sys, os, logging, random,time
from datetime import datetime
from pyutil.program.pprint import pprint
sys.path.insert(0, '../../../../')
os.environ['DJANGO_SETTINGS_MODULE'] = 'ss_datacenter.djangosite.settings'
from ss_datacenter.djangosite.crawler.models import AccountAccessToken

def test_sina():
    from sina import APIClient
    #APP_KEY = '1234567' # app key
    #APP_SECRET = 'abcdefghijklmn' # app secret
    #CALLBACK_URL = 'http://www.example.com/callback' # callback url
    #在网站放置“使用微博账号登录”的链接，当用户点击链接后，引导用户跳转至如下地址：

    #client = APIClient(app_key=APP_KEY, app_secret=APP_SECRET, redirect_uri=CALLBACK_URL)
    #url = client.get_authorize_url()
    ## TODO: redirect to url
    #用户授权后，将跳转至网站回调地址，并附加参数code=abcd1234：

    ## 获取URL参数code:
    #code = your.web.framework.request.get('code')
    #client = APIClient(app_key=APP_KEY, app_secret=APP_SECRET, redirect_uri=CALLBACK_URL)
    #r = client.request_access_token(code)
    #access_token = r.access_token # 新浪返回的token，类似abc123xyz456
    #expires_in = r.expires_in # token过期的UNIX时间：http://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4
    ## TODO: 在此可保存access token
    client = APIClient(None, None)
    tokens = list(AccountAccessToken.objects.filter(status=1, account__platform_id=1, version=2, account=415))
    t = tokens[1]

    client.set_access_token(t.access_token, t.expires)
    #client.set_access_token('2.00t23EyC6OrxYDda2c63010fJQ3zVB', '1351882800')
    #client.set_access_token(access_token, expires_in)
    #res = client.post.statuses__update(status=u'测试OAuth 2.0发微博')
    #res = client.upload.statuses__upload(status=u'测试OAuth 2.0带图片发微博', pic=open('/Users/michael/test.png'))
    #res = client.get.statuses__user_timeline()
    #res = client.get.statuses__friends_timeline()
    res = client.get.statuses__home_timeline()
    pprint(res)
    print t.account_id, t.access_token, t.expires
    #res = client.get.statuses__hot__repost_daily()
    #res = client.get.statuses__user_timeline(screen_name=user_name)
    #res = client.get.comments__show(id=3497129550834440, page=1, count=2)
    #res = client.get.statuses__show(id=3510386588201919)
    count = 0
    for t in tokens:
        count += 1
        client.set_access_token(t.access_token, t.expires)
        res = client.get.account__rate_limit_status(source=3265059897)
        print 'account: ', t.account_id, 'ip', res['remaining_ip_hits'], 'user ', res['remaining_user_hits']
    #for user_name in (u'陈华Tony', u'李开复', 'Zhou_Jingjin')[2:]:
    #    pprint(user_name)
    #    res = client.get.friendships__friends(screen_name=user_name, count=200)
    #    #pprint(res)
    #    for u in res.users:
    #        pprint((u.id, u.screen_name))
    #    print
    #users = res.users
    #uid_to_user = {u.id: u for u in res.users}
    #tag_counts = {}
    #while True:
    #    cur_users, users = users[:20], users[20:]
    #    res = client.get.tags__tags_batch(uids=','.join(u.idstr for u in cur_users))
    #    for u_tags in res:
    #        pprint(uid_to_user[u_tags.id].screen_name)
    #        pprint(u_tags)
    #        for t in u_tags.tags:
    #            tag_name = [v for k, v in t.items() if k != 'weight'][0]
    #            tag_counts[tag_name] = tag_counts.get(tag_name, 0) + 1
    #    if not users:
    #        break
    #pprint(sorted(tag_counts.items(), key=lambda x: x[1], reverse=True))

def test_tencent():
    from tencent import APIClient
    from datetime import datetime, timedelta
    import time
    app_key, app_secret = '801073111', 'e40d3edd6f5cb8cd22645ca2b76d7a18'
    #token, token_secret = 'c2e525187099481e988ca059a4157ae5','8a45349204fc1c2fd533c2b9f33662a5'#account_id=385
    #token, token_secret = '1d1d93100c704b5fb42b6d3cd0c0e607','475f17c7306da659bd3b99f7191448f3'#account_id=542
    token, token_secret = '81980aeb96db4d53b37fc17e6e0eacaa','6da3246516d675f2445447104c1ec028'#account_id=495
    token, token_secret = '1671c86ab3a7496a92aea38b5a491675','8ab3b406e23efb36f329afb769eacf02'#account_id=495
    token, token_secret = 'fff1ec532c74460ba9c0075d69a9edb5','ae2d2a1cd63e65449da593683ceead79'#account_id=495
    client = APIClient(app_key, app_secret)
    client.set_access_token(token, token_secret)
    sorttype = 0
    contenttype = 4 #picture and url
    msgtype = 1     #original
    endtime = datetime.now()
    starttime = endtime - timedelta(hours=2)
    endtime = int(time.mktime(endtime.timetuple()))
    starttime = int(time.mktime(starttime.timetuple()))
    res = client.get.search__t(format='json',keyword=u'分享', pagesize=30, page=1, contenttype=2, sorttype=sorttype, msgtype=msgtype, searchtype=0, starttime=starttime, endtime=endtime)
    pprint(res)
    return
    pagetime = 1352248667
    mids = set()
    times = []
    f = open('history.res', 'w+')
    count = 0
    while True:
        count += 1
        res = client.get.statuses__home_timeline(format='json', pageflag=2, pagetime=pagetime, reqnum=70, type=0, contenttype='0x80')
        #pprint(res)
        if not res['data']['info']:
            print 'none update', datetime.now()
            pagetime=time.mktime(datetime.timetuple(datetime.now()))
            break
        timelines = res['data']['info']
        print 'len of timelines ',len(timelines)
        for t in timelines:
            if t.id not in mids:
                mids.add(t.id)
                time_ = datetime.fromtimestamp(t.timestamp).strftime('%Y-%m-%d %H:%m:%S')
                times.append(time_)
                if t.timestamp > 1352252432:
                    print 'end timestamp', t.timestamp
                    print 'return,len of mids', len(mids)
                    f.close()
                    return
                #print type(t.text)
                f.write(('mid: %s time %s text %s\n'%(t.id, time_, t.text)).encode('utf8'))
        pagetime = timelines[0].timestamp
        print 'pagetime', pagetime, datetime.fromtimestamp(pagetime).strftime('%Y-%m-%d %H:%m:%S')
        if pagetime > 1352252432:
            print 'arrive'
            break
        if count > 30:
            print 'total 30 times'
            break
        time.sleep(1)

    print 'len of mids', len(mids)
    f.close()

    #res = client.get.statuses__user_timeline(format='json', pageflag=0, pagetime=0, reqnum=20, type=0, contenttype=0, name='sasuke1984')
    #res = client.get.t__re_list(format='json', flag=1, rootid=131934075910505,  pageflag=0, pagetime=0, reqnum=20, twitterid=0)
    params = {}
    #res =  client.get.other__shorturl(format='json', url='http://url.cn/8Q3HPq')
    #print 'len ', len(res)
    #statuses = res['data']['info']
    #print statuses
    """
    ids = set()
    for s in statuses:
        print s.text.encode('utf8'), datetime.fromtimestamp(s.timestamp)
        if s.id not in ids:
            ids.add(s.id)
    print 'len', len(ids)

    start_idx = 0
    tag_counts = {}
    while True:
        name = ('Dirac0808', 'sasuke1984')[0]
        res = client.get.friends__user_idollist(format='json', reqnum=30, startindex=start_idx, name=name)
        #pprint(res)
        if res.data.curnum != 30:
            break
        for u in res.data.info:
            print u.nick, u.name, ', '.join(t.name for t in u.tag) if u.tag else ''
            if u.tag:
                for t in u.tag:
                    tag_counts[t.name] = tag_counts.get(t.name, 0) + 1
        start_idx += 30
    pprint(sorted(tag_counts.items(), key=lambda x: x[1], reverse=True))
    """

if __name__=='__main__':
    #test_sina()
    test_tencent()
